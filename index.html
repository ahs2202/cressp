<!DOCTYPE html>
<html lang="en">
    
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-9Z9W65R97H"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-9Z9W65R97H');
</script>
    
<head>
    <!-- Required meta tags (add the responsive viewport meta tag) -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description"
        content="Molecular Mimicry Map of SARS-CoV-2 web application">
    <title>CRESSP</title>
    
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="https://www.ebi.ac.uk/pdbe/pdb-component-library/css/pdbe-molstar-light-1.1.0-dev.4.css">
    <!--Bootstrap CSS library-->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
    <!--Google Icon CSS library-->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- JS -->
    <!-- IntervalTree package for searching matched records efficiently (binary-search-bounds and interval-tree-1d packages, browserified and minified) -->
    <script>require=function t(i,r,n){function e(h,o){if(!r[h]){if(!i[h]){var u="function"==typeof require&&require;if(!o&&u)return u(h,!0);if(s)return s(h,!0);var f=new Error("Cannot find module '"+h+"'");throw f.code="MODULE_NOT_FOUND",f}var l=r[h]={exports:{}};i[h][0].call(l.exports,(function(t){return e(i[h][1][t]||t)}),l,l.exports,t,i,r,n)}return r[h].exports}for(var s="function"==typeof require&&require,h=0;h<n.length;h++)e(n[h]);return e}({"binary-search-bounds":[function(t,i,r){"use strict";function n(t,i,r,n,e){var s=["function ",t,"(a,l,h,",n.join(","),"){",e?"":"var i=",r?"l-1":"h+1",";while(l<=h){var m=(l+h)>>>1,x=a[m]"];return e?i.indexOf("c")<0?s.push(";if(x===y){return m}else if(x<=y){"):s.push(";var p=c(x,y);if(p===0){return m}else if(p<=0){"):s.push(";if(",i,"){i=m;"),r?s.push("l=m+1}else{h=m-1}"):s.push("h=m-1}else{l=m+1}"),s.push("}"),e?s.push("return -1};"):s.push("return i};"),s.join("")}function e(t,i,r,e){return new Function([n("A","x"+t+"y",i,["y"],e),n("P","c(x,y)"+t+"0",i,["y","c"],e),"function dispatchBsearch",r,"(a,y,c,l,h){if(typeof(c)==='function'){return P(a,(l===void 0)?0:l|0,(h===void 0)?a.length-1:h|0,y,c)}else{return A(a,(c===void 0)?0:c|0,(l===void 0)?a.length-1:l|0,y)}}return dispatchBsearch",r].join(""))()}i.exports={ge:e(">=",!1,"GE"),gt:e(">",!1,"GT"),lt:e("<",!0,"LT"),le:e("<=",!0,"LE"),eq:e("-",!0,"EQ",!0)}},{}],"interval-tree-1d":[function(t,i,r){"use strict";var n=t("binary-search-bounds");function e(t,i,r,n,e){this.mid=t,this.left=i,this.right=r,this.leftPoints=n,this.rightPoints=e,this.count=(i?i.count:0)+(r?r.count:0)+n.length}i.exports=function(t){if(!t||0===t.length)return new d(null);return new d(p(t))};var s=e.prototype;function h(t,i){t.mid=i.mid,t.left=i.left,t.right=i.right,t.leftPoints=i.leftPoints,t.rightPoints=i.rightPoints,t.count=i.count}function o(t,i){var r=p(i);t.mid=r.mid,t.left=r.left,t.right=r.right,t.leftPoints=r.leftPoints,t.rightPoints=r.rightPoints,t.count=r.count}function u(t,i){var r=t.intervals([]);r.push(i),o(t,r)}function f(t,i){var r=t.intervals([]),n=r.indexOf(i);return n<0?0:(r.splice(n,1),o(t,r),1)}function l(t,i,r){for(var n=0;n<t.length&&t[n][0]<=i;++n){var e=r(t[n]);if(e)return e}}function c(t,i,r){for(var n=t.length-1;n>=0&&t[n][1]>=i;--n){var e=r(t[n]);if(e)return e}}function g(t,i){for(var r=0;r<t.length;++r){var n=i(t[r]);if(n)return n}}function a(t,i){return t-i}function v(t,i){var r=t[0]-i[0];return r||t[1]-i[1]}function P(t,i){var r=t[1]-i[1];return r||t[0]-i[0]}function p(t){if(0===t.length)return null;for(var i=[],r=0;r<t.length;++r)i.push(t[r][0],t[r][1]);i.sort(a);var n=i[i.length>>1],s=[],h=[],o=[];for(r=0;r<t.length;++r){var u=t[r];u[1]<n?s.push(u):n<u[0]?h.push(u):o.push(u)}var f=o,l=o.slice();return f.sort(v),l.sort(P),new e(n,p(s),p(h),f,l)}function d(t){this.root=t}s.intervals=function(t){return t.push.apply(t,this.leftPoints),this.left&&this.left.intervals(t),this.right&&this.right.intervals(t),t},s.insert=function(t){var i=this.count-this.leftPoints.length;if(this.count+=1,t[1]<this.mid)this.left?4*(this.left.count+1)>3*(i+1)?u(this,t):this.left.insert(t):this.left=p([t]);else if(t[0]>this.mid)this.right?4*(this.right.count+1)>3*(i+1)?u(this,t):this.right.insert(t):this.right=p([t]);else{var r=n.ge(this.leftPoints,t,v),e=n.ge(this.rightPoints,t,P);this.leftPoints.splice(r,0,t),this.rightPoints.splice(e,0,t)}},s.remove=function(t){var i=this.count-this.leftPoints;if(t[1]<this.mid)return this.left?4*(this.right?this.right.count:0)>3*(i-1)?f(this,t):2===(o=this.left.remove(t))?(this.left=null,this.count-=1,1):(1===o&&(this.count-=1),o):0;if(t[0]>this.mid)return this.right?4*(this.left?this.left.count:0)>3*(i-1)?f(this,t):2===(o=this.right.remove(t))?(this.right=null,this.count-=1,1):(1===o&&(this.count-=1),o):0;if(1===this.count)return this.leftPoints[0]===t?2:0;if(1===this.leftPoints.length&&this.leftPoints[0]===t){if(this.left&&this.right){for(var r=this,e=this.left;e.right;)r=e,e=e.right;if(r===this)e.right=this.right;else{var s=this.left,o=this.right;r.count-=e.count,r.right=e.left,e.left=s,e.right=o}h(this,e),this.count=(this.left?this.left.count:0)+(this.right?this.right.count:0)+this.leftPoints.length}else this.left?h(this,this.left):h(this,this.right);return 1}for(s=n.ge(this.leftPoints,t,v);s<this.leftPoints.length&&this.leftPoints[s][0]===t[0];++s)if(this.leftPoints[s]===t){this.count-=1,this.leftPoints.splice(s,1);for(o=n.ge(this.rightPoints,t,P);o<this.rightPoints.length&&this.rightPoints[o][1]===t[1];++o)if(this.rightPoints[o]===t)return this.rightPoints.splice(o,1),1}return 0},s.queryPoint=function(t,i){if(t<this.mid){if(this.left)if(r=this.left.queryPoint(t,i))return r;return l(this.leftPoints,t,i)}if(t>this.mid){var r;if(this.right)if(r=this.right.queryPoint(t,i))return r;return c(this.rightPoints,t,i)}return g(this.leftPoints,i)},s.queryInterval=function(t,i,r){var n;if(t<this.mid&&this.left&&(n=this.left.queryInterval(t,i,r)))return n;if(i>this.mid&&this.right&&(n=this.right.queryInterval(t,i,r)))return n;return i<this.mid?l(this.leftPoints,i,r):t>this.mid?c(this.rightPoints,t,r):g(this.leftPoints,r)};var y=d.prototype;y.insert=function(t){this.root?this.root.insert(t):this.root=new e(t[0],null,null,[t],[t])},y.remove=function(t){if(this.root){var i=this.root.remove(t);return 2===i&&(this.root=null),0!==i}return!1},y.queryPoint=function(t,i){if(this.root)return this.root.queryPoint(t,i)},y.queryInterval=function(t,i,r){if(t<=i&&this.root)return this.root.queryInterval(t,i,r)},Object.defineProperty(y,"count",{get:function(){return this.root?this.root.count:0}}),Object.defineProperty(y,"intervals",{get:function(){return this.root?this.root.intervals([]):[]}})},{"binary-search-bounds":"binary-search-bounds"}]},{},[]);</script>
    <!--For Using utility functions-->
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.19/lodash.min.js"></script>
    <script> lodash = _.noConflict(); // load script of lodash </script> 
    <!--Plotly-->
    <script src="https://cdn.plot.ly/plotly-1.58.4.js"></script>
<!--     1.54.7.min.js"></script> -->
    <!--PDB Mol*-->
    <script type="text/javascript" src="https://www.ebi.ac.uk/pdbe/pdb-component-library/js/pdbe-molstar-plugin-1.1.0-dev.4.js"></script>
    <!--For loading large csv files-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.2.0/papaparse.min.js"></script>
    <!--Python's Numpy-like Library, NumJS-->
    <script src="https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js"></script>
    <!--D3 to draw tables-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <!--chroma to draw colormaps-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.1.0/chroma.min.js"></script>
    <!--hotkeys to add keyboard shortcuts-->
    <script src="https://cdn.jsdelivr.net/npm/hotkeys-js@3.8.1/dist/hotkeys.min.js" integrity="sha256-4nmnbhmVpr2Rg64+7ysAr93+vQrfc0UvHWwm4W6uXJM=" crossorigin="anonymous"></script>
    
    <!--Datatable for efficient visualization of tabular data-->
    <!--full: jquery.dataTables.js, jquery.dataTables.css-->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.10.21/css/jquery.dataTables.min.css">
    <script type="text/javascript" charset="utf8" src="https://cdn.datatables.net/1.10.21/js/jquery.dataTables.min.js" crossorigin="anonymous"></script>
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV" crossorigin="anonymous"></script>
    <!-- dataframe.js for useful dataframe functions -->
    <script src="https://cdn.jsdelivr.net/npm/dataframe-js@1.4.3/dist/dataframe.min.js" integrity="sha256-ncD0rnpkULRQhB+hFzhFCQ4KBu+NKVYEQHyhxsUA29Q=" crossorigin="anonymous"></script>
    <!-- FileSaver.js to save js object as local files -->
    <script src="https://cdn.jsdelivr.net/npm/filesaver.js@1.3.4/FileSaver.min.js" integrity="sha256-5IjlS/EkXaEXRrVOMusSOlmQsyFy3DvCD5QC5mJZubU=" crossorigin="anonymous"></script>
    <!-- Html2Canvas.js to save current view as a PNG file -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.0.0-rc.7/dist/html2canvas.min.js" integrity="sha256-Ax1aqtvxWBY0xWND+tPZVva/VQZy9t1Ce17ZJO+NTRc=" crossorigin="anonymous"></script>
    <!-- Pako.js to parse base64 gzipped text file downloaded from remote location -->
    <script src="https://cdn.jsdelivr.net/npm/pako@1.0.11/dist/pako.min.js" integrity="sha256-Kc+gVCuYZLZkDP3MjxWxhNtkMbUy2ycCo86X5fKn/Bw=" crossorigin="anonymous"></script>
    <!-- Bootstrap-Toggle.js more more animated toggle button -->
    <link href="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap4-toggle@3.6.1/css/bootstrap4-toggle.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap4-toggle@3.6.1/js/bootstrap4-toggle.min.js"></script>
<!--   Tagify for search bar interaction   -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@yaireo/tagify@3.21.5/dist/tagify.css" integrity="sha256-JQCBuvZzuXrKFdHRTVW23P/DqnFsfvbI3kraGJhPyNA=" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/@yaireo/tagify@3.21.5/dist/tagify.min.js" integrity="sha256-6QmUlbXKkm+RVqvqtIzhhDQ3cqRkuREeUhNJDnL2ujM=" crossorigin="anonymous"></script>
    
    <!--To use font-awesome icons -->
<!--     <script src="https://kit.fontawesome.com/b773d81884.js" crossorigin="anonymous"></script> -->
    <!-- Fussy search package for alignment of given peptide sequences to consensus sequence -->
<!--     <script src="https://cdn.jsdelivr.net/npm/fuse-js-latest@3.1.0/dist/fuse.min.js" integrity="sha256-7f3wLI5WWMPufBdf3U8CNW6K7WYPoO83Iqvr+dd6k4Q=" crossorigin="anonymous"></script> -->
    <!--React and React-Bootstrap library-->
<!--     <script src="https://unpkg.com/react/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-bootstrap@next/dist/react-bootstrap.min.js" crossorigin></script>
    <script>var Alert = ReactBootstrap.Alert;</script> -->
    <style>
      * { box-sizing: border-box; }
        /* Create two equal columns that floats next to each other */
        .column {
          float: left;
          width: 50%;
          padding: 10px;
          height: 450px; /* Should be removed. Only for demonstration */
          position:relative;
        }
        /* Clear floats after the columns */
        .responsive_row_with_two_columns:after {
          float:left;
          content: "";
          display: table;
          clear: both;
        }
        /* Responsive layout - makes the two columns stack on top of each other instead of next to each other */
        @media screen and (max-width: 700px) {
          .column {
            width: 100%;
          }
        }
        .deconstructed_pancake_box { /* example in https://web.dev/one-line-layouts/ */
            flex: 1 1 450px;
            margin: 5px;
        }
        .deconstructed_pancake_parent {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        .container_molstar {
          height: 600px; /* Should be modified */
          position:relative;
        }
        #container_d3_table_metrics{
          display: grid;
          grid-template-rows: auto 1fr auto;
          position:relative;
        }
        #plotly_graph_molecular_mimicry_map{
            float:left;
            width:100%;
            padding: 5px;
            height:575px;
            position:relative;
            overflow:hidden;
        }
        .graph_for_selection{
            float:left;
            width:100%;
            height:350px;
            position:relative;
        }
/*    custom bootstrap button color   */
        .bg-custom-navbar{  /* custom navbar color and gradient (color representing lupus awareness color) */
            background-image: linear-gradient( 15deg, #004d4d 0%, #00e0e0 100%);
        }
        .bg-custom-navbar-secondary{  /* custom navbar color and gradient for secondary navbar (color representing lupus awareness color) */
            background-image: linear-gradient( 20deg, #46137a 0%, #f08dee 100%);
        }
        .bg-custom-navbar-hidden{  /* custom navbar color and gradient (color representing lupus awareness color) */
            border-left: 6px solid #ccc;
            border-bottom: 3px solid #ccc;
            color: #000;
            border-color: #6b0596;
            background-color: #f8f7fa;
/*             '#fce6ff; #dfdae6; #f3f0f7; */
        }
        .bg-custom-navbar-top{  /* custom navbar color and gradient (color representing lupus awareness color) */
            background-image: linear-gradient( 0deg, #ababab 0%, #f7f7f7 100%);
        }
        /* CSS for D3 Table */
        table { border-collapse: collapse; color: #333; background-color: #F7F6F3; margin: auto; } /* place the table in the middle of div */
        table thead { font-weight: bold; background-color: #CCC; cursor: default; text-align: center; }
        table tbody tr:hover { background-color: #FFC; }
        td { border: solid 1px #CCC; padding: 0 1ex; }
        .table_even { color: #284775; background-color: White; }
        .table_left { text-align: left; }
        .table_center { text-align: center; }
        .table_right { text-align: right; }
        .table_add { color: green; }
        .table_minus { color: red; }
        
        #button_scroll_to_the_top { /* CSS for Scroll Back To Top Button */
          display: none; /* Hidden by default */
          position: fixed; /* Fixed/sticky position */
          bottom: 20px; /* Place the button at the bottom of the page */
          right: 30px; /* Place the button 30px from the right */
          z-index: 99; /* Make sure it does not overlap */
          border: none; /* Remove borders */
          outline: none; /* Remove outline */
          background-color: DarkViolet; /* Set a background color */
          color: white; /* Text color */
          cursor: pointer; /* Add a mouse pointer on hover */
          padding: 15px; /* Some padding */
          border-radius: 10px; /* Rounded corners */
          font-size: 18px; /* Increase font size */
        }
/*     for tidy organization of buttons     */
        .btn { 
            margin-bottom: 0px !important;
        }
        #button_scroll_to_the_top:hover {
          background-color: #555 ; /* Indigo Add a dark-grey background on hover */
        }
        .helpIcon
        {
          cursor: pointer;
          padding-top:12px;
        }
        i.icon-white {
            color: white;
            display:inline-flex;
            vertical-align:middle;
        }
        i.icon-black {
            color: black;
            display:inline-flex;
            vertical-align:middle;
        }
        /* for labeled buttons */
        .btn-label {position: relative;left: -12px;display: inline-block;padding: 6px 12px;background: rgba(0,0,0,0.1);border-radius: 3px 0 0 3px;}
        .btn-labeled {padding-top: 0;padding-bottom: 0;}
        .btn { margin-bottom:10px; }
        /* for  div. displayed during loading (https://stackoverflow.com/questions/54439548/display-loading-symbol-while-waiting-for-a-result-with-plot-ly-dash) */
        @keyframes fadein {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 0.5;
            }
        }
        ._plotly-loading-callback {
          font-family: sans-serif;
          padding-top: 50px;
          color: rgb(90, 90, 90);

          /* The banner */
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          text-align: center;
          cursor: progress;

          opacity: 0;
          background-color: rgb(250, 250, 250);
          /* Delay animation by 1s to prevent flashing 
             and smoothly transition the animation over 0.5s 
           */
          -moz-animation: fadein 0.5s ease-in 1s forwards; /* Firefox */
          -webkit-animation: fadein 0.5s ease-in 1s forwards; /* Safari and Chrome */
          -o-animation: fadein 0.5s ease-in 1s forwards; /* Opera */
            animation: fadein 0.5s ease-in 1s forwards;
        }
        /* Add an extra .carousel parent class to increase specificity
           avoiding the use of !important flag. */
        .carousel-caption {
            color: black;
        }
        .carousel .carousel-indicators li {
            background-color: #fff;
            background-color: rgba(70, 70, 70, 0.25);
        }

        .carousel .carousel-indicators .active {
            background-color: #444;
        }
        .carousel .carousel-indicators li {
            background-color: #fff;
            background-color: rgba(70, 70, 70, 0.25);
        }

        .carousel .carousel-indicators .active {
            background-color: #444;
        }
        .carousel-control-next,
        .carousel-control-prev {
            filter: invert(100%);
        }
        /* for loading SVG images */
/*         .loader{
          margin: 0 0 2em;
          height: 100px;
          width: 100%;
          text-align: center;
          padding: 1em;
          margin: 0 auto 1em;
          display: inline-block;
          vertical-align: top;
        } */
/*  https://gitbrent.github.io/bootstrap4-toggle/ custom settings  */
          .toggle.ios, .toggle-on.ios, .toggle-off.ios { border-radius: 20rem; }
          .toggle.ios .toggle-handle { border-radius: 20rem; }
        
        
/*    Drag & Drop file input box   */
    #filedrag
    {
        display: none;
        font-weight: bold;
        text-align: center;
        padding: 1em 0;
        margin: 1em 0;
        color: #555;
        border: 2px dashed #555;
        border-radius: 7px;
        cursor: default;
    }

    #filedrag.hover
    {
        color: #8c00ff;
        border-color: #8c00ff;
        border-style: solid;
        box-shadow: inset 0 3px 4px #888;
    }

    </style>
    <!-- icon of the document -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2020%2020'%3E%3Ctext%20x='0'%20y='16'%20style='filter:%20invert(100%);'%3E🌱%3C/text%3E%3C/svg%3E" type="image/svg+xml" />
</head>

<body>
 <!-- where captured current view is stored as a data URL  -->
<a id="anchor-current-view" href="#" hidden></a>
</div>
<!-- start of the current view container -->
<div id="molecularmimicrymap-current-view">
<nav class="navbar navbar-expand-lg navbar-dark bg-custom-navbar"> <!-- sticky-top -->
    <a class="navbar-brand mb-0 h1">CRESSP Web Viewer</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav_top" aria-controls="navbarNav_top" aria-expanded="false" aria-label="Toggle top navigation"><span class="navbar-toggler-icon"></span></button>
    <div class="collapse navbar-collapse" id="navbarNav_top">
        
        <ul class="navbar-nav">
            <li class="nav-item">
                <div class="form-check form-check-inline" id="toggle_alignment_mode_container">
                    <input id="toggle_alignment_mode" type="checkbox" checked data-toggle="toggle" data-on="Aligned to Target" data-off="Aligned to Query" data-onstyle="secondary" data-offstyle="light" data-style="ios" data-width="12rem" data-height="calc(1.5em + .75rem + 2px)" onchange="Load_Dataset( )">
                </div>
            </li>
        </ul>

        <button type="button" class="btn btn-light bth-sm ml-auto mr-1 my-0" aria-label="capture current view and download it as a PNG file" data-tooltip="tooltip" data-placement="left" data-html="true" title="Capture <b>current view</b> and download it as a PNG file" onclick="DownloadCurrentView( )"><i class="material-icons icon-black" style="font-size:25px">camera_alt</i></button>
        <button type="button" class="btn btn-light bth-sm ml-1 mr-1 my-0" aria-label="show keyboard shortcuts" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to show <b>keyboard shortcuts</b>" onclick="$( '#modal_keyboard_shortcuts' ).modal( 'show' )"><i class="material-icons icon-black" style="font-size:25px">keyboard</i></button>
        <button type="button" class="btn btn-light bth-sm ml-1 my-0" aria-label="toggle tooltips" data-tooltip-always-active="tooltip" data-placement="bottom" data-html="true" title="Press to <b>on/off</b> help messages on mouse over (hover) of certain buttons" onclick="Toggle_Tooltips( )"><i class="material-icons icon-black" style="font-size:25px">help_outline</i></button>
    </div>
</nav>
<button onclick="Scroll_to_the_Top( )" id="button_scroll_to_the_top" title="Go to top">Top</button>
<div>
    <div class="collapse" id="container_fileLoader"><div><input type="file" id="file-selector" multiple></div></div>
</div>
<div id="molecular_mimicry_map">
    <div id="container_molecular_mimicry_map">
        <div id="controlBox_plotly_graph_molecular_mimicry_map">
            <div class="pos-f-t">
                <nav class="navbar navbar-dark bg-custom-navbar">
                    <form class="form-inline">
                        <button class="navbar-toggler mr-2" type="button" data-toggle="collapse" data-target="#navbarToggleExternalContent__plotly_graph_molecular_mimicry_map" aria-controls="navbarToggleExternalContent__plotly_graph_molecular_mimicry_map" aria-expanded="false" aria-label="Toggle navigation" data-tooltip="tooltip" data-placement="right" data-html="true" title="Press to change default graph settings and turn on/off tracks"><i class="material-icons icon-white" style="font-size:20px;cursor:pointer">settings</i></button>
                        <a class="mb-0" style="color:white; font-size:0.8em" id="text_number_of_records"></a>
                    </form>
                    
                    <form class="form-inline">
                        <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="button" data-tooltip="tooltip" data-placement="left" data-html="true" title="Press to <b>on/off</b> the <i>legend</i> of the graph" id="button_toggle_legend_MolecularMimicryMap" onclick="Toggle_Legend_MolecularMimicryMap( )"><i class="material-icons icon-black" style="font-size:20px">list</i></button>
                        <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="button" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>on/off</b> displaying <i>record details</i> on hover (mouse over). It will <b>also disable click events</b>." id="button_toggle_hovermode_MolecularMimicryMap" onclick="Toggle_Hovermode_MolecularMimicryMap( )"><i class="material-icons icon-black" style="font-size:20px">article</i></button>
                        
                        <button class="btn btn-light btn-sm active ml-1 mr-1 my-0" type="button" data-toggle="button" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> B-cell cross-reactivity prediction data" aria-label="Press to toggle B-cell cross-reactivity prediction data" id="toggle_BCellCrossReactivityPrediction_MolecularMimicryMap" onclick="Toggle_BCellCrossReactivityPrediction_MolecularMimicryMap( )" autocomplete="off" aria-pressed="true">B-Cell Cross-Reactivity</button>
                        <button class="btn btn-light btn-sm active ml-0 mr-1 my-0" type="button" data-toggle="button" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> T-cell cross-reactivity prediction data" aria-label="Press to toggle T-cell cross-reactivity prediction data" id="toggle_TCellCrossReactivityPrediction_MolecularMimicryMap" onclick="Toggle_TCellCrossReactivityPrediction_MolecularMimicryMap( )" autocomplete="off" aria-pressed="true">T-Cell Cross-Reactivity</button>
                        <button class="btn btn-light btn-sm active mx-1 my-0" type="button" data-toggle="button" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> SARS-CoV-2 target protein annotations and InterPro protein domain annotations" aria-label="Press to toggle SARS-CoV-2 target protein annotations and InterPro protein domain annotations" id="toggle_ProteinAnnotation_MolecularMimicryMap" onclick="Toggle_ProteinAnnotation_MolecularMimicryMap( )" autocomplete="off" aria-pressed="true">Protein Annotations</button>
                    </form>
                </nav>
                <div class="collapse" id="navbarToggleExternalContent__plotly_graph_molecular_mimicry_map">
                    <div class="bg-custom-navbar-hidden p-4">
                        <h4 class="text-black">CRESSP Main Graph Setting Panel</h4>
                        <p>
                            <h5 class="text-muted">General Setting</h5>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><span class="input-group-text">Plot height is</span></div>
                                    <input type="text" class="form-control" aria-label="height of the plot in pixel" id="input_plot_height_MolecularMimicryMap" title="input field for setting the height of Molecular Mimicry Map plot in pixels" value="750">
                                    <div class="input-group-append"><span class="input-group-text">pixels</span></div>
                                </div>
                            </div>
                        </p>
                        <p>
                            <h5 class="text-muted">B Cell Cross-Reactivity Prediction Data</h5>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><span class="input-group-text">Y axis represents</span></div>
                                    <select class="custom-select w-auto" id="select_YAxis_BCellCrossReactivity" title="select y-axis values for plotting">
                                        <option value="score_blosum">Sum of BLOSUM62 Scores</option>
                                        <option value="score_blosum_weighted">Sum of Accessibility-Weighted BLOSUM62 Scores</option>
                                        <option value="sum_of_weights">Sum of Relative Surface Accessible Areas</option>
                                        <option value="avg_score_blosum_weighted" selected>Average Accessibility-Weighted BLOSUM62 Score</option>
                                        <option value="score_similarity_ss8">Secondary Structure Similarity</option>
                                        <option value="correl_coeffi_acc">Correlation Coefficient of Accessibility</option>
                                        <option value="correl_coeffi_phi">Correlation Coefficient of Phi (ϕ)</option>
                                        <option value="correl_coeffi_psi">Correlation Coefficient of Psi (Ψ)</option>
                                        <option value="duplicate_counts">Duplicate Counts</option>
                                    </select>
                                </div>
                            </div>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><span class="input-group-text">Size of point (or width of line) represents</span></div>
                                    <select class="custom-select w-auto" id="select_Size_BCellCrossReactivity" title="select size (line thickness) values for plotting">
                                        <option value="score_blosum">Sum of BLOSUM62 Scores</option>
                                        <option value="score_blosum_weighted">Sum of Accessibility-Weighted BLOSUM62 Scores</option>
                                        <option value="sum_of_weights" selected>Sum of Relative Surface Accessible Areas</option>
                                        <option value="avg_score_blosum_weighted">Average Accessibility-Weighted BLOSUM62 Score</option>
                                        <option value="score_similarity_ss8">Secondary Structure Similarity</option>
                                        <option value="correl_coeffi_acc">Correlation Coefficient of Accessibility</option>
                                        <option value="correl_coeffi_phi">Correlation Coefficient of Phi (ϕ)</option>
                                        <option value="correl_coeffi_psi">Correlation Coefficient of Psi (Ψ)</option>
                                        <option value="duplicate_counts">Duplicate Counts</option>
                                    </select>
                                </div>
                            </div>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><span class="input-group-text">Opacity of point represents</span></div>
                                    <select class="custom-select w-auto" id="select_Opacity_BCellCrossReactivity" title="select opacity values for plotting">
                                        <option value="score_blosum">Sum of BLOSUM62 Scores</option>
                                        <option value="score_blosum_weighted">Sum of Accessibility-Weighted BLOSUM62 Scores</option>
                                        <option value="sum_of_weights">Sum of Relative Surface Accessible Areas</option>
                                        <option value="avg_score_blosum_weighted">Average Accessibility-Weighted BLOSUM62 Score</option>
                                        <option value="score_similarity_ss8">Secondary Structure Similarity</option>
                                        <option value="correl_coeffi_acc" selected>Correlation Coefficient of Accessibility</option>
                                        <option value="correl_coeffi_phi">Correlation Coefficient of Phi (ϕ)</option>
                                        <option value="correl_coeffi_psi">Correlation Coefficient of Psi (Ψ)</option>
                                        <option value="duplicate_counts">Duplicate Counts</option>
                                    </select>
                                </div>
                            </div>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><span class="input-group-text">Plot top</span></div>
                                    <input type="text" class="form-control" aria-label="the number of alignments for plotting" id="input_n_alignments_for_plotting_BCellCrossReactivity" title="input field for setting the number of alignments for plotting B Cell Cross-Reactivity prediciton data" value="1000">
                                    <div class="input-group-append"><span class="input-group-text">most significant aligned sequences for window size of</span></div>
                                    <select class="custom-select w-auto" id="select_windowSize_BCellCrossReactivity" title="window size for B cell cross-reactivity prediction data">
                                        <option value="select">select window size</option>
                                    </select>
                                    <div class="input-group-append"><label class="input-group-text" for="select_windowSize_BCellCrossReactivity">amino acids.</label></div>
                                </div>
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><label class="input-group-text" for="select_representation_of_an_alignment_BCellCrossReactivity">Represent each alignment with a</label></div>
                                    <select class="custom-select w-auto" id="select_representation_of_an_alignment_BCellCrossReactivity" title="select a representation of an alignment in B cell cross-reactivity prediction data">
                                        <option value="1">select a representation</option>
                                        <option value="0" selected>point (faster)</option>
                                        <option value="1">line (slower)</option>
                                    </select>
                                    <div class="input-group-append"><label class="input-group-text" for="select_representation_of_an_alignment_BCellCrossReactivity">on a</label></div>
                                    <select class="custom-select w-auto" id="select_graphic_format_BCellCrossReactivity" title="select a graphic format of representations of B cell cross-reactivity prediction data">
                                        <option value="0">select a graphic format</option>
                                        <option value="0" selected>bitmap (faster)</option>
                                        <option value="1">vector (scalable, but slower)</option>
                                    </select>
                                    <div class="input-group-append"><label class="input-group-text" for="select_graphic_format_BCellCrossReactivity">image.</label></div>
                                </div>
                            </div>
                        </p>
                        <p>
                            <h5 class="text-muted">T Cell Cross-Reactivity Prediction Data</h5>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><span class="input-group-text">Y axis represents</span></div>
                                    <select class="custom-select w-auto" id="select_YAxis_TCellCrossReactivity" title="select y-axis values for plotting">
                                        <option value="score_blosum">Sum of BLOSUM62 Scores</option>
                                        <option value="average_score_blosum" selected>Average BLOSUM62 Score</option>
                                        <option value="score_geometric_mean">-Log of Geometric Average of Predicted Binding Affinities (IC50) of query and target Peptides</option>
                                    </select>
                                </div>
                            </div>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><span class="input-group-text">Plot top</span></div>
                                    <input type="text" class="form-control" aria-label="the number of alignments for plotting" id="input_n_alignments_for_plotting_TCellCrossReactivity" title="input field for setting the number of alignments for plotting T Cell Cross-Reactivity prediciton data" value="1000">
                                    <div class="input-group-append"><span class="input-group-text">most significant aligned sequences for MHC class I and II molecules.</span></div>
                                </div>
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><label class="input-group-text" for="select_representation_of_an_alignment_TCellCrossReactivity">Represent each pair of predicted binding scores with a</label></div>
                                    <select class="custom-select w-auto" id="select_representation_of_an_alignment_TCellCrossReactivity" title="select a representation for a pair of predicted binding scores in T cell cross-reactivity prediction data">
                                        <option value="1">select a representation</option>
                                        <option value="0" selected>point (Y down/up)</option>
                                        <option value="1">point (star-triangle down/up)</option>
                                        <option value="2">point (bowtie/hourglass)</option>
                                    </select>
                                    <div class="input-group-append"><label class="input-group-text" for="select_representation_of_an_alignment_TCellCrossReactivity">(query/target) on a</label></div>
                                    <select class="custom-select w-auto" id="select_graphic_format_TCellCrossReactivity" title="select a graphic format of representations of T cell cross-reactivity prediction data">
                                        <option value="0">select a graphic format</option>
                                        <option value="0" selected>bitmap (faster)</option>
                                        <option value="1">vector (scalable, but slower)</option>
                                    </select>
                                    <div class="input-group-append"><label class="input-group-text" for="select_graphic_format_TCellCrossReactivity">image.</label></div>
                                </div>
                            </div>
                        </p>
                        <p><button type="button" class="btn btn-secondary btn-block mx-2 my-2" onclick="DrawMolecularMimicryMap( ); Loading_Screen( false );">Load and Draw</button></p>
                    </div>
                </div>
            </div>
        </div>
        <div id="container_searchbox_main">
            <input name='tags' id='searchbox_main' placeholder='Enter Gene Symbol' value='' data-blacklist='.NET,PHP'>
        </div>
        <div id="container_graph_molecular_mimicry_map">
            <div id="plotly_graph_molecular_mimicry_map"></div>
            <div id="container_d3_table_metrics">
                </div>
            </div>
        </div>
    </div>
    <div>
        <nav class="navbar navbar-dark bg-custom-navbar">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarToggleExternalContent_supplementary_graph_setting_panel" aria-controls="navbarToggleExternalContent_supplementary_graph_setting_panel" aria-expanded="false" aria-label="Toggle supplementary plot setting panel" data-tooltip="tooltip" data-placement="right" data-html="true" title="Press to <b>select or remove columns</b> in for <i>parallel coordinate graphs</i> for filtering cross-reactivity prediction data"><i class="material-icons icon-white" style="font-size:20px;cursor:pointer">settings</i></button>
            <form class="form-inline">
                <button class="btn btn-light btn-sm mx-1 my-0" type="button" aria-expanded="false" aria-controls="plotly_graph_b_cell_cross_reactivity" onclick="Toggle_Exclusive_Tabs( '#plotly_graph_b_cell_cross_reactivity' )" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> a parallel coordinate graph for <i>filtering</i> B-cell cross-reactivity prediction data" aria-label="Press to toggle a parallel coordinate graph for filtering B-cell cross-reactivity prediction data">B-Cell Cross-Reactivity Filter</button>
                <button id="btn_toggle_mhc_cross_reactivity_metrics" class="btn btn-light btn-sm mx-1 my-0" type="button" aria-expanded="false" aria-controls="plotly_graph_t_cell_cross_reactivity" onclick="Toggle_Exclusive_Tabs( '#plotly_graph_t_cell_cross_reactivity' )" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> a parallel coordinate graph for <i>filtering</i> T-cell cross-reactivity prediction data" aria-label="Press to toggle a parallel coordinate graph for filtering T-cell cross-reactivity prediction data">T-Cell Cross-Reactivity Filter</button>
                <button id="btn_toggle_query_protein_metrics" class="btn btn-light btn-sm mx-1 my-0" type="button" aria-expanded="false" aria-controls="plotly_graph_query_protein" onclick="Toggle_Exclusive_Tabs( '#plotly_graph_query_protein' )" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> a parallel coordinate graph for <i>filtering</i> query proteins" aria-label="Press to toggle a parallel coordinate graph for filtering query proteins">query Protein Filter</button>
                <button class="btn btn-light btn-sm mx-1 my-0" type="button" aria-controls="#container_datatable_panel_MolecularMimicryMap" aria-expanded="false" onclick="Toggle_Exclusive_Tabs( '#container_datatable_panel_MolecularMimicryMap' )" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> a panel for exploring associated data using a <i>data table</i>. Data records associated with <b>a specific query protein can be highlighted</b> by entering the <i>UniProt accession</i> of the protein" aria-label="Press to toggle a panel for exploring associated data using a data table. Data records associated with a specific query protein can be highlighted by entering the UniProt accession of the protein">Data Tables</button>
<!--                 <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="collapse" data-toggle="button" data-target="#container_d3_table_metrics" aria-expanded="false" aria-controls="container_d3_table_metrics">Record Details</button> -->
                <button id="btn_toggle_gene_expression_panel" class="btn btn-light btn-sm mx-1 my-0" type="button" aria-expanded="false" aria-controls="container_expression_panel_MolecularMimicryMap" onclick='Toggle_Panel( "#container_expression_panel_MolecularMimicryMap" )' data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> a panel showing <b>mRNA expression</b> of the selected query protein" aria-label="Press to toggle a panel showing mRNA expression of the selected query protein">Expression</button>
                <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="collapse" data-toggle="button" data-target="#container_plotly_table_sequence" aria-expanded="false" aria-controls="container_plotly_table_sequence"data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> <i>a table</i> showing <b>predicted/experimental structural properties</b> of aligned query and SARS-CoV-2 target proteins" aria-label="">Aligned Sequences</button>
                <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="collapse" data-toggle="button" data-target="#container_PDB" aria-expanded="false" aria-controls="container_PDB"data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> <i>molecule structure viewers</i> displaying aligned query and SARS-CoV-2 target <i>protein structures</i>. Aligned residues were colored between <i>red to green</i> based on the <b>BLOSUM62 score</b> of the alignment at each position." aria-label="Press to toggle molecule structure viewers displaying aligned query and SARS-CoV-2 target protein structures">Aligned Structures</button> 
            </form>
        </nav>
        <div class="collapse" id="navbarToggleExternalContent_supplementary_graph_setting_panel">
            <div class="bg-custom-navbar-hidden p-4">
                <h4 class="text-muted" style="display: inline-block;">CRESSP Web Viewer<h4>
                <h4 class="text-black"> Supplementary Graph Setting Panel</h4>
                <p>
                    <h5 class="text-muted">B Cell Cross-Reactivity Prediction Metrics</h5>
                    <div class="form-group">
                        <label for="selectmultiple_BCellCrossReactivityMetrics">Select columns <i class="material-icons" style="font-size:20px;cursor:pointer" data-toggle="tooltip" data-placement="right" title="Press ⌘ or Control Key to multi-select">help</i></label>
                        <select multiple class="form-control" id="selectmultiple_BCellCrossReactivityMetrics" size="9">
                            <option selected value="-log10( e-value )">-log10( e-value )</option>
                            <option selected value="score_blosum">score_blosum</option>
                            <option selected value="score_blosum_weighted">score_blosum_weighted</option>
                            <option value="avg_score_blosum_weighted">avg_score_blosum_weighted</option>
                            <option selected value="sum_of_weights">sum_of_weights</option>
                            <option selected value="score_similarity_ss8">score_similarity_ss8</option>
                            <option selected value="correl_coeffi_acc">correl_coeffi_acc</option>
                            <option selected value="correl_coeffi_phi">correl_coeffi_phi</option>
                            <option selected value="correl_coeffi_psi">correl_coeffi_psi</option>
                            <option value="correl_p_value_acc">correl_p_value_acc</option>
                            <option value="correl_p_value_phi">correl_p_value_phi</option>
                            <option value="correl_p_value_psi">correl_p_value_psi</option>
                            <option selected value="duplicate_counts">duplicate_counts</option>
                            <option selected value="identity">identity</option>
                            <option value="source_is_blastp">source_is_blastp</option>
                            <option value="structure_id_target_is_a_homology_modeling_result">structure_id_target_is_a_homology_modeling_result</option>
                            <option selected value="window_size">window_size</option>
                        </select>
                    </div>
                </p>
                <p><button type="button" class="btn btn-secondary btn-block mx-2 my-2" onclick="UpdateBCellCrossReactivityPredMetricsPlot( )">Load and Draw</button></p>
                <p>
                    <h5 class="text-muted">T Cell Cross-Reactivity Prediction Metrics</h5>
                    <div class="form-group">
                        <label for="selectmultiple_TCellCrossReactivityMetrics">Select columns <i class="material-icons" style="font-size:20px;cursor:pointer" data-toggle="tooltip" data-placement="right" title="Press ⌘ or Control Key to multi-select">help</i></label>
                        <select multiple class="form-control" id="selectmultiple_TCellCrossReactivityMetrics" size="8">
                            <option selected value="mhc_class">mhc_class</option>
                            <option selected value="score_blosum">score_blosum</option>
                            <option selected value="log10( score_geometric_mean_query )">log10( score_geometric_mean_query )</option>
                            <option selected value="log10( score_geometric_mean_target )">log10( score_geometric_mean_target )</option>
                            <option selected value="window_size">window_size</option>
                            <option value="-log10( e-value )">-log10( e-value )</option>
                            <option selected value="duplicate_counts">duplicate_counts</option>
                            <option value="source_is_blastp">source_is_blastp</option>
                        </select>
                    </div>
                </p>
                <p><button type="button" class="btn btn-secondary btn-block mx-2 my-2" onclick="UpdateTCellCrossReactivityPredMetricsPlot( )">Load and Draw</button></p>
                <p>
                    <h5 class="text-muted">query Protein Metrics</h5>
                    <div class="form-group">
                        <label for="selectmultiple_queryProteinMetrics">Select columns <i class="material-icons" style="font-size:20px;cursor:pointer" data-toggle="tooltip" data-placement="right" title="Press ⌘ or Control Key to multi-select">help</i></label>
                        <select multiple class="form-control" id="selectmultiple_queryProteinMetrics" size="8">
                            <option value="Adipose Tissue (n=1204) (log10)">Adipose Tissue (n=1204) (log10)</option>
                            <option value="Adrenal Gland (n=258) (log10)">Adrenal Gland (n=258) (log10)</option>
                            <option value="Bladder (n=21) (log10)">Bladder (n=21) (log10)</option>
                            <option selected value="Blood (n=929) (log10)">Blood (n=929) (log10)</option>
                            <option selected value="Blood Vessel (n=1335) (log10)">Blood Vessel (n=1335) (log10)</option>
                            <option selected value="Brain (n=2642) (log10)">Brain (n=2642) (log10)</option>
                            <option value="Breast (n=459) (log10)">Breast (n=459) (log10)</option>
                            <option value="Cervix Uteri (n=19) (log10)">Cervix Uteri (n=19) (log10)</option>
                            <option value="Colon (n=779) (log10)">Colon (n=779) (log10)</option>
                            <option value="Esophagus (n=1445) (log10)">Esophagus (n=1445) (log10)</option>
                            <option value="Fallopian Tube (n=9) (log10)">Fallopian Tube (n=9) (log10)</option>
                            <option value="Heart (n=861) (log10)">Heart (n=861) (log10)</option>
                            <option value="Kidney (n=89) (log10)">Kidney (n=89) (log10)</option>
                            <option value="Liver (n=226) (log10)">Liver (n=226) (log10)</option>
                            <option selected value="Lung (n=578) (log10)">Lung (n=578) (log10)</option>
                            <option value="Muscle (n=803) (log10)">Muscle (n=803) (log10)</option>
                            <option selected value="Nerve (n=619) (log10)">Nerve (n=619) (log10)</option>
                            <option value="Ovary (n=180) (log10)">Ovary (n=180) (log10)</option>
                            <option value="Pancreas (n=328) (log10)">Pancreas (n=328) (log10)</option>
                            <option value="Pituitary (n=283) (log10)">Pituitary (n=283) (log10)</option>
                            <option value="Prostate (n=245) (log10)">Prostate (n=245) (log10)</option>
                            <option value="Salivary Gland (n=162) (log10)">Salivary Gland (n=162) (log10)</option>
                            <option value="Skin (n=1809) (log10)">Skin (n=1809) (log10)</option>
                            <option value="Small Intestine (n=187) (log10)">Small Intestine (n=187) (log10)</option>
                            <option value="Spleen (n=241) (log10)">Spleen (n=241) (log10)</option>
                            <option value="Stomach (n=359) (log10)">Stomach (n=359) (log10)</option>
                            <option value="Testis (n=361) (log10)">Testis (n=361) (log10)</option>
                            <option value="Thyroid (n=653) (log10)">Thyroid (n=653) (log10)</option>
                            <option value="Uterus (n=142) (log10)">Uterus (n=142) (log10)</option>
                            <option value="Vagina (n=156) (log10)">Vagina (n=156) (log10)</option>
                            
                            <option selected value="AAgAtlas___n_PubMed_ID">AAgAtlas___n_PubMed_ID</option>
                            <option selected value="IEDB___n_unique_epitopes">IEDB___n_unique_epitopes</option>
                            <option selected value="n_counts">n_counts</option>
                            <option value="seq_length">seq_length</option>
                        </select>
                    </div>
                </p>
                <p><button type="button" class="btn btn-secondary btn-block mx-2 my-2" onclick="UpdatequeryProteinMetricsPlot( )" id="button_update_query_protein_metrics_plot">Load and Draw</button></p>
            </div>
        </div>
        <div id="plotly_graph_b_cell_cross_reactivity" class="collapse graph_for_selection"></div>
        <div id="plotly_graph_t_cell_cross_reactivity" class="collapse graph_for_selection"></div>
        <div id="plotly_graph_query_protein" class="collapse graph_for_selection"></div>
        <div id="container_datatable_panel_MolecularMimicryMap" class="collapse">
            <nav class="navbar navbar-dark bg-custom-navbar">
                <a class="navbar-brand mb-0 h5">Data Tables</a>
                <div class="btn-toolbar" role="toolbar">
                    <div class="input-group mr-2 ml-1 my-0">
<!--                         <div class="input-group-prepend"><label class="input-group-text" for="input_n_records_for_datatable">Display top</label></div>
                        <input type="text" class="form-control" aria-label="the number of records in the datatable to display" id="input_n_records_for_datatable" title="input field for setting the number of records for display a datatable" value="1000">
                        <div class="input-group-append"><span class="input-group-text">records for</span></div> -->
                        <select class="custom-select w-auto" id="select_datatable" title="select datatable">
                            <option value="acc_query.tsv">select datatable</option>
                            <option value="acc_query.tsv" selected>aligned query proteins</option>
                            <option value="acc_target_representative.tsv">representative target proteins</option>
                            <option value="mhc_allele.tsv">MHC alleles</option>
                            <option value="interpro_target.tsv">InterPro target protein annotation</option>
<!--                             <option value="iedb_epitope_target.tsv">IEDB SARS-CoV-2 epitopes</option> -->
                        </select>
                        <div class="input-group-append"><span class="input-group-text">datatable</span></div>
                    </div>
                    <button type="button" class="btn btn-light mx-0 my-0" id="button_display_datatable" aria-pressed="false" onclick="Display_DataTable( )" autocomplete="off">Show</button>
                    <button class="btn btn-light ml-1 mr-2 my-0" type="button" onclick="Download_DataTable( )" data-tooltip="tooltip" data-placement="bottom" title="Press to download current datatable as a CSV file"><i class="material-icons icon-black" style="font-size:20px;cursor:pointer">get_app</i></button> 
                </div>
<!--        currently searching using the search box above the datatable is not supported       -->
<!--                 <form class="form-inline">
                    <input class="form-control" type="search" placeholder="Highlight Value" aria-label="Highlight Value" id="input_highlight_value">
                    <button class="btn btn-light mx-2 my-0" type="button" onclick="Highlight_MolecularMimicryMap( )">Highlight</button>
                    <button class="btn btn-light mx-2 my-0" type="button" onclick="Clear_Highlight_MolecularMimicryMap( )">Clear Highlight</button>
                </form> --> 
                <button type="button" class="close" aria-label="Close container_datatable_panel_MolecularMimicryMap" data-toggle="collapse" data-target="#container_datatable_panel_MolecularMimicryMap"><span aria-hidden="true">&times;</span></button>
            </nav>
            <div id="container_datatable_MolecularMimicryMap"><table id="datatable_MolecularMimicryMap" class="display" width="100%"></table></div>
        </div>
        <div id="container_expression_panel_MolecularMimicryMap" class="collapse">
            <nav class="navbar navbar-dark bg-custom-navbar">
                <a class="navbar-brand mb-0 h5">Expression</a>
                <div class="btn-toolbar" role="toolbar">
                </div>
                <form class="form-inline">
                    <div class="form-check form-check-inline">
                        <input id="checkbox__show__plotly_scrnaseq" type="checkbox" class="mr-2" checked data-toggle="toggle" data-on="Single-cell Expression" data-off="Single-cell Expression" data-onstyle="secondary" data-offstyle="light" data-size="sm" data-style="ios" data-width="200" onchange="Toggle_Panel( '#container_plotly_scrnaseq' )" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> graphs displaying <i>single-cell-level expression</i> of a query protein" aria-label="">
                    </div>
                    <div class="form-check form-check-inline">
                        <input id="checkbox__show__plotly_gtex" type="checkbox" class="mr-2" checked data-toggle="toggle" data-on="GTEx Tissue" data-off="GTEx Tissue" data-onstyle="secondary" data-offstyle="light" data-size="sm" data-style="ios" data-width="120" onchange="Toggle_Panel( '#container_plotly_gtex' )" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> graphs displaying <i>tissue-level expression</i> of a query protein" aria-label="">
                    </div>
<!--                     <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="button" onclick="Toggle_Panel( '#container_plotly_gtex' )" aria-expanded="false" aria-controls="container_plotly_gtex" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> graphs displaying <i>tissue-level expression</i> of a query protein" aria-label="">GTEx Tissue</button>
                    <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="button" onclick="Toggle_Panel( '#container_plotly_scrnaseq' )" aria-expanded="false" aria-controls="container_plotly_scrnaseq" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> graphs displaying <i>single-cell-level expression</i> of a query protein" aria-label="">Single-cell Expression</button> -->
<!--                     <input class="form-control" type="search" placeholder="Enter Gene Symbol" aria-label="Draw plot of a gene symbol" id="input_gene_symbol_expression">
                    <button class="btn btn-light mx-2 my-0" type="button" onclick="Highlight_MolecularMimicryMap( )">Plot</button> -->
                </form>
                <button type="button" class="close" aria-label="Close container_expression_panel_MolecularMimicryMap" data-toggle="collapse" data-target="#container_expression_panel_MolecularMimicryMap"><span aria-hidden="true">&times;</span></button>
            </nav>
            <div id="container_plotly_scrnaseq" class="collapse show">
                <nav class="navbar navbar-dark bg-custom-navbar-secondary">
                    <div data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>open an interactive single-cell expression viewer</b> to further explore the expression of the gene at a single cell resolution" style="margin-right: 15px">
                        <a class="navbar-brand my-0" style="font-size: 1em; font-weight: bold; margin-right: 0px !important" id="expression_panel__link_to_cellxgene" href="" target="_blank" rel="noopener noreferrer">Single Cell Expression</a>
                        <i class="material-icons icon-white" style="font-size:17px;cursor:pointer">launch</i>
                    </div>
                    <div data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>open a link</b> to the publication of the current <i>single cell RNA-Seq</i> study">
                        <a class="navbar-brand my-0" style="font-size: 0.75em; font-weight: bold; margin-right: 0px !important" id="expression_panel__link_to_publication" href="" target="_blank" rel="noopener noreferrer" >Publication</a>
                        <i class="material-icons icon-white" style="font-size:14px;cursor:pointer">launch</i>
                    </div>
                    <div class="btn-toolbar mr-auto ml-auto my-0" role="toolbar">
                        <div class="input-group">
                            <select id="select__category_dataset__plotly_scrnaseq" class="form-control mr-2 w-auto" style="text-align: center; height:30px; line-height: 0px; padding-top: 0px; padding-bottom: 0px;" onchange="PlotExpression_scRNA_Seq_Update_Select_Options( )">
                                <option value="patient_donors" selected>Patient Donors</option>
                                <option value="cell_line">Lung Cell Line</option>
                                <option value="healthy_donors" >Healthy Donors</option>
                            </select>
                            <select id="select__name_dataset__plotly_scrnaseq" class="form-control mr-2 w-auto" style="text-align: center; height:30px; line-height: 0px; padding-top: 0px; padding-bottom: 0px;" onchange="PlotExpression_scRNA_Seq( )">
                                <option value="" selected>Select Category</option>
                            </select>
                            <div class="form-check form-check-inline">
                                <input id="checkbox__covid_status__plotly_scrnaseq" type="checkbox" class="mr-2" checked data-toggle="toggle" data-on="Cell Type" data-off="COVID-19 Status" data-onstyle="secondary" data-offstyle="danger" data-size="sm" data-style="ios" data-width="150" onchange="PlotExpression_scRNA_Seq( )">
                            </div>
                            <div class="form-check form-check-inline">
                                <input id="checkbox__proportion__plotly_scrnaseq" type="checkbox" checked data-toggle="toggle" data-on="Expression" data-off="Proportion" data-onstyle="success" data-offstyle="warning" data-size="sm" data-style="ios" data-width="100" onchange="PlotExpression_scRNA_Seq( )">
                            </div>
                            <div class="form-check form-check-inline">
                                <input id="checkbox__ignore_cells_with_zero_counts__plotly_scrnaseq" type="checkbox" checked data-toggle="toggle" data-on="All Cells" data-off="Only Positive Cells" data-onstyle="primary" data-offstyle="info" data-size="sm" data-style="ios" data-width="150" onchange="PlotExpression_scRNA_Seq( )">
                            </div>
                        </div>
                    </div>
                </nav>
                <div id="plotly_graph_scrnaseq_expression"></div>
            </div>
            <div id="container_plotly_gtex" class="collapse show">
                <nav class="navbar navbar-dark bg-custom-navbar-secondary">
                    <div data-toggle="tooltip" data-placement="bottom" data-html="true" title="Press to <b>open the GTEx portal</b> to explore the expression of the gene further"><a id="expression_panel__link_to_GTEx_portal" class="navbar-brand my-0" style="font-size: 1.1em; font-weight: bold; margin-right: 0px !important" href="" target="_blank" rel="noopener noreferrer">GTEx Expression</a><i class="material-icons icon-white" style="font-size:17px;cursor:pointer">launch</i></div>
                </nav>
                <div id="plotly_graph_gtex"></div>
            </div>
        </div>
        <div id="container_plotly_table_sequence" class="collapse">
            <nav class="navbar navbar-dark bg-custom-navbar" style="padding-top: 5px; padding-bottom: 5px">
                <a class="navbar-brand mb-0 h5">Aligned Sequences</a>
                <form class="form-inline">
                </form>
                <button type="button" class="close" aria-label="Close container_plotly_table_sequence" data-toggle="collapse" data-target="#container_plotly_table_sequence"><span aria-hidden="true">&times;</span></button>
            </nav>
            <div id="plotly_table_sequence" style="height:100px;"></div>
            <div id="description_clicked_position__table_sequence" style="text-align: center; border-top: 2px solid #6b0596; background-color: #f8f7fa; color: #000"></div>
        </div>
        <div id="container_PDB" class="collapse">
            <nav class="navbar navbar-dark bg-custom-navbar" style="padding-top: 5px; padding-bottom: 5px">
                <a class="navbar-brand mb-0 h5">Aligned Structures</a>
                <form class="form-inline">
                    <div class="input-group-prepend mx-2 my-0" style="height:30px"><a id="text_protein_structure_target" class="input-group-text" target="_blank" rel="noopener noreferrer" href="">target Protein Structure</a></div>
                    <select class="form-control my-0" id="select_PDB_target_protein_structure" style="text-align: center; height:30px; line-height: 0px; padding-top: 0px; padding-bottom: 0px;" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Select how to visualize the alignment result on the SARS-CoV-2 target protein" onchange="Select_View_of_PDB_target_Protein( )">
                        <option value="Clear">Clear</option>
                        <option selected value="BLOSUM62 Score">BLOSUM62 Score</option>
                        <option value="BLOSUM62 Score with Side Chains">BLOSUM62 Score with Side Chains</option>
                    </select>
                    <div class="input-group-prepend mx-2 my-0" style="height:30px"><a id="text_protein_structure_query" class="input-group-text" target="_blank" rel="noopener noreferrer" href="">query Protein Structure</a></div>
                    <select class="form-control my-0" id="select_PDB_query_protein_structure" style="text-align: center; height:30px; line-height: 0px; padding-top: 0px; padding-bottom: 0px;" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Select how to visualize the alignment result on the query protein" onchange="Select_View_of_PDB_query_Protein( )">
                        <option value="Clear">Clear</option>
                        <option selected value="BLOSUM62 Score">BLOSUM62 Score</option>
                        <option value="BLOSUM62 Score with Side Chains">BLOSUM62 Score with Side Chains</option>
                    </select>
                </form>
                <button type="button" class="close" aria-label="Close container_PDB" data-toggle="collapse" data-target="#container_PDB"><span aria-hidden="true">&times;</span></button>
            </nav>
            <div id="PDB_Viewer" class="deconstructed_pancake_parent">
                <div class="container_molstar deconstructed_pancake_box" id="PDB_Viewer_target_Protein"></div>
                <div class="container_molstar deconstructed_pancake_box" id="PDB_Viewer_query_Protein"></div>
            </div>
        </div>
    </div>
</div>
</div> 
<!-- end of current view container -->

<div class="modal fade" id="modal_keyboard_shortcuts" tabindex="-1" role="dialog" aria-labelledby="modal_keyboard_shortcuts" aria-hidden="true">
    <div class="modal-dialog modal-lg" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="label_modal_generate_peptides">Keyboard Shortcuts</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            </div>
            <div class="modal-body">
                <h5 class="text-muted mb-2" style="font-size:20px">General</h5>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>s</kbd><b>(screenshot)</b> to capture <b>the current view</b> and download it as a PNG file</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>i</kbd><b>(introduction)</b> to toggle the modal showing file loader and instructions</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>a</kbd><b>(information on hover)</b> to toggle the click/hover events of the main graph.</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>h</kbd><b>(help messages)</b> to toggle tooltip messages that are shown when mouse pointers are on buttons.</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>u</kbd><b>(UP)</b> to move to the top of the page.</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>d</kbd><b>(Down)</b> to move to the bottom of the page.</p>
                <br>
                <h5 class="text-muted mb-2" style="font-size:20px">Peptide Vaccine Design</h5>
                <p>Press <kbd>a</kbd><b>(add)</b> when clicking/selecting peptides to include peptides in the selection.</p>
                <p>Press <kbd>r</kbd><b>(remove)</b> when clicking/selecting peptides to exclude peptides from the selection.</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>r</kbd><b>(reset)</b> to reset selection of peptides.</p>
                <br>
                <h5 class="text-muted mb-2" style="font-size:20px">Panel Control</h5>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>b</kbd><b>(B-cell Cross Reactivity Pred.)</b> to show/hide the parallel coordinates plot showing B-cell cross reactivity prediction metrics</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>g</kbd><b>(T-cell Cross Reactivity Pred.)</b> to show/hide the parallel coordinates plot showing T-cell cross reactivity prediction metrics</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>p</kbd><b>(query <i>P</i>rotein)</b> to show/hide the parallel coordinates plot for filtering query proteins</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>t</kbd><b>(Table)</b> to show/hide the DataTable panel</p>
                <br>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Okay</button>
            </div>
        </div>
    </div>
</div>
<!-- fullscreen load file modal -->
<div id="modal_file_loader" class="modal fade show" tabindex="-1" role="dialog" aria-labelledby="modal_file_loader" aria-hidden="true" style="padding-right: 0px!important;"> <!-- disable fading when the web page has been loaded -->
  <div class="modal-dialog" style="width: 100%!important;height: 100%!important;margin: 0!important;padding: 0!important;max-width:none !important;">
    <div class="modal-content" style="height: auto !important; min-height: 100% !important; border-radius: 0 !important;min-width: 100% !important;">
        <nav class="navbar navbar-expand-lg navbar-dark bg-custom-navbar"> <!-- sticky-top -->
            <a class="navbar-brand mb-0 h1">CRESSP Web Viewer</a>
<!--             <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav_top" aria-controls="navbarNav_top" aria-expanded="false" aria-label="Toggle top navigation"><span class="navbar-toggler-icon"></span></button> -->
            <div class="collapse navbar-collapse" id="navbarNav_top">
                <ul class="navbar-nav">
<!--                     <li class="nav-item">
                        <a class="nav-link">Citation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link">Feedback</a>
                    </li> -->
                </ul>
            </div>
        </nav>
            <div class="modal-header">
                <h1 class="modal-title">File Loader</h1>
<!--                 <button class="btn btn-link btn-lg mt-2 mr-auto" onclick="Toggle_File_Loader_Modal();">Close File Loader</button>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button> -->
            </div>
            <div class="modal-body">

                <!-- drag & drop file uploader  -->
                <form id="upload">
                    <fieldset>
                    <legend>Load CRESSP Output Files</legend>
                    <input type="hidden" id="MAX_FILE_SIZE" name="MAX_FILE_SIZE" value="300000" />
                    <div>
                        <label for="fileselect">Files to load:</label>
                        <input type="file" id="fileselect" name="fileselect[]" multiple="multiple" />
                        <div id="filedrag"><br><br><br>or Drag &amp Drop files here<br><br><br></div>
                    </div>
                    </fieldset>
                </form>
                <button id="btn_submit_files" class="btn btn-secondary btn-lg btn-block" data-dismiss="modal" onclick="Initialize_Viewer( )">Load Files</button>
                <br>
                <p>Status:</p>
                <div id="container_file_message"></div>
            <!--                 
                <h2></h2>
                <img src="https://ahs2202.github.io/3M/images/3M_of_SARS-CoV-2.cover.PNG" alt="introduction images" style="min-width:50%;max-width:90%;display: block;margin-left: auto;margin-right: auto;">
                <br>
                <div class="card mx-auto my-2" style="max-width: 60rem;">
                    <div class="card-body">
                        <h2 class="card-title">Abstract</h2>
                        <p class="card-text">The development of autoimmune diseases following SARS-CoV-2 infection, including multisystem inflammatory syndrome, has been reported, and several mechanisms have been suggested, including molecular mimicry. We developed a novel pipeline to identify cross-reactive epitopes between SARS-CoV-2 and query proteins using the structural properties of the proteins. Overall, by searching 4,911,245 proteins from 196,352 SARS-CoV-2 genomes, we identified 133 and 648 query proteins harboring potential cross-reactive B-cell and CD8+ T-cell epitopes, respectively. To demonstrate the robustness of our pipeline, we predicted the cross-reactive epitopes of coronatarget spike proteins, which were recognized by known cross-neutralizing antibodies. Using single-cell expression data, we identified PARP14 as a potential target of intermolecular epitope spreading between the target and query proteins. Finally, we developed a web application (https://ahs2202.github.io/3M/) to interactively visualize our results. Overall, our immunoinformatic resources provide a foundation for the investigation of molecular mimicry in the pathogenesis of autoimmune and chronic inflammatory diseases following COVID-19.</p>
                    </div>
                    <div class="mr-auto ml-auto"><a href="https://doi.org/10.1101/2020.11.12.344424" style="font-size: 1.35em; font-weight: bold" target="_blank" rel="noopener noreferrer" class="btn btn-link btn-sm mx-1 my-0" role="button" data-toggle="button" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Click to view our BioRXiv preprint">BioRXiv preprint<i class="material-icons icon-black" style="font-size: 0.9em">launch</i></a></div>
                </div> -->
<!--                 <h5 class="text-muted">This program has been developed by Hyunsu An at Gwangju Institute of Science and Technology under the supervision of Professor JiHwan Park.</h5> -->
<!--                 <div class="card border-primary mx-auto my-2" style="max-width: 50rem;">
                    <div class="card-header">Instruction</div>
                    <div class="card-body text-primary">
                        <h5 class="card-title">basic usage</h5>
                        <p class="card-text">Click points to see details.</p>
                    </div>
                </div> -->
                
            </div>
            <div class="modal-footer">

                <h1 class="modal-title">Usages</h1>
                <div id="carouselExampleIndicators" class="carousel slide" data-ride="carousel">
                    <ol class="carousel-indicators">
                        <li data-target="#carouselExampleIndicators" data-slide-to="0" class="active"></li>
                        <li data-target="#carouselExampleIndicators" data-slide-to="1"></li>
                        <li data-target="#carouselExampleIndicators" data-slide-to="2"></li>
                    </ol>
                    <div class="carousel-inner">
                        <div class="carousel-item active">
                            <img src="https://ahs2202.github.io/3M/images/3M_of_SARS-CoV-2.usage_main_graph.PNG" class="d-block w-100 mx-auto" style="max-width: 1700px !important;" alt="Explore cross-reactive immune epitopes">
                            <div class="carousel-caption d-none d-md-block">
                                <h2>Explore cross-reactive immune epitopes</h2>
                                <p>Toggle <b>help messages</b> by pressing <kbd>Cmd</kbd> + <kbd>H</kbd><br>Keyboard shorcuts can be found at the upper right corner</p>
                            </div>
                        </div>
                        <div class="carousel-item">
                            <img src="https://ahs2202.github.io/3M/images/3M_of_SARS-CoV-2.usage_filter.PNG" class="d-block w-100 mx-auto" style="max-width: 1700px !important;" alt="Filter cross-reactive immune epitopes">
                            <div class="carousel-caption d-none d-md-block">
                                <h2>Filter cross-reactive immune epitopes</h2>
                                <p>Multiple filters can be applied.<br>To remove a filter, click the filter again</p>
                            </div>
                        </div>
                        <div class="carousel-item">
                            <img src="https://ahs2202.github.io/3M/images/3M_of_SARS-CoV-2.usage_aligned_structures.PNG" class="d-block w-100 mx-auto" style="max-width: 1700px !important;" alt="Visualize Aligned Structures">
                            <div class="carousel-caption d-none d-md-block">
                                <h2>Visualize Aligned Structures</h2>
                                <p>Click a row in the aligned sequence table to highlight a pair of aligned residues on target and query structures<br>When protein structure is not available, a black screen will be shown</p>
<!--                                 Change the representation of protein structure <i>(Control Panel > Components > Polymer > Actions > Add Representation > Molecular Surface)</i><br> -->
                            </div>
                        </div>
                    </div>
                    <a class="carousel-control-prev" href="#carouselExampleIndicators" role="button" data-slide="prev">
                        <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                        <span class="sr-only">Previous</span>
                    </a>
                    <a class="carousel-control-next" href="#carouselExampleIndicators" role="button" data-slide="next">
                        <span class="carousel-control-next-icon" aria-hidden="true"></span>
                        <span class="sr-only">Next</span>
                    </a>
                </div>
                <p class="text-muted" style="text-align:center;">This program has been developed by Hyunsu An at Gwangju Institute of Science and Technology under the supervision of Professor JiHwan Park. (License: GPLv3)</p>
                
            </div>
        </div>
    </div>
</div>
<div id="loading_screen"></div>
<script>
// packages
var DragSort=function(t){var e,i=0,s={},r={},a=(e=window.MutationObserver||window.WebKitMutationObserver,function(t,i){t&&1===t.nodeType&&(e?new e((function(t,e){i(t)})).observe(t,{childList:!0,subtree:!1}):window.addEventListener&&t.addEventListener("DOMNodeInserted",i,!1))});function n(t,e){if(!t)return this;e=e||{},this.parentElm=t,this.uid=e.uid,this.settings={selector:"*",callbacks:{}},Object.assign(this.settings,e),this.setup(),a(this.parentElm,this.setup.bind(this)),this.bindEvents()}return n.prototype={namespace:"dragsort",setup(){[...this.parentElm.childNodes].forEach(t=>{if(1!=t.nodeType)return t.parentNode.removeChild(t);t.matches(this.settings.selector)&&(t.draggable=!0)}),this.gap=this.getItemsGap(this.parentElm.firstElementChild)},throttle(t,e){var i=!1,s=this;return function(r){i||(t.call(s,r),i=!0,setTimeout(()=>i=!1,e))}},getDraggableElm(t){var e=t.closest('[draggable="true"]');return this.uid==s.uid?e:null},dragstart(t,e){s=this;var i,r=this.getDraggableElm(e);r?(this.source=this.getInitialState(),this.target=this.getInitialState(),i=r.getBoundingClientRect(),this.source.elm=r,this.source.idx=this.getNodeIndex(r),this.source.size.width=i.width,this.source.size.height=i.height,t.dataTransfer.effectAllowed="move",setTimeout(this.afterDragStart.bind(this))):s={}},afterDragStart(){var t="vertical"==this.settings.mode?"height":"width";this.parentElm.classList.add(this.namespace+"--dragStart"),this.source.elm.style[t]=this.source.size[t]+"px",this.source.elm.classList.add(this.namespace+"--dragElem")},dragover(t){t.preventDefault(),t.stopPropagation();var e=t.target;if((e=this.getDraggableElm(e))&&this.target){var i=this.target.elm,s=this.target.hoverDirection;t.dataTransfer.dropEffect="move",this.target.hoverDirection=this.getTargetDirection(t),i==e&&s==this.target.hoverDirection||this.directionAwareDragEnter(t,e)}},dragenter(t,e){(e=this.getDraggableElm(e))&&this.target&&this.isValidElm(e)&&this.source.elm!=e&&this.source.elm&&(this.target.bounding=e.getBoundingClientRect())},directionAwareDragEnter(t,e){var i;t.preventDefault(),t.stopPropagation(),t.dataTransfer.dropEffect="none",this.isValidElm(e)&&this.source.elm!=e&&this.source.elm&&(t.dataTransfer.dropEffect="move",this.cleanupLastTarget(),this.target.elm=e,this.target.idx=this.getNodeIndex(e),e.classList.add("over"),i=Math.abs(this.target.idx-this.source.idx),this.source.elm.classList.toggle(this.namespace+"--hide",i>0),"vertical"==this.settings.mode?this.target.elm.style[this.target.hoverDirection?"marginBottom":"marginTop"]=this.source.size.height+this.gap+"px":this.target.elm.style[this.target.hoverDirection?"marginRight":"marginLeft"]=this.source.size.width+this.gap+"px")},dragend(t){if(clearTimeout(this.dragoverTimeout),this.dragoverTimeout=null,this.parentElm.classList.remove(this.namespace+"--dragStart"),!this.isValidElm(this.target.elm))return this.cleanup();var e=this.target.hoverDirection?this.target.elm.nextElementSibling:this.target.elm;return this.source.elm!=this.target.elm&&this.target.elm&&(this.target.elm.classList.add(this.namespace+"--noAnim"),this.cleanup(),this.parentElm.insertBefore(this.source.elm,e)),this.source.elm&&this.source.elm.classList.remove(this.namespace+"--dragElem",this.namespace+"--hide"),this.settings.callbacks.dragEnd(this.source.elm),this},isTargetLastChild(){return this.parentElm.lastElementChild==this.target.elm},getTargetDirection(t){if(this.target.bounding)return"vertical"==this.settings.mode?t.pageY>this.target.bounding.top+this.target.bounding.height/2?1:0:t.pageX>this.target.bounding.left+this.target.bounding.width/2?1:0},getNodeIndex(t){for(var e=0;t=t.previousSibling;)3==t.nodeType&&/^\s*$/.test(t.data)||e++;return e},isValidElm(t){return t&&t.nodeType&&t.parentNode==this.parentElm},cleanup(){s={},[...this.parentElm.children].forEach(t=>{t.removeAttribute("style"),setTimeout(()=>{t.classList.remove(this.namespace+"--over",this.namespace+"--noAnim",this.namespace+"--dragElem")},50)})},cleanupLastTarget(){this.target.elm&&(this.target.elm.classList.remove(this.namespace+"--hide",this.namespace+"--over"),this.target.elm.removeAttribute("style"))},getInitialState:()=>({elm:null,size:{}}),getItemsGap(t){var e=getComputedStyle(t);return"vertical"==this.settings.mode?parseInt(e.marginTop)+parseInt(e.marginBottom):parseInt(e.marginLeft)+parseInt(e.marginRight)},bindEvents(t){for(var e in this.listeners=this.listeners||{dragstart:t=>this.dragstart(t,t.target),dragenter:t=>this.dragenter(t,t.target),dragend:t=>this.dragend(t,t.target),dragover:this.throttle(this.dragover,350)},this.listeners)this.parentElm[t?"removeEventListener":"addEventListener"](e,this.listeners[e])},destroy(){this.cleanup(),this.bindEvents(!0),delete r[this.uid]}},function(t,e){return r[++i]=t._DragSort?r[t._DragSort]:new n(t,{...e,uid:i}),t._DragSort=i,r[i]}}();
// MD5 hashing function from https://css-tricks.com/snippets/javascript/javascript-md5/
var MD5_from_String = function( string ) {
   function RotateLeft(lValue, iShiftBits) {
           return (lValue<<iShiftBits) | (lValue>>>(32-iShiftBits));
   }

   function AddUnsigned(lX,lY) {
           var lX4,lY4,lX8,lY8,lResult;
           lX8 = (lX & 0x80000000);
           lY8 = (lY & 0x80000000);
           lX4 = (lX & 0x40000000);
           lY4 = (lY & 0x40000000);
           lResult = (lX & 0x3FFFFFFF)+(lY & 0x3FFFFFFF);
           if (lX4 & lY4) {
                   return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
           }
           if (lX4 | lY4) {
                   if (lResult & 0x40000000) {
                           return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
                   } else {
                           return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
                   }
           } else {
                   return (lResult ^ lX8 ^ lY8);
           }
   }

   function F(x,y,z) { return (x & y) | ((~x) & z); }
   function G(x,y,z) { return (x & z) | (y & (~z)); }
   function H(x,y,z) { return (x ^ y ^ z); }
   function I(x,y,z) { return (y ^ (x | (~z))); }

   function FF(a,b,c,d,x,s,ac) {
           a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
           return AddUnsigned(RotateLeft(a, s), b);
   };

   function GG(a,b,c,d,x,s,ac) {
           a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
           return AddUnsigned(RotateLeft(a, s), b);
   };

   function HH(a,b,c,d,x,s,ac) {
           a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
           return AddUnsigned(RotateLeft(a, s), b);
   };

   function II(a,b,c,d,x,s,ac) {
           a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
           return AddUnsigned(RotateLeft(a, s), b);
   };

   function ConvertToWordArray(string) {
           var lWordCount;
           var lMessageLength = string.length;
           var lNumberOfWords_temp1=lMessageLength + 8;
           var lNumberOfWords_temp2=(lNumberOfWords_temp1-(lNumberOfWords_temp1 % 64))/64;
           var lNumberOfWords = (lNumberOfWords_temp2+1)*16;
           var lWordArray=Array(lNumberOfWords-1);
           var lBytePosition = 0;
           var lByteCount = 0;
           while ( lByteCount < lMessageLength ) {
                   lWordCount = (lByteCount-(lByteCount % 4))/4;
                   lBytePosition = (lByteCount % 4)*8;
                   lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount)<<lBytePosition));
                   lByteCount++;
           }
           lWordCount = (lByteCount-(lByteCount % 4))/4;
           lBytePosition = (lByteCount % 4)*8;
           lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80<<lBytePosition);
           lWordArray[lNumberOfWords-2] = lMessageLength<<3;
           lWordArray[lNumberOfWords-1] = lMessageLength>>>29;
           return lWordArray;
   };

   function WordToHex(lValue) {
           var WordToHexValue="",WordToHexValue_temp="",lByte,lCount;
           for (lCount = 0;lCount<=3;lCount++) {
                   lByte = (lValue>>>(lCount*8)) & 255;
                   WordToHexValue_temp = "0" + lByte.toString(16);
                   WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length-2,2);
           }
           return WordToHexValue;
   };

   function Utf8Encode(string) {
           string = string.replace(/\r\n/g,"\n");
           var utftext = "";

           for (var n = 0; n < string.length; n++) {

                   var c = string.charCodeAt(n);

                   if (c < 128) {
                           utftext += String.fromCharCode(c);
                   }
                   else if((c > 127) && (c < 2048)) {
                           utftext += String.fromCharCode((c >> 6) | 192);
                           utftext += String.fromCharCode((c & 63) | 128);
                   }
                   else {
                           utftext += String.fromCharCode((c >> 12) | 224);
                           utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                           utftext += String.fromCharCode((c & 63) | 128);
                   }

           }

           return utftext;
   };

   var x=Array();
   var k,AA,BB,CC,DD,a,b,c,d;
   var S11=7, S12=12, S13=17, S14=22;
   var S21=5, S22=9 , S23=14, S24=20;
   var S31=4, S32=11, S33=16, S34=23;
   var S41=6, S42=10, S43=15, S44=21;

   string = Utf8Encode(string);

   x = ConvertToWordArray(string);

   a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476;

   for (k=0;k<x.length;k+=16) {
           AA=a; BB=b; CC=c; DD=d;
           a=FF(a,b,c,d,x[k+0], S11,0xD76AA478);
           d=FF(d,a,b,c,x[k+1], S12,0xE8C7B756);
           c=FF(c,d,a,b,x[k+2], S13,0x242070DB);
           b=FF(b,c,d,a,x[k+3], S14,0xC1BDCEEE);
           a=FF(a,b,c,d,x[k+4], S11,0xF57C0FAF);
           d=FF(d,a,b,c,x[k+5], S12,0x4787C62A);
           c=FF(c,d,a,b,x[k+6], S13,0xA8304613);
           b=FF(b,c,d,a,x[k+7], S14,0xFD469501);
           a=FF(a,b,c,d,x[k+8], S11,0x698098D8);
           d=FF(d,a,b,c,x[k+9], S12,0x8B44F7AF);
           c=FF(c,d,a,b,x[k+10],S13,0xFFFF5BB1);
           b=FF(b,c,d,a,x[k+11],S14,0x895CD7BE);
           a=FF(a,b,c,d,x[k+12],S11,0x6B901122);
           d=FF(d,a,b,c,x[k+13],S12,0xFD987193);
           c=FF(c,d,a,b,x[k+14],S13,0xA679438E);
           b=FF(b,c,d,a,x[k+15],S14,0x49B40821);
           a=GG(a,b,c,d,x[k+1], S21,0xF61E2562);
           d=GG(d,a,b,c,x[k+6], S22,0xC040B340);
           c=GG(c,d,a,b,x[k+11],S23,0x265E5A51);
           b=GG(b,c,d,a,x[k+0], S24,0xE9B6C7AA);
           a=GG(a,b,c,d,x[k+5], S21,0xD62F105D);
           d=GG(d,a,b,c,x[k+10],S22,0x2441453);
           c=GG(c,d,a,b,x[k+15],S23,0xD8A1E681);
           b=GG(b,c,d,a,x[k+4], S24,0xE7D3FBC8);
           a=GG(a,b,c,d,x[k+9], S21,0x21E1CDE6);
           d=GG(d,a,b,c,x[k+14],S22,0xC33707D6);
           c=GG(c,d,a,b,x[k+3], S23,0xF4D50D87);
           b=GG(b,c,d,a,x[k+8], S24,0x455A14ED);
           a=GG(a,b,c,d,x[k+13],S21,0xA9E3E905);
           d=GG(d,a,b,c,x[k+2], S22,0xFCEFA3F8);
           c=GG(c,d,a,b,x[k+7], S23,0x676F02D9);
           b=GG(b,c,d,a,x[k+12],S24,0x8D2A4C8A);
           a=HH(a,b,c,d,x[k+5], S31,0xFFFA3942);
           d=HH(d,a,b,c,x[k+8], S32,0x8771F681);
           c=HH(c,d,a,b,x[k+11],S33,0x6D9D6122);
           b=HH(b,c,d,a,x[k+14],S34,0xFDE5380C);
           a=HH(a,b,c,d,x[k+1], S31,0xA4BEEA44);
           d=HH(d,a,b,c,x[k+4], S32,0x4BDECFA9);
           c=HH(c,d,a,b,x[k+7], S33,0xF6BB4B60);
           b=HH(b,c,d,a,x[k+10],S34,0xBEBFBC70);
           a=HH(a,b,c,d,x[k+13],S31,0x289B7EC6);
           d=HH(d,a,b,c,x[k+0], S32,0xEAA127FA);
           c=HH(c,d,a,b,x[k+3], S33,0xD4EF3085);
           b=HH(b,c,d,a,x[k+6], S34,0x4881D05);
           a=HH(a,b,c,d,x[k+9], S31,0xD9D4D039);
           d=HH(d,a,b,c,x[k+12],S32,0xE6DB99E5);
           c=HH(c,d,a,b,x[k+15],S33,0x1FA27CF8);
           b=HH(b,c,d,a,x[k+2], S34,0xC4AC5665);
           a=II(a,b,c,d,x[k+0], S41,0xF4292244);
           d=II(d,a,b,c,x[k+7], S42,0x432AFF97);
           c=II(c,d,a,b,x[k+14],S43,0xAB9423A7);
           b=II(b,c,d,a,x[k+5], S44,0xFC93A039);
           a=II(a,b,c,d,x[k+12],S41,0x655B59C3);
           d=II(d,a,b,c,x[k+3], S42,0x8F0CCC92);
           c=II(c,d,a,b,x[k+10],S43,0xFFEFF47D);
           b=II(b,c,d,a,x[k+1], S44,0x85845DD1);
           a=II(a,b,c,d,x[k+8], S41,0x6FA87E4F);
           d=II(d,a,b,c,x[k+15],S42,0xFE2CE6E0);
           c=II(c,d,a,b,x[k+6], S43,0xA3014314);
           b=II(b,c,d,a,x[k+13],S44,0x4E0811A1);
           a=II(a,b,c,d,x[k+4], S41,0xF7537E82);
           d=II(d,a,b,c,x[k+11],S42,0xBD3AF235);
           c=II(c,d,a,b,x[k+2], S43,0x2AD7D2BB);
           b=II(b,c,d,a,x[k+9], S44,0xEB86D391);
           a=AddUnsigned(a,AA);
           b=AddUnsigned(b,BB);
           c=AddUnsigned(c,CC);
           d=AddUnsigned(d,DD);
        }

    var temp = WordToHex(a)+WordToHex(b)+WordToHex(c)+WordToHex(d);

    return temp.toLowerCase();
}
let rand_seed = xmur3( "molecular_mimicry_map_of_SARS-CoV-2" ), random_number_generator = mulberry32( rand_seed( ) ), MD5 = function( ) { return MD5_from_String( String( random_number_generator( ) ) ); }; // create MD5 hash from random number
    
    // getElementById
    function $id( id ) {
        return document.getElementById( id );
    }
    
    const fileSelector = document.getElementById( 'file-selector' );
    fileSelector.addEventListener( 'change', function( event ) {
        Loading_Screen( true ); // add loading screen
        l_file = [ ];
        l_file.push( ... event.target.files ); // retrieve list of given files
        console.log( "Locally loaded files:", l_file );
        if ( l_file.length > 0 ) { LoadLocalData( l_file ); }
        Loading_Screen( false );
    });
    
    async function LoadLocalData( l_file ) {
        Loading_Screen( true ) // add loading screen
        let l_promise = l_file.map( function( file ) { 
            return new Promise ( function( resolve, reject ) {
                Papa.parse( file, { header: true, skipEmptyLines: false, delimiter: '\t', dynamicTyping: true, complete: function( results ) { resolve( results.data.slice( 0, results.data.length - 1 ) ) }, error: reject } ); }); }); // 'skipEmptyLines' is set to false to allow reading empty lines in some input files // due to 'skipEmptyLines: false' option, the last line is empty, and should be discarded
        let results = await Promise.all( l_promise ) // wait until all files have been parsed by Papa.parse
        l_parsed_data = [ ]; // empty a list
        l_parsed_data.push( ... results ); 
        for ( let i = 0; i < l_file.length; i ++ ) { object_data.file.dict_dir_file_to_parsed_data[ l_file[ i ].name ] = l_parsed_data[ i ]; } // put parsed data into a dictionary
        console.log( "[LoadLocalData] parsing completed:", object_data.file.dict_dir_file_to_parsed_data );
        await ParseData( );
        Loading_Screen( false );
    }

    function Dismissible_Alert( container, class_alert, message, id_dom = null, str_onclick_dismiss = null ) { // display a dismissible alert message of a given class_alert (eg. 'primary') at a given container with a given message // str_onclick_dismiss: string that will be added to onclick of the close button
        $( container ).prepend( '<div class="alert alert-' + class_alert + ' alert-dismissible fade show"' + ( id_dom === null ? "" : ' id="' + id_dom + '"' ) + ' role="alert">' +
              message +
              '<button type="button" class="close" data-dismiss="alert" aria-label="Close" ' + ( str_onclick_dismiss === null ? "" : ' onclick="' + str_onclick_dismiss + '"' ) + '>' +
                 '<span aria-hidden="true">&times;</span>' +
              '</button>' +
            '</div>' ); 
    }
    // set up drag & drop file loader (ref: https://css-tricks.com/drag-and-drop-file-uploading/) (https://www.sitepoint.com/html5-file-drag-and-drop/) (2)
    var dict_file = { };
    function File_Loader_Init( ) {
        var fileselect = $id( "fileselect" ),
            filedrag = $id( "filedrag" ),
            btn_submit_files = $id( "btn_submit_files" ); // button for submitting files

        // file select
        fileselect.addEventListener( "change", FileSelectHandler, false );

        // is XHR2 available?
        var xhr = new XMLHttpRequest( );
        if (xhr.upload) {

            // file drop
            filedrag.addEventListener( "dragover", FileDragHover, false );
            filedrag.addEventListener( "dragleave", FileDragHover, false );
            filedrag.addEventListener( "drop", FileSelectHandler, false );
            filedrag.style.display = "block";

            // remove submit button
            btn_submit_files.disabled = true;
            btn_submit_files.innerHTML = "Please Load CRESSP Output Files";
        }
    }
    // file drag hover
    function FileDragHover( e ) {
        e.stopPropagation( );
        e.preventDefault( );
        e.target.className = ( e.type == "dragover" ? "hover" : "" );
    }
    function RemoveFile( file_name ) {
        delete dict_file[ file_name ]; // remove file from dict_file
        // check whether the removal of file still satisfy 'Check_Remaining_Files'
        if ( 'l_name_file_web' in dict_cressp_setting ) {
            Check_Remaining_Files( dict_cressp_setting[ 'l_name_file_web' ] )
        }
    }
    // file selection
    async function FileSelectHandler( e ) {
        // cancel event and hover styling
        FileDragHover( e );
        // fetch FileList object
        let l_file_newly_loaded = e.target.files || e.dataTransfer.files;
        
        // process all File objects
        let i = 0, file;
        for ( i = 0; file = l_file_newly_loaded[ i ]; i ++ ) {
            if ( file.name in dict_file ) {
                // when the file with the same file.name
                let id_alert = MD5( );
                Dismissible_Alert( "#container_file_message", "warning", "<p>File with filename <strong>" + file.name + "</strong> has been already loaded. Please remove the file before attempting to load a new file.</p>", id_alert );
                setTimeout( function( ){ $( "#" + id_alert ).alert( 'close' ); }, 3000 ); // dismiss alert after 3 second
            } else {
                let id_alert = "alert_" + file.name;
                Dismissible_Alert( "#container_file_message", "info", "<p>File name: <strong>" + file.name + "</strong> size: <strong>" + file.size + "</strong> bytes</p>", id_alert, "RemoveFile( '" + file.name + "' )" ); // delete file from the dict_file once the alert is dismissed
                dict_file[ file.name ] = file; // add file.name to the dict_file
            }
        }
        if ( 'cressp_web_viewer_setting.json' in dict_file ) {
            await Read_CRESSP_Setting( 'cressp_web_viewer_setting.json' );
            Check_Remaining_Files( dict_cressp_setting[ 'l_name_file_web' ] ); // check number of remaining files
        }
    }
    var dict_cressp_setting = { }; // dictionary containing cressp setting
    async function Read_CRESSP_Setting( filename_cressp_setting ) { // load cressp setting from 'cressp_web_viewer_setting.json' file
        let file = dict_file[ filename_cressp_setting ];
        return new Promise( ( resolve, reject ) => {
            let reader = new FileReader( ); // initialize FileReader
            reader.onload = function( progressEvent ) {
                dict_cressp_setting = JSON.parse( this.result );
                console.log( file, "cressp setting loaded and parsed." );
                resolve( ); // when loading and parsing is complete, resolve the promise
            };
            reader.readAsText( file )
        });
    }
    function Check_Remaining_Files( l_name_file_web ) {
        let i = 0, file_name = '', n_file_missing = 0;
        // check every file exported for visualization on the web application reported in the cressp setting file.
        for ( i = 0; file_name = l_name_file_web[ i ]; i ++ ) {
            if ( file_name in dict_file ) {
            }
            else {
                console.log( '[Check_Remaining_Files] ' + file_name + ' file is missing.' );
                n_file_missing += 1; // increase number of files missing in the input files
            }
        }
        if ( n_file_missing > 0 ) {
            btn_submit_files.disabled = true;
            btn_submit_files.innerHTML = `Please Load CRESSP Output Files (${n_file_missing} files remaining)`;
        } else {
            btn_submit_files.disabled = false;
            btn_submit_files.innerHTML = "Start Analysis!";
        }
    }
    
    
    // define shortcuts 
    object_data_keydown = { dict_status: { } };
    function Record_KeyDown( event ) { // Record pressed keyborad keys, and trigger appropriate function when key is pressed.
        object_data_keydown.dict_status[ event.key ] = event.type; // record event.type for each key
    }
    window.addEventListener( "keyup", Record_KeyDown );
    window.addEventListener( "keypress", Record_KeyDown );
    window.addEventListener( "keydown", Record_KeyDown );
    
    hotkeys( 'ctrl+t,ctrl+a,ctrl+s,ctrl+r,ctrl+b,ctrl+g,ctrl+d,ctrl+h,ctrl+i,ctrl+u,ctrl+p,command+t,command+a,command+s,command+r,command+b,command+g,command+d,command+h,command+i,command+u,command+p', function ( event, handler ) {
        event.preventDefault( );
        switch ( handler.key ) {
            case 'ctrl+s': 
            case 'command+s': 
                DownloadCurrentView( ); 
                break;
            case 'ctrl+r': 
            case 'command+r': 
                // reset selection of peptides
                dataset.vaccine_design.selection.l_selected_current = ArrayFull( dataset.vaccine_design.dict_data[ "selected" ].length, true );
                dataset.vaccine_design.selection.l_selected_previous = dataset.vaccine_design.dict_data[ "selected" ];
                document.getElementById( "button_apply_change_select_peptides" ).disabled = true;
                document.getElementById( "button_undo_last_change_modal_select_peptides" ).disabled = false;
                dataset.vaccine_design.dict_data[ "selected" ] = dataset.vaccine_design.selection.l_selected_current;
                Draw_DesignedVaccineTrace( "update_selection" ); // update selection
                break;
            case 'ctrl+a': 
            case 'command+a': 
                $( "#button_toggle_hovermode_MolecularMimicryMap" ).click( );
                break;
            case 'ctrl+b': 
            case 'command+b': 
                Toggle_Exclusive_Tabs( '#plotly_graph_b_cell_cross_reactivity' );
                break;
            case 'ctrl+g': 
            case 'command+g': 
                Toggle_Exclusive_Tabs( '#plotly_graph_t_cell_cross_reactivity' );
                break;
            case 'ctrl+t': 
            case 'command+t': 
                Toggle_Exclusive_Tabs( '#container_datatable_panel_MolecularMimicryMap' );
                break;
            case 'ctrl+d': // scroll to the bottom of the page
            case 'command+d': 
                Scroll_to_the_Bottom( ); 
                break;
            case 'ctrl+p': 
            case 'command+p': 
                Toggle_Exclusive_Tabs( '#plotly_graph_query_protein' );
                break;
            case 'ctrl+h': 
            case 'command+h': 
                Toggle_Tooltips( ); 
                break;
            case 'ctrl+i': 
            case 'command+i': 
                Toggle_File_Loader_Modal( ); 
                break;
            case 'ctrl+u': 
            case 'command+u': 
                Scroll_to_the_Top( ); 
                break;
            default: alert(event);
        }
    }); 
    function Toggle_File_Loader_Modal( ) { 
        $( '#modal_file_loader' ).modal( 'toggle' );
        document.getElementById( "modal_file_loader" ).style[ "padding-right" ] = "0px";
    } // Toggle Modal for an Introduction 
    
    var object_data = { }; // an object containing data
    object_data.file = { };
    object_data.file.base_url = "https://raw.githubusercontent.com/ahs2202/3M/master/";
    object_data.file.dict_dir_file_to_parsed_data = { };
    object_data.data = { };
    object_data.data.dict_dir_file_to_dictarr = { };
    object_data.main = { };
    object_data.main.dataset = { }; // object storing loaded data of datasets
    object_data.main.gene = { };
    object_data.main.dictionary_query_gene_symbol_lower_case_to_color = { }; // colormap mapping gene_symbol to color
    object_data.main.dictionary_target_species_to_color = { }; // colormap mapping str_target_species to color
    object_data.setting = { };
    object_data.setting.plot = { };
    object_data.flag = { };
    object_data.plot = { BCell : { }, TCell : { }, MolecularMimicryMap : { } };
    var object_data_remote_file = { }; // define values for downloading files in remote locations
    object_data.file.l_n_records_for_each_step = [ 1000, 2000, 5000, 10000, 20000, 40000, 80000, 160000 ];
    object_data.file.dict_bcell_crossreactivity_data_to_n_records = { 'nonredundant_sequence': {'5': 40000 } };
    object_data.file.dict_tcell_crossreactivity_data_to_n_records = { 'all' : 20000 };
    
    // when document is ready for interaction
    $(document).ready( function( ) {
        $('[data-toggle="tooltip"]').tooltip( ); // enable tooltips
        $('[data-tooltip="tooltip"]').tooltip( );
        $('[data-tooltip-always-active="tooltip"]').tooltip( );
        document.getElementById( 'button_toggle_hovermode_MolecularMimicryMap' ).click( ); // set initial status
        $( '#modal_file_loader' ).modal( 'show' ); // show introduction modal
        Toggle_Tooltips( ); // set tooltips status
        object_plot_MolecularMimicryMap.hovermode = "closest"; // set initial status
        Initialize_Web_Application( );
    });
    async function Initialize_Web_Application( ) { // initialize the web application
        File_Loader_Init( );
        console.log( 'CRESSP Web Viewer initialized' );
    }
    
//         // initialize flags
//         object_data.flag.vaccine_design_optivax_loaded = false;
//         // load default dataset 
//         await Load_Dataset( );
//         console.log( "[Initialize] processing of parsed data completed:", Object.keys( object_data.file.dict_dir_file_to_parsed_data ) );
//         Loading_Screen( false );
//         // show an example potentially cross-reactive B-cell epitope after loading
//         ClickCallBack_BCellCrossReactivity( 127 ); 
    
    function UpdateOption_WindowSize( ) { // update the select option of window sizes using loaded dict_cressp_setting
        let select_element = $id( 'select_windowSize_BCellCrossReactivity' ); // retrieve select object of window sizes
        Select_RemoveOptions( select_element ); // remove all option in the select element
        
        // select default option
        let objOption = document.createElement( "option" );
        objOption.text = "select window size"; // add a default select option
        objOption.value = String( dict_cressp_setting.l_window_size[ 0 ] );
        select_element.options.add( objOption );
        
        for ( let i = 0; int_window_size = dict_cressp_setting.l_window_size[ i ]; i ++ ) {
            let objOption = document.createElement( "option" ), str_window_size = String( int_window_size );
            objOption.text = str_window_size;
            objOption.value = str_window_size;
            select_element.options.add( objOption );
        }
    }
    async function Initialize_Viewer( ) {
        UpdateOption_WindowSize( ); // update the select option of window sizes using loaded dict_cressp_setting
        
        // retrieve updated setting
        object_data.flag.cross_reactive_mhc_ligand_data_exist = true;
        object_data.setting.name_acc_query = 'value';

        
        console.log( 'initialized' );
        await Load_Dataset( );
    }
    async function Load_Dataset( ) { // function triggered when setting for loading dataset is altered.
        
        
        return -1;
        // retrieve updated setting
        object_data.flag.alignment_to_target = document.getElementById( "toggle_alignment_mode" ).checked; // retrieve alignment mode
        
        let l_dir_file = [ ]; // retrieve list of files of remote locations for loading datasets
        Loading_Screen( true );
        if ( object_data.flag.alignment_to_target ) { // show alignment to reference target genomes
            object_data.main.l_name_dataset = [ object_data.main.name_dataset ]; // number of used dataset is 1
            console.log( "[Load_Dataset] " + object_data.main.name_dataset + " dataset selected" );
            let l_name_file = [ "BCellCrossReactivity.nonredundant_position.windowSize_30.top_1000.tsv.gz.base64.txt", 
                                "structural_property_target__compact__for_web_application.tsv.gz.base64.txt", 
                                "structural_property_query__compact__for_web_application.tsv.gz.base64.txt",  
                                "alignment_target_pdb__compact__for_web_application.tsv.gz.base64.txt", 
                                "alignment_query_target__compact__for_web_application.tsv.gz.base64.txt", 
                                "alignment_query_pdb__compact__for_web_application.tsv.gz.base64.txt", 
                                "blosum62.tsv.gz.base64.txt", 
                                "acc_target.tsv.gz.base64.txt", 
                                "acc_pdb.tsv.gz.base64.txt", 
                                "acc_query.tsv.gz.base64.txt",
                                "acc_target_representative.tsv.gz.base64.txt", 
                                "interpro_target.tsv.gz.base64.txt", 
                                "iedb_epitope_target.tsv.gz.base64.txt" ]; 
            if ( ! object_data.flag.query_label_represents_target ) { // if 'query' label represents actual query proteins, add several files
                l_name_file.push( ... [ 
                    "TCellCrossReactivity.nonredundant_aligned_position.top_1000.tsv.gz.base64.txt", 
                    "algorithms.tsv.gz.base64.txt", 
                    "mhc_allele.tsv.gz.base64.txt", 
                    "gtex.tsv.gz.base64.txt", 
                    "scrnaseq.metadata.tsv.gz.base64.txt" ] );
            }
            let dir_folder = object_data.file.base_url + "data/base64/" + object_data.main.name_dataset + "/" // retrieve directory of the current folder of the current dataset
            l_dir_file = l_name_file.map( ( name_file ) => { return dir_folder + name_file; } ); // retrieve remote directory for the core data files for the visualization of records aligned to target
        } else { // show alignment to query proteins
            object_data.main.l_name_dataset = object_data.main.name_dataset.includes( "coronatarget" ) ? [ object_data.main.name_dataset ] : [ object_data.main.name_dataset, 'non_SARS_CoV_2_coronatarget_20201214.valid.nonredundant' ]; // number of datasets can be either one (common cold coronatarget only) or two (comparison) // add common cold dataset as a second dataset (supplementary data) for comparison if SARS-CoV-2 target is chosen
            for ( let i = 0; i < object_data.main.l_name_dataset.length; i ++ ) {
                let l_name_file = [ "TCellCrossReactivity.nonredundant_aligned_position.top_1000.tsv.gz.base64.txt", 
                                    "BCellCrossReactivity.nonredundant_position.windowSize_30.top_1000.tsv.gz.base64.txt", 
                                    "structural_property_target__compact__for_web_application.tsv.gz.base64.txt", 
                                    "structural_property_query__compact__for_web_application.tsv.gz.base64.txt",  
                                    "alignment_target_pdb__compact__for_web_application.tsv.gz.base64.txt", 
                                    "alignment_query_target__compact__for_web_application.tsv.gz.base64.txt", 
                                    "alignment_query_pdb__compact__for_web_application.tsv.gz.base64.txt", 
                                    "mhc_allele.tsv.gz.base64.txt", 
                                    "blosum62.tsv.gz.base64.txt", 
                                    "algorithms.tsv.gz.base64.txt", 
                                    "acc_target.tsv.gz.base64.txt", 
                                    "acc_pdb.tsv.gz.base64.txt", 
                                    "acc_query.tsv.gz.base64.txt",
                                    "interpro_query.tsv.gz.base64.txt", 
                                    "iedb_epitope_query.tsv.gz.base64.txt", 
                                    "gtex.tsv.gz.base64.txt", 
                                    "scrnaseq.metadata.tsv.gz.base64.txt" ];
                l_dir_file.push( ... l_name_file.map( ( name_file ) => { return object_data.file.base_url + "data/base64/" + object_data.main.l_name_dataset[ i ] + '/' + name_file; } ) ); // retrieve remote directories for the core data files for the visualization of records aligned to query
            }
        }
        await LoadRemoteData( l_dir_file ); // load files for the selected dataset 
        console.log( "[Load_Dataset] loading remote data completed" );
        await ParseData( ); // parse loaded data
        console.log( "[Load_Dataset] parsing data completed" );
        Loading_Screen( false );
    } // load selected dataset
//     <input name='tags' id='searchbox_main' placeholder='Enter Gene Symbol' value='PARP14' data-blacklist='.NET,PHP'>
    var searchbox_main = document.getElementById( 'searchbox_main' ), tagify_searchbox_main = { };
    object_data.flag.flag_tagify_searchbox_main_mutationobserver_attached = false;
    function Tagify_color_tag( tag ) { // change colors of Tagify.js tag 
        let str_entry = tag.innerText
        if ( object_data.main.set_query_gene_symbol.has( str_entry ) ) { // if entry is query_gene_symbol (case insensitive)
            if ( object_data.flag.alignment_to_target ) {
                if ( object_data.flag.query_label_represents_target ) {
                    
                } else {
                    let color_hex_bg = object_data.main.dictionary_query_gene_symbol_lower_case_to_color[ str_entry.toLowerCase( ) ];
                    tag.style = ( ColorGetDarkness( color_hex_bg ) < 40 ) ? `--tag-bg: ${color_hex_bg}; --tag-hover: ${color_hex_bg} --tag-text-color white` : `--tag-bg: ${color_hex_bg}; --tag-hover: ${color_hex_bg}`;
                }
            } else {

            }
        }
        else if ( str_entry in object_data.main.dictionary_target_species_to_color ) { // if entry is target_species (case sensitive)
            if ( object_data.flag.alignment_to_target ) {
                if ( object_data.flag.query_label_represents_target ) {
                    let color_hex_bg = object_data.main.dictionary_target_species_to_color[ str_entry ];
                    tag.style = ( ColorGetDarkness( color_hex_bg ) < 40 ) ? `--tag-bg: ${color_hex_bg}; --tag-hover: ${color_hex_bg} --tag-text-color white` : `--tag-bg: ${color_hex_bg}; --tag-hover: ${color_hex_bg}`;
                } else {
                    
                }
            } else {
                let color_hex_bg = object_data.main.dictionary_target_species_to_color[ str_entry ];
                tag.style = ( ColorGetDarkness( color_hex_bg ) < 40 ) ? `--tag-bg: ${color_hex_bg}; --tag-hover: ${color_hex_bg} --tag-text-color white` : `--tag-bg: ${color_hex_bg}; --tag-hover: ${color_hex_bg}`;
            }
        }
    }
    function Tagify_Preview( str_entry ) { // show preview of the number of record
        // show preview of the number of record
        let dict_BCell = { },
            dict_TCell = { }; // initialize dictionary-based indices
        if ( object_data.main.set_query_gene_symbol.has( str_entry ) ) { // if entry is query_gene_symbol (case insensitive)
            str_entry = str_entry.toUpperCase( );
            dict_BCell = object_plot_BCellCrossReactivity.dictionary_query_gene_symbol_upper_case_to_l_index;
            if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) {
                dict_TCell = object_plot_TCellCrossReactivity.dictionary_query_gene_symbol_upper_case_to_l_index;
            }
        } else if ( str_entry in object_data.main.dictionary_target_species_to_color ) { // if entry is target_species (case sensitive)
            dict_BCell = object_plot_BCellCrossReactivity.dictionary_target_species_to_l_index;
            if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) {
                dict_TCell = object_plot_TCellCrossReactivity.dictionary_target_species_to_l_index;
            }
        }
        // compose a string showing preview of the current input 
        let str_preview = `${( str_entry in dict_BCell ) ? dict_BCell[ str_entry ].length : 0}/${object_plot_BCellCrossReactivity.arr_data_all.length} B-cell records`;
        if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) {
            str_preview = str_preview + `, ${( str_entry in dict_TCell ) ? dict_TCell[ str_entry ].length : 0}/${object_plot_TCellCrossReactivity.arr_data_all.length} T-cell records`;
        }
        document.getElementById( "text_number_of_records" ).innerText = str_preview;
    }
    function Initialize_SearchBox_Main( ) {
        if ( 'destroy' in tagify_searchbox_main ) {
            tagify_searchbox_main.destroy( ); // if tagify has been already attached, destroy the previous tagify element before initializing new one.
            object_data.flag.flag_tagify_searchbox_main_mutationobserver_attached = false;
        }
        let l_name_dataset = object_data.main.l_name_dataset,
            l_whitelist = [ ], l_target_species = [ ], set_query_gene_symbol = new Set( ), set_target_species = new Set( );
        // retrieve unique elements for retrieving a whitelist
        for ( let index_dataset = 0; index_dataset < l_name_dataset.length; index_dataset ++ ) {
            let dataset = object_data.main.dataset[ l_name_dataset[ index_dataset ] ];
            dataset.l_target_species.forEach( item => set_target_species.add( item ) ); // collect unique elements using set // add target species of a dataset (for the records of all query_proteins)
        }
        // collect unique elements using set // query proteins
        Object.keys( object_plot_BCellCrossReactivity.dictionary_query_gene_symbol_upper_case_to_l_index ).forEach( item => set_query_gene_symbol.add( item ) ); 
        if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) {
            Object.keys( object_plot_TCellCrossReactivity.dictionary_query_gene_symbol_upper_case_to_l_index ).forEach( item => set_query_gene_symbol.add( item ) ); 
        }
        // makes set of target and query gene symbol available to external functions
        object_data.main.set_query_gene_symbol = set_query_gene_symbol;
        object_data.main.set_target_species = set_target_species;
        
        // convert sets to a list 
        l_whitelist.push( ... set_query_gene_symbol ); 
        l_whitelist.push( ... set_target_species ); 
        // retrieve list of target species
        l_target_species.push( ... set_target_species );
        // attach tagify to the search box
        tagify_searchbox_main = new Tagify( searchbox_main, {
            dropdown: { 
                maxItems: 7,
                enabled: 0,
                position: 'text', // enable minimal sizing of a dropdown list
                highlightFirst: true, // enable enhanced autocomplete feature
            },
            maxTags: 100,
            editTags: false, // disable editing
            enforceWhitelist: true, whitelist: l_whitelist
        });
        for ( let i = 0; i < l_target_species.length; i ++ ) {
            let str_target_species = l_target_species[ i ];
            if ( tagify_searchbox_main.isTagDuplicate( str_target_species ) == 0 ) {
                tagify_searchbox_main.addTags( str_target_species );
            }
        }
        
        // color existing elements
        tagify_searchbox_main.getTagElms( ).forEach( Tagify_color_tag );
        // Chainable event listeners
        tagify_searchbox_main
              .on( 'add', e => { 
            console.log( "onAddTag: ", e.detail.data.value );
            let str_entry = e.detail.data.value, // retrieve entry
                tag = e.detail.tag;
            // color newly added elements
            Tagify_color_tag( tag );
            // highlight record and draw plots for a query protein
            if ( set_query_gene_symbol.has( str_entry ) ) { // if entry is query_gene_symbol (case insensitive)
                let query_gene_symbol_upper_case = str_entry.toUpperCase( );
                if ( object_data.flag.alignment_to_target ) {
                    Highlight_Records_MolecularMimicryMap( query_gene_symbol_upper_case, "dictionary_query_gene_symbol_upper_case_to_l_index" ); // highlight a query gene
                } else {
                    DrawMolecularMimicryMap_for_a_query_gene( query_gene_symbol_upper_case ); // draw plot of a query gene
                }
            }
            else if ( str_entry in object_data.main.dictionary_target_species_to_color ) { // if entry is target_species (case sensitive)
                if ( object_data.flag.alignment_to_target ) {
                    Highlight_Records_MolecularMimicryMap( str_entry, "dictionary_target_species_to_l_index" ); // highlight a target species
                } else {
                    Highlight_Records_MolecularMimicryMap( str_entry, "dictionary_target_species_to_l_index" ); // highlight a target species
                }
            }
        } )
              .on( 'click', e => { 
            console.log( "onClickTag: ", e.detail.data.value );
            
            let str_entry = e.detail.data.value, // retrieve entry
                tag = e.detail.tag;
            // color newly added elements
            Tagify_color_tag( tag );
            // highlight record and draw plots for a query protein
            if ( set_query_gene_symbol.has( str_entry ) ) { // if entry is query_gene_symbol (case insensitive)
                let query_gene_symbol_upper_case = str_entry.toUpperCase( );
                if ( object_data.flag.alignment_to_target ) {
                    Highlight_Records_MolecularMimicryMap( query_gene_symbol_upper_case, "dictionary_query_gene_symbol_upper_case_to_l_index" ); // highlight a query gene
                } else {
                    DrawMolecularMimicryMap_for_a_query_gene( query_gene_symbol_upper_case ); // draw plot of a query gene
                }
            }
            else if ( str_entry in object_data.main.dictionary_target_species_to_color ) { // if entry is target_species (case sensitive)
                if ( object_data.flag.alignment_to_target ) {
                    Highlight_Records_MolecularMimicryMap( str_entry, "dictionary_target_species_to_l_index" ); // highlight a target species
                } else {
                    Highlight_Records_MolecularMimicryMap( str_entry, "dictionary_target_species_to_l_index" ); // highlight a target species
                }
            }
        } )
              .on( 'remove', e => { 
            console.log( "onRemoveTag: ", e.detail );
            let str_entry = e.detail.data.value;
            if ( object_data.main.highlight.str_entry == str_entry ) { // if the entry of the tag being removed is currently being highlighted, undo the highlighting
                if ( set_query_gene_symbol.has( str_entry ) ) { // if entry is query_gene_symbol (case insensitive)
                    let query_gene_symbol_upper_case = str_entry.toUpperCase( );
                    if ( object_data.flag.alignment_to_target ) {
                        Highlight_Records_MolecularMimicryMap( query_gene_symbol_upper_case, "dictionary_query_gene_symbol_upper_case_to_l_index" ); // highlight a query gene
                    } else {

                    }
                }
                else if ( str_entry in object_data.main.dictionary_target_species_to_color ) { // if entry is target_species (case sensitive)
                    if ( object_data.flag.alignment_to_target ) {
                        
                    } else {
                        Highlight_Records_MolecularMimicryMap( str_entry, "dictionary_target_species_to_l_index" ); // highlight a target species
                    }
                }
            }
        } )
              .on('input', e => { // preview during typing
            console.log( e );
            if ( ! isString( e.detail.value ) ) { return -1; }
            let str_entry = e.detail.value; // retrieve entry
            // show preview of the number of record 
            Tagify_Preview( str_entry );
        } )
              .on( "dropdown:hide", ( e ) => { 
            console.log( "dropdown:hide" ); 
            document.getElementById( "text_number_of_records" ).innerText = ""
        } )
              .on( "dropdown:show", ( e ) => { // preview during exploring dropdown options
            $( "#container_plotly_searchbox_main_preview" ).collapse( 'show' );
            console.log( "dropdown:show" );
            if ( ! object_data.flag.flag_tagify_searchbox_main_mutationobserver_attached ) {
                let dropdown = document.querySelector( '.tagify__dropdown' ); // retrieve DOM of active dropdown
                let options = {
                    subtree: true,
                    attributes: true
                };
                let observer = new MutationObserver( function( mutations ) {
                    mutations.forEach( function( e ) {
                        if ( ( e.attributeName == 'class' ) & ( e.target.className == "tagify__dropdown__item tagify__dropdown__item--active" ) ) { // detect the innerHTML of the active element using MutationObserver
                            console.log( "dropdown active element:", e.target.innerHTML );
                            
                            let str_entry = e.target.innerHTML; // retrieve entry
                            // show preview of the number of  record and draw plots for a query protein
                            Tagify_Preview( str_entry );
                        }
                    });
                });
                observer.observe( dropdown, options );
                
                let dragsort = new DragSort( tagify_searchbox_main.DOM.scope, {
                    selector: '.' + tagify_searchbox_main.settings.classNames.tag,
                    callbacks: {
                        dragEnd: ( elm ) => { 
                            tagify_searchbox_main.updateValueByDOMTags( );
                            // color tags after the tags has been updated
                            tagify_searchbox_main.getTagElms( ).forEach( Tagify_color_tag );
                        }
                    }
                });
                object_data.flag.flag_tagify_searchbox_main_mutationobserver_attached = true; // set the flag to true after attaching mutationobserver to the dropdown list so that another observer is not attached.
            }
        })
    }
    
    function LoadRemoteTextFile( remoteFilePath ) { // load remote text file using xml_http_request (syncrhonous)
        let result = null;
        let xmlhttp = new XMLHttpRequest();
        xmlhttp.open( "GET", remoteFilePath, false );
        xmlhttp.send( );
        if ( xmlhttp.status == 200 ) {
            result = xmlhttp.responseText;
        }
        return result;
    }
    function ParseBase64GzippedText( str_base64_gzipped ) {
        let l_char = pako.inflate( new Uint8Array( atob( str_base64_gzipped ).split( '' ).map( function( x ) { return x.charCodeAt( 0 ); } ) ) ); // Decode base64 (convert ascii to binary) // Convert binary string to character-number array // Turn number array into byte-array // Convert gunzipped byteArray back to ascii string:
        let str_content = ""; // convert ASCII value to character and concatenate the characters into a string
        for ( let i = 0; i < l_char.length; i ++ ) {
            str_content += String.fromCharCode( l_char[ i ] );
        }
        return str_content;
    }
    var div_current_view = $("#molecularmimicrymap-current-view"); // global variable
    function DownloadCurrentView( ) {
         html2canvas( div_current_view.get( 0 ) ).then ( function ( canvas ) {
                var imgageData = canvas.toDataURL("image/png");
                // Now browser starts downloading it instead of just showing it
                var newData = imgageData.replace(/^data:image\/png/, "data:application/octet-stream");
                $("#anchor-current-view").attr("download", "MolecularMimicryMap of SARS-CoV-2.screenshot.png").attr("href", newData);
                $("#anchor-current-view").get( 0 ).click( ) // download image file
         });
    }
    
    // use dataframe-js
    var DataFrame = dfjs.DataFrame;
    // use interval-tree-1d
    var createIntervalTree = require( "interval-tree-1d" )
    // code for approximate string matching (for peptide sequence mapping) from https://gist.github.com/andrei-m/982927
    function Levenstein(a, b) { 
        var m = [], i, j, min = Math.min;
        if (!(a && b)) return (b || a).length;
        for (i = 0; i <= b.length; m[i] = [i++]);
        for (j = 0; j <= a.length; m[0][j] = j++);
        for (i = 1; i <= b.length; i++) {
            for (j = 1; j <= a.length; j++) {
                m[i][j] = b.charAt(i - 1) == a.charAt(j - 1)
                    ? m[i - 1][j - 1]
                    : m[i][j] = min(
                        m[i - 1][j - 1] + 1, 
                        min(m[i][j - 1] + 1, m[i - 1 ][j] + 1))
            }
        }
        return m[b.length][a.length];
    }
    function FuzzyContains(a, b, error) {
        var matchLength = a.length - b.length;
        var distanceToMatch = Levenstein(a, b) - matchLength;
        if(distanceToMatch - error > 0) {
          return false;
        } else {
          return true;
        }
    }
    // code for pseudorandom number generator (PRNG) with random seed from https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
    function xmur3(str) { // random seed generator
        for(var i = 0, h = 1779033703 ^ str.length; i < str.length; i++)
            h = Math.imul(h ^ str.charCodeAt(i), 3432918353),
            h = h << 13 | h >>> 19;
        return function() {
            h = Math.imul(h ^ h >>> 16, 2246822507);
            h = Math.imul(h ^ h >>> 13, 3266489909);
            return (h ^= h >>> 16) >>> 0;
        }
    }
    function mulberry32(a) { // a simple (PRNG) generator with a 32-bit state
        return function() {
          var t = a += 0x6D2B79F5;
          t = Math.imul(t ^ t >>> 15, t | 1);
          t ^= t + Math.imul(t ^ t >>> 7, t | 61);
          return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
    }
    // function for sorting
    function SortFloat( a, b ) { return a - b; }
    function CheckInt(n) { // return true if 'n' is true
       return n % 1 === 0;
    }
    function CountOccurrence( entry, query ) { // count occurrence of specific string in a string
        return ( entry.match( new RegExp( query, 'g' ) ) || []).length;
    }
    function ArraySum( l ) { // return the sum of values of an array
        return l.reduce( (a, b) => a + b, 0 );
    }
    function ArrayStandardDeviation( array ) {
        let n = array.length
        let mean = array.reduce((a, b) => a + b) / n
        return Math.sqrt(array.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n)
    } // from https://stackoverflow.com/questions/7343890/standard-deviation-javascript
    // funrcions for UI
    function Loading_Screen( bool_add_loading_screen ) { // add or remove loading screen
        if ( ( ! bool_add_loading_screen ) && document.getElementById( "svg_during_loading" ) != null ) {
            document.getElementById( "svg_during_loading" ).remove( ); // remove loading screen once plot is drawn
        } else if ( bool_add_loading_screen && document.getElementById( "svg_during_loading" ) == null ) {
            $("#loading_screen").append( [
                '<div class="loader loader--style1 _plotly-loading-callback" title="data is being loaded..." id="svg_during_loading">',
                    '<svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewBox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve" rect="fill: #FF6700;" path>',
                        '<path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946',
                        's14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634',
                        'c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>',
                        '<path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0',
                        'C22.32,8.481,24.301,9.057,26.013,10.047z">',
                        '<animateTransform attributeType="xml"',
                          'attributeName="transform"',
                          'type="rotate"',
                          'from="0 20 20"',
                          'to="360 20 20"',
                          'dur="0.5s"',
                          'repeatCount="indefinite"/>',
                        '</path>',
                    '</svg>',
                '</div>' ].join( "" ) ); // display an SVG file during loading 
        }
    }
    
    // basic functions
    function isString ( value ) { // Returns if a value is a string
        return typeof value === 'string' || value instanceof String;
    }
    // define hashing funciton of string
    Object.defineProperty(String.prototype, 'hashCode', {
            value: function() {
                var hash = 0, i, chr;
                for (i = 0; i < this.length; i++) {
                    chr   = this.charCodeAt(i);
                    hash  = ((hash << 5) - hash) + chr;
                    hash |= 0; // Convert to 32bit integer
                }
            return hash;
        }
    });
    
    // functions for numpy-like operations
    function ArrayIndexing( l, l_index ) {
        let l_output = [ ];
        for ( let i = 0; i < l_index.length; i++ ) { l_output.push( l[ l_index[ i ] ] ); }
        return l_output
    }
    function ArrayBooleanIndexing( l, l_bool ) {
        let l_output = [ ];
        for ( let i = 0; i < l_bool.length; i++ ) { if ( l_bool[ i ] ) { l_output.push( l[ i ] ); } }
        return l_output
    }
    function ArrayBoolAND( l_l ) {
        let l_output = [ ];
        for ( let j = 0; j < l_l[ 0 ].length; j++ ) {
            let output = true;
            for ( let i = 0; i < l_l.length; i++ ) { output = output && l_l[ i ][ j ]; }
            l_output.push( output );
        }
        return l_output;
    }
    function ArrayBoolOR( l_l ) {
        let l_output = [ ];
        for ( let j = 0; j < l_l[ 0 ].length; j++ ) {
            let output = false;
            for ( let i = 0; i < l_l.length; i++ ) { output = output || l_l[ i ][ j ]; }
            l_output.push( output );
        }
        return l_output;
    }
    function ArrayBoolNOT( l ) {
        let l_output = [ ];
        for ( let i = 0; i < l.length; i++ ) { l_output.push( l[ i ] ? false : true ); }
        return l_output;
    }
    function ArrayGreaterThan( l, thres ) {
        let l_output = [ ];
        for ( let i = 0; i < l.length; i++ ) { l_output.push( l[ i ] > thres ); }
        return l_output;
    }
    function ArrayLessThan( l, thres ) {
        let l_output = [ ];
        for ( let i = 0; i < l.length; i++ ) { l_output.push( l[ i ] < thres ); }
        return l_output;
    }
    function ArrayFull( length, value ) {
        let l_output = [ ];
        for ( let i = 0; i < length; i++ ) { l_output.push( value ); }
        return l_output;
    }
    function ArrayBroadCasting( l, l_bool_or_integer_index, value ) { // broadcast a single scalar value to multiple elements of an array according to the given 'l_bool_or_integer_index'. Receive either l_bool or l_integer_index
        let l_output = [ ];
        if ( ( l.length == l_bool_or_integer_index.length ) & ( typeof l_bool_or_integer_index[ 0 ] === 'boolean' ) ) { // if boolean index is given
            let l_bool = l_bool_or_integer_index;
            for ( let i = 0; i < l.length; i++ ) { 
                l_output.push( l_bool[ i ] ? value : l[ i ] );
            }
        } else {
            let l_int_index = l_bool_or_integer_index;
            l_output.push( ... l ); // copy list l to l_output
            for ( let i = 0; i < l_int_index.length; i++ ) { 
                l_output[ l_int_index[ i ] ] = value; // then modify elements according to the given list of integer indices
            }
        }
        return l_output;
    }
    function ArrayCap( l, value ) { // cap value of a given list at the given capping value (manually set maximum value)
        l_modified = lodash.cloneDeep( l );
        for ( let i = 0; i < l.length; i ++ ) {
            if ( l[ i ] > value ) { // cap value of a given list at the given capping value (manually set maximum value)
                l_modified[ i ] = value;
            }
        }
        return l_modified
    }
    function ArrayFloor( l, value ) { // floor value of a given list at the given flooring value (manually set minimum value)
        l_modified = lodash.cloneDeep( l );
        for ( let i = 0; i < l.length; i ++ ) {
            if ( l[ i ] < value ) { // cap value of a given list at the given capping value (manually set maximum value)
                l_modified[ i ] = value;
            }
        }
        return l_modified
    }
    function ArrayApply( l, a_function ) { // apply certain function to all of values of a given array
        let l_output = [ ];
        for ( let i = 0; i < l.length; i ++ ) {
            l_output[ i ] = a_function( l[ i ] );
        }
        return l_output
    }
    function ArrayMap( l, dictionary ) { // map values in a given array using a given dictionary
        let l_output = [ ];
        for ( let i = 0; i < l.length; i ++ ) {
            l_output[ i ] = dictionary[ l[ i ] ];
        }
        return l_output
    }
    function ArrayTranspose( l_l ) { // transpose 2d array
        let n_row = l_l.length, n_col = l_l[ 0 ].length, l_l_t = [ ]; // transposed 2d array
        for ( let i = 0; i < n_col; i ++ ) {
            let l_t = [ ]; // transposed column (now a row)
            for ( let j = 0; j < n_row; j ++ ) { l_t.push( l_l[ j ][ i ] ); }
            l_l_t.push( l_t );
        }
        return l_l_t;
    }
    function ArrayAsInt( l ) { 
        let l_int = [ ];
        for ( let i = 0; i < l.length; i ++ ) {
            l_int.push( parseInt( l[ i ] ) ); // parse a string into an integer for each entry
        }
        return l_int
    } // convert array of strings to array of integers
    function ArrayAverage( l ) { // calculate average of values in the array
        let sum = l.reduce( ( a, b ) => a + b, 0 );
        let avg = ( sum / l.length ) || 0;
        return avg;
    }
    function ArrayMultiply( l, float_multiply_by ) { // return a list with values multiplied by 'float_multiply_by'
        let l_multiplied = [ ];
        for ( let i = 0; i < l.length; i ++ ) {
            l_multiplied.push( l[ i ] * float_multiply_by );
        }
        return l_multiplied;
    }
    function ArrayFindMinMax ( l ) { 
        let min = l[ 0 ], max = l[ 0 ]; // initialize min and max values
        for ( let i = 1; i < l.length; i++ ) {
            let value = l[ i ];
            min = (value < min) ? value : min;
            max = (value > max) ? value : max;
        }
        return [ min, max ];
    } // Find Min and Max values of a given array
    function TickFindOptimal( float_max ) { // retrieve list of optimal number of ticks for concise representation of an axis (start from 0)
        let step = parseInt( 10 ** Math.floor( Math.log10( float_max ) ) );
        let n_ticks = Math.ceil( float_max / step ) + 1;
        if ( n_ticks <= 3 ) {
            step = step / 5;
        } else if ( n_ticks <= 5 ) {
            step = step / 2;
        }
        if ( parseInt( step ) == step ) {
            step = parseInt( step );
        }
        n_ticks = Math.ceil( float_max / step ) + 1;
        return nj.arange( 0, step * n_ticks, step ).tolist( ); // return ticks starts from 0
    }
    function Unique( l ) {
        let set_unique_element = { };
        for ( let i = 0; i < l.length; i ++ ) {
            set_unique_element[ l[ i ] ] = true;
        }
        return Object.keys( set_unique_element );
    } // return unique elements of a given array as a list of strings 
    function DictArrayCombine( ) { // return combined dictionary-arrays of the given list of dictionary-arrays (dictionary arrays are list of arrays with key values stored in a dictionary (combining action will be an inner join)
        let l_key = [ ];
        for ( let i = 0; i < arguments.length; i ++ ) {
            let dictarr = arguments[ i ];
            l_key.push( ... Object.keys( dictarr ) );
        }
        let l_key_shared = DictionaryFindMatchingValue( Counter( l_key ), arguments.length ); // retrieve list of keys shared by all dictionary-arrays
        // initialize a dictarr that will contain combined dictionary-arrays
        let dictarr_combined = { };
        for ( let i = 0; i < l_key_shared.length; i ++ ) {
            let key = l_key_shared[ i ];
            dictarr_combined[ key ] = [ ];
        }
        for ( let i = 0; i < arguments.length; i ++ ) {
            let dictarr = arguments[ i ]; // retrieve dictionary-array in order
            for ( let j = 0; j < l_key_shared.length; j ++ ) {
                let key = l_key_shared[ j ];
                try {
                    dictarr_combined[ key ].push( ... dictarr[ key ] ); // concatanate the array of a shared key of the current dictionary-array
                } catch ( e ) {
                    console.log( `[DictArrCOmbine] error when combining ${key} value`, dictarr ); // report key that caused error
                }
            }
        }
        return dictarr_combined;
    }
    function DictArrayIndexing( dictarr, l_index ) { // return a smaller dictarr than the given dictarr containing smaller arrays with a given 'l_index'
        let l_key = Object.keys( dictarr ),
            dictarr_output = { };
        for ( let i = 0; i < l_key.length; i ++ ) {
            let key = l_key[ i ];
            dictarr_output[ key ] = ArrayIndexing( dictarr[ key ], l_index ); // retrieve a smaller array with a given 'l_index'
        }
        return dictarr_output;
    }
    function ArrayCombine(  ) { 
        let l_combined = [ ]; 
        for ( let i = 0; i < arguments.length; i ++ ) {
            let l = arguments[ i ];
            l_combined.push( ... l );
        }
        return l_combined;
    } // return a list that will contain elments of a combined list
    function Index_list_with_dictionary( l ) { // build dictionary containing list for indices for a given list of accessions (key = accession, value = list of indices containing the accession)
        let dictionary_index = { };
        for ( let i = 0; i < l.length; i ++ ) { 
            let acc = l[ i ];
            if ( acc in dictionary_index ) {
                dictionary_index[ acc ].push( i )
            } else {
                dictionary_index[ acc ] = [ i ]; // initialize value of key encountered for the first time
            }
        }
        return dictionary_index;
    }
    function Counter( l ) { // count entries in the list
        let dict_count = { };
        for ( entry of l ) {
            if ( entry in dict_count ) {
                dict_count[ entry ] += 1;
            } else {
                dict_count[ entry ] = 1;
            }
        }
        return dict_count;
    }
    function FindTheMajority( l ) { // count entries in the list and return the majority in the list
        let dict_count = Counter( l ), key_majority = '', count_majority = 0;
        for ( key of Object.keys( dict_count ) ) { // for each key
            let count = dict_count[ key ];
            if ( count > count_majority ) { // if the count of the current key is larger than count of majority key, update the majority key name
                key_majority = key;
                count_majority = count;
            }
        }
        return key_majority;
    }
    function DictionaryFindMatchingValue( dict, value ) { // return list of keys in a given dictionary with a matching value with the given value
        let l_key_match = [ ];
        let l_key = Object.keys( dict ); // retrieve all keys of a given object
        for ( let i = 0; i < l_key.length; i ++ ) {
            let key = l_key[ i ];
            if ( dict[ key ] == value ) { // if key has a value matched with the given value
                l_key_match.push( key );
            }
        }
        return l_key_match;
    }
    function DictArrayToArray( dictarr, l_col ) {
        let l_l = [ ];
        for ( let i = 0; i < l_col.length; i ++ ) {
            l_l.push( dictarr[ l_col[ i ] ] );
        }
        return l_l;
    } // return 2D array containing lists in the order specified by l_col of dictarr (column name refers to the key name of the dicitonary of dictionary-array)
    
    function unpack( rows, key ) { 
        if ( Array.isArray( key ) ) { // if more than one key is given, return 2D-array of unpacked data
            let l_l_value = [ ];
            for ( let i = 0; i < rows.length; i ++ ) {
                let row = rows[ i ];
                let l_value = [ ];
                for ( let j = 0; j < key.length; j ++ ) { 
                    l_value.push( row[ key[ j ] ] );
                }
                l_l_value.push( l_value );
            }
            return l_l_value;
        } else { return rows.map( function( row ) { return row[ key ]; } ); } // if only a single key is given, return 1D-array of unpacked data
    };
    function Unpack_array_to_dict_data( arr, l_key = [ ] ) { // unpack array returned by papaparse into dictionary containing unpacked arrays // this is much faster than 'new DataFrame( arr ).toDict( )' method
        if ( l_key.length == 0 ) { // if list of keys is not given, use all keys of the first record for unpacking by default.
            l_key = Object.keys( arr[ 0 ] );
        }
        let dict_data = { };
        for ( let i = 0; i < l_key.length; i ++ ) {
            let key = l_key[ i ];
            dict_data[ key ] = unpack( arr, key );
        }
        return dict_data;
    }
    function Unpack_String_Numbers( data ) { // unpack a string containing a list of numbers
        let l = data.split( ',' ), l_data = [ ], bool_flag_float_datatype = data.includes( '.' ); // retrieve flag indicating the float datatype
        for ( let i = 0; i < l.length; i ++ ) {
            let value = l[ i ].length == 0? "0" : l[ i ];
            l_data.push( bool_flag_float_datatype? parseFloat( value ) : parseInt( value ) ); // parse float or integer datatype
        }
        return l_data;
    };
    function ColorMap_Rainbow( n_colors ) { // colormap witn the given number of colors
        let l_colormap = [ ]; 
        for ( let i = 0; i < n_colors; i ++ ) { 
            let f = i / n_colors; // convert to [0,1]

            let a = ( 1 - f ) * 5.0; // from a code found at "https://www.particleincell.com/2014/colormap/"
            let X = Math.floor( a );
            let Y = Math.floor( 255 * ( a - X ) );
            let r = 0, g = 0, b = 0;
            switch( X )
            {
                case 0: r = 255; g = Y; b = 0; break;
                case 1: r = 255 - Y; g = 255; b = 0; break;
                case 2: r = 0; g = 255; b = Y; break;
                case 3: r = 0; g = 255 - Y; b = 255; break;
                case 4: r = Y; g = 0; b = 255; break;
                case 5: r = 255; g = 0; b = 255; break;
            }
            l_colormap.push( {r:r,g:g,b:b} )
        }
        return l_colormap; // return a colormap
    }
    function ColorMap_Rainbow_Map( l_scalar ) { // map integer values in 'l_scaler' to rainbow rgb colormap 
        let min_value = Math.min.apply( null, l_scalar );
        let max_value = Math.max.apply( null, l_scalar );
        console.log( min_value, max_value )
        let l_colormap = [ ], l_mapped_color = [ ], n_colors = ( max_value - min_value + 1 ); // min and max values should be intergers
        for ( let i = 0; i < n_colors; i ++ ) { 
            let f = i / n_colors; // convert to [0,1]

            let a = ( 1 - f ) * 5.0; // from a code found at "https://www.particleincell.com/2014/colormap/"
            let X = Math.floor( a );
            let Y = Math.floor( 255 * ( a - X ) );
            let r = 0, g = 0, b = 0;
            switch( X )
            {
                case 0: r = 255; g = Y; b = 0; break;
                case 1: r = 255 - Y; g = 255; b = 0; break;
                case 2: r = 0; g = 255; b = Y; break;
                case 3: r = 0; g = 255 - Y; b = 255; break;
                case 4: r = Y; g = 0; b = 255; break;
                case 5: r = 255; g = 0; b = 255; break;
            }
            l_colormap.push( {r:r,g:g,b:b} )
        }
        for ( let i = 0; i < l_scalar.length; i ++ ) { l_mapped_color.push( l_colormap[ l_scalar[ i ] - min_value ] ); }
        return l_mapped_color; // return mapped colors
    }
    function hexToRgb(hex) { // https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
      // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
      let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, function(m, r, g, b) {
        return r + r + g + g + b + b;
      });

      let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }
    function rgbToHex(r, g, b) {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    function ColorGetDarkness( hex ) { // get darkness of color (hex)
        let c = hex.substring(1);      // strip #
        let rgb = parseInt(c, 16);   // convert rrggbb to decimal
        let r = (rgb >> 16) & 0xff;  // extract red
        let g = (rgb >>  8) & 0xff;  // extract green
        let b = (rgb >>  0) & 0xff;  // extract blue
        let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709 // get brightness
        return luma
    }
    
    function RetrieveDiscardedLength( str_discarded_regions, alignment_start ) { // retrieve length of discarded sequence from 'str_discarded_regions' for the given alignment start position
        let len_discarded_sequence = 0, l_discarded_regions = str_discarded_regions.split( ";" ).map( function( str ) { return str.split( ":" ).map( function( str ) { return parseInt( str ); } ) } );
        for ( let i = 0; i < l_discarded_regions.length; i ++ ) {
            if ( alignment_start < l_discarded_regions[ i ][ 0 ] ) { break; } // if the region is before the start of a discarded region, stop subtracting the length of discarded regions
            len_discarded_sequence += l_discarded_regions[ i ][ 1 ] // increase the length of discarded regions by the length of the current discarded region
        }
        return len_discarded_sequence;
    }
    function Unpack_String_rsa( seq ) { // unpack string containing RSA value using ASCII encoding (126 encodes null)
        let l_output = [ ];
        for ( let i = 0; i < seq.length; i ++ ) {
            let int_value = seq.charCodeAt( i ); // retrieve ASCII character as an integer number
            if ( int_value == 126 ) { l_output.push( null ); }
            else { l_output.push( Math.round( ( int_value - 33 ) / 92 * 100 ) / 100 ); } // RSA value range 0 ~ 1 // round up so that step is 1
        }
        return l_output;
    }
    function Unpack_String_rsa_encoded_by_two_char( seq ) { // unpack string containing RSA value using ASCII encoding with two characters (two 126 encodes null)
        let l_output = [ ];
        for ( let i = 0; i < parseInt( seq.length / 2 ); i ++ ) {
            let int_value_first_char = seq.charCodeAt( 2 * i ), int_value_second_char = seq.charCodeAt( 2 * i + 1 ); // retrieve ASCII character as an integer number
            if ( int_value_first_char == 126 && int_value_second_char == 126 ) { l_output.push( null ); }
            else { l_output.push( Math.round( ( int_value_first_char - 33 ) * ( int_value_second_char - 33 ) / 8648 * 1000 ) / 1000 ); } // RSA value range 0 ~ 1 // round up so that step is 1
        }
        return l_output;
    }
    function Unpack_String_torsion_angle( seq ) {
        let l_output = [ ];
        for ( let i = 0; i < seq.length; i ++ ) {
            let int_value = seq.charCodeAt( i ); // retrieve ASCII character as an integer number
            if ( int_value == 126 ) { l_output.push( null ); }
            else { l_output.push( Math.round( ( int_value - 33 ) / 92 * 360 ) - 180 ); } // torsion angle value range -180 ~ 180 // round up so that step is 1
        }
        return l_output;
    }
    function Unpack_String_ss8( seq ) {
        let l_ss8 = [ 'G', 'H', 'I', 'E', 'B', 'T', 'S', 'C' ];
        let l_output = [ ];
        for ( let i = 0; i < seq.length; i ++ ) {
            let int_value = seq.charCodeAt( i ); // retrieve ASCII character as an integer number
            if ( int_value >= 41 ) { l_output.push( null ); }
            else { l_output.push( l_ss8[ int_value - 33 ] ); } // retrieve encoded ss8 classification
        }
        return l_output;
    }
    function Unpack_String_datatype( seq ) {
        let l_datatype = [ 'predicted', 'modeling', 'PDB' ]; // [ 'prediction', 'homology modeling', 'experimental structure' ];
        let l_output = [ ];
        for ( let i = 0; i < seq.length; i ++ ) {
            let int_value = seq.charCodeAt( i ); // retrieve ASCII character as an integer number
            if ( int_value >= 36 ) { l_output.push( null ); }
            else { l_output.push( l_datatype[ int_value - 33 ] ); } // retrieve encoded datatype classification
        }
        return l_output;
    }
    function Unpack_String_structure_id( seq ) {
        let l_value = seq.split( ';' ), entry_previous = null, l_output = [ ], chr_representing_repeated_string = '=';
        for ( let i = 0; i < l_value.length; i ++ ) {
            let entry = l_value[ i ];
            if ( entry.length == 0 )  { l_output.push( null ); }
            else if ( entry == chr_representing_repeated_string ) { l_output.push( entry_previous ); }
            else { l_output.push( entry ); entry_previous = entry; }
        }
        return l_output;
    }
    function Align_Structural_Property( object_structure_property, seq ) { // align structural property and colors 
        let l_name_data = Object.keys( object_structure_property ), object_structure_property_aligned = { };
        for ( let i = 0; i < l_name_data.length; i ++ ) { // for each member (structural property data) in 'object_structure_property'
            let l_aligned_data = [ ], l_data = object_structure_property[ l_name_data[ i ] ], int_pos_data = 0; // initial position is 0
            for ( let j = 0; j < seq.length; j ++ ) {
                let residue = seq[ j ]; // for each residue in the alignment
                if ( residue == '-' ) { // add value representing a gap when encounter a gap (for color, the value representing the gap is the color 'black')
                    let value_representing_gap = l_name_data[ i ].includes( "color_" )? "#000000" : '-';
                    l_aligned_data.push( value_representing_gap );
                } else {
                    l_aligned_data.push( l_data[ int_pos_data ] ); // add data value when encounter a non-gap residue
                    int_pos_data += 1;
                }
            }
            object_structure_property_aligned[ l_name_data[ i ] ] = l_aligned_data; // add aligned data
        }
        return object_structure_property_aligned;
    }
    
    var color_representing_null = "#c3c3c3"; // color representing null value is grey color
    function Color_for_rsa( l_rsa ) {
        let l_color = [ ], function_colormap = function_colormap_rsa;
        for ( let i = 0; i < l_rsa.length; i ++ ) { l_color.push( l_rsa[ i ] == null? color_representing_null : function_colormap( l_rsa[ i ] * 2 ).toString( ) ); } // RSA of 0.5 will be represented as 'fully accessible to the surface'
        return l_color;
    }
    function Color_for_score_blosum( l_score_blosum ) {
        let l_color = [ ], function_colormap = function_colormap_score_blosum;
        for ( let i = 0; i < l_score_blosum.length; i ++ ) { l_color.push( l_score_blosum[ i ] == null? color_representing_null : function_colormap( ( l_score_blosum[ i ] + 3 ) / 6 ).toString( ) ); } // display blosum62 score from -5 to 5
        return l_color;
    }
    function Color_for_torsion_angle( l_torsion_angle ) {
        let l_color = [ ], function_colormap = function_colormap_torsion_angle;
        for ( let i = 0; i < l_torsion_angle.length; i ++ ) { l_color.push( l_torsion_angle[ i ] == null? color_representing_null : function_colormap( ( l_torsion_angle[ i ] + 180 ) / 360 ).toString( ) ); }
        return l_color;
    }
    function Color_for_ss8( l_ss8 ) {
        let l_color = [ ], dict_colormap = { G: "#b2d0ed", H: "#b2d0ed", I: "#b2d0ed", E: "#f7b4a3", B: "#f7b4a3", T: "#cbf7c8", S: "#cbf7c8", C: "#edebe4" };
        for ( let i = 0; i < l_ss8.length; i ++ ) { l_color.push( l_ss8[ i ] == null? color_representing_null : dict_colormap[ l_ss8[ i ] ] ); }
        return l_color;
    }
    function Color_for_datatype( l_datatype ) {
        let l_color = [ ], dict_colormap = { predicted: "#fffafe", modeling: "ffc38a", PDB: "#ff8b14" };
        for ( let i = 0; i < l_datatype.length; i ++ ) { l_color.push( l_datatype[ i ] == null? color_representing_null : dict_colormap[ l_datatype[ i ] ] ); }
        return l_color;
    }
    function Color_for_structure_id( l_structure_id ) {
        let l_color = [ ];
        for ( let i = 0; i < l_structure_id.length; i ++ ) { l_color.push( l_structure_id[ i ] == null? color_representing_null : "#ffffff" ); } // color representing value structure_id is 'white' color
        return l_color;
    }
    
    var plotMolecularMimicryMap = document.getElementById( 'plotly_graph_molecular_mimicry_map' );
    var plotBCellCrossReactivityMetrics = document.getElementById( 'plotly_graph_b_cell_cross_reactivity' );
    var plotTCellCrossReactivityMetrics = document.getElementById( 'plotly_graph_t_cell_cross_reactivity' );
    var plotqueryProteinMetrics = document.getElementById( 'plotly_graph_query_protein' );
    var plotGTEx = document.getElementById( 'plotly_graph_gtex' );
    var plotscrnaseq = document.getElementById( 'plotly_graph_scrnaseq_expression' );
    var tableMetrics = document.getElementById( 'd3_table_metrics' );
    var tableSequence = document.getElementById( 'plotly_table_sequence' );
    
    var str_jquery_container = "#container_PDB"; // JQuery string for returning promise for collapse transition of the container targeted by 'str_jquery_container'
    const BootstrapCollapseShownPromise = ( str_jquery ) => { // return promise when content is fully shown to the screen
        return new Promise( ( resolve, reject ) => {
            jQuery( str_jquery ).collapse( 'show' ) // trigger transition
            jQuery( str_jquery ).on( 'shown.bs.collapse', function( ) { // when transition is complete, resolve the promise
                console.log( "shown" );
                resolve( 'shown' );
            });
        });
    }
    const MolStarRenderCompletePromise = ( instance_molstar_viewer ) => { // return promise when content is fully shown to the screen
        return new Promise( ( resolve, reject ) => {
            instance_molstar_viewer.events.loadComplete.subscribe( function( ) { // when transition is complete, resolve the promise
                console.log( "rendering was completed" );
                resolve( "rendering was completed" );
            });
        });
    }
    
    async function LoadFasta( file ) { // async. function for loading a fasta file (return a promise that resolve when parsing of FASTA file is completed)
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        return new Promise( ( resolve, reject ) => {
            let reader = new FileReader( ); // initialize FileReader
            reader.onload = function( progressEvent ) {
                var l_line = this.result.split( '\n' ); // By lines
                let index = 0, line = '';
                line = l_line[ index ]; // retrieve the first line as a header
                let str_header = line, l_seq = [ ];
                while ( true ) {
                    str_header = line, l_seq = [ ];
                    while ( true ) {
                        index ++;
                        if ( index >= l_line.length ) { break; }
                        line = l_line[ index ];
                        if ( line[ 0 ] == '>' ) { break; }
                        l_seq.push( line );
                    }
                    let header = str_header.slice( 1 ), seq = l_seq.join( '' );
                    if ( header in dataset.vaccine_design.dict_duplicated_header_count ) { dataset.vaccine_design.dict_duplicated_header_count[ header ] ++; } // handle sequences with duplicated headers
                    else { dataset.vaccine_design.dict_duplicated_header_count[ header ] = 1; }
                    if ( dataset.vaccine_design.dict_duplicated_header_count[ header ] > 1 ) { dataset.vaccine_design.dict_header_to_seq[ header + '_dup_' + String( dataset.vaccine_design.dict_duplicated_header_count[ header ] ) ] = seq; } // if current fastq header in already exists, add '_dup_{index}' to the header to make it unique 
                    else { dataset.vaccine_design.dict_header_to_seq[ header ] = seq; }
                    if ( index >= l_line.length ) { break; }
                }
                console.log( file, "loaded and parsed." );
                resolve( ); // when loading and parsing is complete, resolve the promise
            };
            reader.readAsText( file )
        });
    }
    async function LoadRemoteFasta( file ) { // async. function for loading a remote fasta file through URL (return a promise that resolve when parsing of FASTA file is completed)
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        return new Promise( ( resolve, reject ) => {
            jQuery.get( file, function( data ) {
                var l_line = data.split( '\n' ); // process each line
                let index = 0, line = '';
                line = l_line[ index ]; // retrieve the first line as a header
                let str_header = line, l_seq = [ ];
                while ( true ) {
                    str_header = line, l_seq = [ ];
                    while ( true ) {
                        index ++;
                        if ( index >= l_line.length ) { break; }
                        line = l_line[ index ];
                        if ( line[ 0 ] == '>' ) { break; }
                        l_seq.push( line );
                    }
                    let header = str_header.slice( 1 ), seq = l_seq.join( '' );
                    if ( header in dataset.vaccine_design.dict_duplicated_header_count ) { dataset.vaccine_design.dict_duplicated_header_count[ header ] ++; } // handle sequences with duplicated headers
                    else { dataset.vaccine_design.dict_duplicated_header_count[ header ] = 1; }
                    if ( dataset.vaccine_design.dict_duplicated_header_count[ header ] > 1 ) { dataset.vaccine_design.dict_header_to_seq[ header + '_dup_' + String( dataset.vaccine_design.dict_duplicated_header_count[ header ] ) ] = seq; } // if current fastq header in already exists, add '_dup_{index}' to the header to make it unique 
                    else { dataset.vaccine_design.dict_header_to_seq[ header ] = seq; }
                    if ( index >= l_line.length ) { break; }
                }
                console.log( "[LoadRemoteFasta] remote file", file, "loaded and parsed." );
                resolve( ); // when loading and parsing is complete, resolve the promise
            });
        });
    }
    

    function Download_Analysis_Result__Vaccine_Design( ) { // download analysis result of vaccine candidate as a csv file
        if ( dataset.vaccine_design.string_csv.length == 0 ) {
            let df = new DataFrame( dataset.vaccine_design.dict_data );
            dataset.vaccine_design.string_csv = df.toCSV( true );
        }
        let blob = new Blob( [ dataset.vaccine_design.string_csv ], { type: "text/plain;charset=utf-8" } );
        let name_file = dataset.vaccine_design.l_file_fasta[ 0 ].name;
        name_file = name_file.slice( 0, name_file.lastIndexOf( '.' ) ) + '_MolecularMimicryMap_of_SARS-CoV-2_analysis_result.csv'
        saveAs( blob, name_file ); // save file 
    }
    
    var l_parsed_data = [ ];
    var function_colormap_rsa = chroma.scale( [ 'black', 'white' ] ), function_colormap_score_blosum = chroma.scale( [ '#f00','white', '#0f0' ] ), function_colormap_torsion_angle = chroma.scale( [ '#52f9ff', '#972ff7', 'yellow', '#52f9ff' ] ), function_colormap_score_iedb_epitope = chroma.scale( [ '#ff00f2', '#1500ff' ] ), function_colormap_rainbow = chroma.scale( [ '#f00','#0f0','#00f','#f00' ] ).mode('hsl'); // define functions for colormaps
    async function LoadRemoteData( l_dir_file ) { // load list of given tsv files from remote locations through asynchrous operations
        return new Promise( async function( resolve, reject ) { 
            console.log( "[LoadRemoteData] remote data fetch started:", l_dir_file );
            Loading_Screen( true ) // add loading screen
            let l_dir_file_not_downloaded = [ ];
            for ( let i = 0; i < l_dir_file.length; i ++ ) { // ignore already downloaded files
                if ( ! ( l_dir_file[ i ] in object_data.file.dict_dir_file_to_parsed_data ) ) { 
                    l_dir_file_not_downloaded.push( l_dir_file[ i ] );
                } // if current file has not been downloaded, download the file 
            }
            l_dir_file = l_dir_file_not_downloaded;
            let l_promise = l_dir_file.map( function( file ) { 
                if( file.split( '.' ).slice( - 1 )[ 0 ] == "tsv" ) { // if given remote file is a tsv file
                    return new Promise ( function( resolve, reject ) {
                        Papa.parse( file, { download: true, header: true, skipEmptyLines: false, delimiter: '\t', dynamicTyping: true, complete: function( results ) { resolve( results.data.slice( 0, results.data.length - 1 ) ) }, error: reject } );
                    });
                } else if ( file.split( '.' ).slice( - 2 ).join( '.' ) == "base64.txt" ) { // if given remote file is base64-encoded binary file
                    return new Promise ( function( resolve, reject ) {
                        fetch( file )
                            .then( ( response ) => {
                              return response.text( );
                           }).then( ( text_base64 ) => {
                              return ParseBase64GzippedText( text_base64 );
                           }).then( ( text ) => {
                              Papa.parse( text, { download: false, header: true, skipEmptyLines: false, delimiter: '\t', dynamicTyping: true, complete: function( results ) { resolve( results.data.slice( 0, results.data.length - 1 ) ) }, error: reject } );
                           }).catch( err => { reject } );
                    });
                }
            }); // 'skipEmptyLines' is set to false to allow reading empty lines in some input files // due to 'skipEmptyLines: false' option, the last line is empty, and should be discarded
            let results = await Promise.all( l_promise ); // wait until all files have been parsed by Papa.parse
            l_parsed_data = [ ]; // empty a list
            l_parsed_data.push( ... results );
            for ( let i = 0; i < l_dir_file.length; i ++ ) { 
                object_data.file.dict_dir_file_to_parsed_data[ l_dir_file[ i ] ] = l_parsed_data[ i ];
            } // put parsed data into a dictionary
            console.log( "[LoadRemoteData] remote data loaded:", l_dir_file );
            resolve( "[LoadRemoteData] resolved" )
            Loading_Screen( false ) // add loading screen
        });
    }

    function SplitColumn( dictarr, delimiter = '|' ) { // split column name of the given dict_array into two with the given delimiter character and return dict_dict_array # 20201106
        let dictdictarr = { };
        for ( let col in dictarr ) {
            let col_split = col.split( "|" );
            if ( ! ( col_split[ 0 ] in dictdictarr ) ) {
                dictdictarr[ col_split[ 0 ] ] = { };
            }
            dictdictarr[ col_split[ 0 ] ][ col_split[ 1 ] ] = dictarr[ col ];
        }
        return dictdictarr;
    }
    function SubsetDictDictArr( dictdictarr, l_col_inner, fill_empty_columm_if_not_exist = true, fill_value = 0 ) { // subset a given dictdictarr with a given list of l_col_inner list containing column names of the inner layer. if only one column is given, return dictarray containing the inner column # 20201106
        // 'fill_empty_columm_if_not_exist' : if true, fill empty column with 'fill_value' value
        if ( Array.isArray( l_col_inner ) ) { // subset a given dictdictarr with a given list of l_col_inner list containing column names of the inner layer.
            let dictdictarr_subset = { };
            for ( let col_outer in dictdictarr ) {
                for ( let i = 0; i < l_col_inner.length; i ++ ) {
                    let col_inner = l_col_inner[ i ];
                    if ( ! ( col_inner in dictdictarr[ col_outer ] ) ) {
                        if ( fill_empty_columm_if_not_exist ) { // 'fill_empty_columm_if_not_exist' : if true, fill empty column with 'fill_value' value
                            dictdictarr[ col_outer ][ col_inner ] = ArrayFull( dictdictarr[ col_outer ][ Object.keys( dictdictarr[ col_outer ] )[ 0 ] ].length, fill_value ); // assume that the length of array is same for all columns
                        }
                    } else {
                        if ( ! ( col_outer in dictdictarr_subset ) ) {
                            dictdictarr_subset[ col_outer ] = { };
                        }
                        dictdictarr_subset[ col_outer ][ col_inner ] = dictdictarr[ col_outer ][ col_inner ]
                    }
                }
            }
            return dictdictarr_subset;
        } else { // if only one column is given, return dictarray containing the inner column
            let col_inner_subset = l_col_inner;
            let dictarr = { };
            for ( let col_outer in dictdictarr ) {
                if ( ! ( col_inner_subset in dictdictarr[ col_outer ] ) ) {
                    dictarr[ col_outer ] = ArrayFull( dictdictarr[ col_outer ][ Object.keys( dictdictarr[ col_outer ] )[ 0 ] ].length, fill_value ); // assume that the length of array is same for all columns
                } else {
                    dictarr[ col_outer ] = dictdictarr[ col_outer ][ col_inner_subset ]
                }
            }
            return dictarr;
        }
    }
    function ParseData_DatasetCore( name_dataset ) { // parse 'arr_data_blosum62' and build blosum62 matrix # 20210110
        console.log( "[ParseData_DatasetCore] Core dataset initialization started for " + name_dataset );
        let dir_folder = object_data.file.base_url + "data/base64/" + name_dataset + "/", // retrieve directory of the current folder of the current dataset
            dataset = object_data.main.dataset[ name_dataset ];
        
        // modify HTML elements
        if ( ! object_data.flag.cross_reactive_mhc_ligand_data_exist ) { // when MHC ligand prediction data does not exist
            $( "#plotly_graph_t_cell_cross_reactivity" ).collapse( 'hide' ); // hide T-cell cross-reactivity panel
            $( "#toggle_TCellCrossReactivityPrediction_MolecularMimicryMap" ).prop( "disabled", true ); 
            $( "#btn_toggle_mhc_cross_reactivity_metrics" ).prop( "disabled", true ); 
            $( "#container_expression_panel_MolecularMimicryMap" ).collapse( 'hide' ); // hide gene expression panel
            $( "#btn_toggle_gene_expression_panel" ).prop( "disabled", true ); 
        } else { // activate buttons
            $( "#toggle_TCellCrossReactivityPrediction_MolecularMimicryMap" ).prop( "disabled", false ); 
            $( "#btn_toggle_mhc_cross_reactivity_metrics" ).prop( "disabled", false );
            $( "#btn_toggle_gene_expression_panel" ).prop( "disabled", false ); 			
        }
        
        if ( ! object_data.flag.query_label_represents_target ) {
            // initialize 
            if ( ! ( 'gtex' in dataset ) ) { 
                dataset.gtex = { };
                dataset.gtex.dict_name_tissue_to_color = {
                    "Adipose Tissue (n=1204)" : "#FF4500",
                    "Muscle (n=803)" : "#9370DB",
                    "Blood Vessel (n=1335)" : "#B22222",
                    "Heart (n=861)" : "#4B0082",
                    "Uterus (n=142)" : "#FF69B4",
                    "Vagina (n=156)" : "#FF1493",
                    "Breast (n=459)" : "#00CED1",
                    "Skin (n=1809)" : "#0000FF",
                    "Salivary Gland (n=162)" : "#8FBC8F",
                    "Brain (n=2642)" : '#FFD700',
                    "Adrenal Gland (n=258)" : '#228B22',
                    "Thyroid (n=653)" : "#006400",
                    "Lung (n=578)" : "#7FFF00",
                    "Spleen (n=241)" : "#556B2F",
                    "Pancreas (n=328)" : "#8B0000",
                    "Esophagus (n=1445)" : "#800000",
                    "Stomach (n=359)" : "#F0E68C",
                    "Colon (n=779)" : "#CD853F",
                    "Small Intestine (n=187)" : "#2F4F4F",
                    "Prostate (n=245)" : "#D3D3D3",
                    "Testis (n=361)" : "#778899",
                    "Nerve (n=619)" : "#F0E68C",
                    "Blood (n=929)" : "#FF0000",
                    "Pituitary (n=283)" : "#98FB98",
                    "Ovary (n=180)" : "#FFC0CB",
                    "Liver (n=226)" : "#9ACD32",
                    "Kidney (n=89)" : "#00FFFF",
                    "Cervix Uteri (n=19)" : "#DDA0DD",
                    "Fallopian Tube (n=9)" : "#FFDAB9",
                    "Bladder (n=21)" : "#8B0000"
                }; // define color for each tissue
            }
            if ( ! ( 'scrnaseq' in dataset ) ) { 
                dataset.scrnaseq = { option: { }, dictdictarr: { }, dict_dir_file_to_cached_data: { } }; // object for saving settings for scrnaseq plot // dictionary to save cached data
                dataset.scrnaseq.metadata = Unpack_array_to_dict_data( object_data.file.dict_dir_file_to_parsed_data[ dataset.dir_folder + "scrnaseq.metadata.tsv.gz.base64.txt" ] ); // load metadata of scRNA-seq datasets
                dataset.scrnaseq.setting = { histogram : { start: 0, step: 0.1 }, gene_of_interest: "ACE2", thres_n_clusters_for_label_newline: 22, cache : { n_records: 5 } } // setting for compact histogram count data. // set maximum records for saving cache for rapid plotting // 'thres_n_clusters_for_label_newline': a threshold number of cluster that removes line breaks in the labels.

                PlotExpression_scRNA_Seq_Update_Select_Options( "20200804_NasalSwab_Broad_BCH_UMMC_to_CZI.h5ad" ); // update select option and select given dataset by default (update selection label)
            }
            if ( ! ( 'l_algorithm' in dataset ) ) {
                dataset.l_algorithm = unpack( object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "algorithms.tsv.gz.base64.txt" ], 'value' ); } // list of algorithms
            if ( ! ( 'dictarr_data_mhc_allele' in dataset ) ) {
                dataset.dictarr_data_mhc_allele = Unpack_array_to_dict_data( object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "mhc_allele.tsv.gz.base64.txt" ] ); }
            if ( ! ( 'dictdictarr' in dataset.gtex ) ) {
                dataset.gtex.dictdictarr = SplitColumn( Unpack_array_to_dict_data( object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "gtex.tsv.gz.base64.txt" ] ) ); } // retrieve dictionary-dictionary-array of gtex data
            // simply put arrays in the name space of the dataset
            dataset.arr_data_mhc_allele = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "mhc_allele.tsv.gz.base64.txt" ];
        } else {
            
        }

        // load dict_blosum62 score dictionary if it has not been loaded
        if ( ! ( 'dict_blosum62' in object_data.main ) ) { 
            let arr_data_blosum62 = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "blosum62.tsv.gz.base64.txt" ]; // blosum62 score matrix
            object_data.main.dict_blosum62 = { }; 
            for ( let i = 0; i < arr_data_blosum62.length; i ++ ) { 
                object_data.main.dict_blosum62[ arr_data_blosum62[ i ].pair_of_amino_acids ] = arr_data_blosum62[ i ].score_blosum62;
            }
        }
        if ( ! ( 'dictarr_data_acc_target' in dataset ) ) {
            dataset.dictarr_data_acc_target = Unpack_array_to_dict_data( object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "acc_target.tsv.gz.base64.txt" ] ); }
        if ( ! ( 'dictarr_data_acc_pdb' in dataset ) ) {
            dataset.dictarr_data_acc_pdb = Unpack_array_to_dict_data( object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "acc_pdb.tsv.gz.base64.txt" ] ); }

            
        if ( ! ( 'acc_query' in dataset ) ) {
            dataset.acc_query = { };
            dataset.acc_query.dict_data_all = Unpack_array_to_dict_data( object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "acc_query.tsv.gz.base64.txt" ] );
            dataset.dictarr_data_acc_query = dataset.acc_query.dict_data_all;
            dataset.acc_query.dictionary_query_gene_symbol_upper_case_to_l_index = Index_list_with_dictionary( dataset.acc_query.dict_data_all[ object_data.setting.name_acc_query ].map( ( e ) => { return e.toUpperCase( ); } ) ); // index records according to datatype of records with the 'query' labels
        }
        // build dictionary-based index of query genes (gene_symbol)
        if ( ! ( 'dictionary_gene_symbol_lower_case_to_list_of_integer_index' in dataset ) ) {
            dataset.dictionary_gene_symbol_lower_case_to_list_of_integer_index = Index_list_with_dictionary( dataset.acc_query.dict_data_all[ object_data.setting.name_acc_query ].map( ( e ) => { return e.toLowerCase( ); } ) );
        } 
        
        // simply put arrays in the name space of the dataset
        dataset.arr_data_acc_target = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "acc_target.tsv.gz.base64.txt" ];
        dataset.arr_data_acc_pdb = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "acc_pdb.tsv.gz.base64.txt" ];
        dataset.arr_data_acc_query = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "acc_query.tsv.gz.base64.txt" ];
        dataset.arr_data_alignment_query_pdb = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "alignment_query_pdb__compact__for_web_application.tsv.gz.base64.txt" ];
        dataset.arr_data_alignment_query_target = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "alignment_query_target__compact__for_web_application.tsv.gz.base64.txt" ];
        dataset.arr_data_alignment_target_pdb = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "alignment_target_pdb__compact__for_web_application.tsv.gz.base64.txt" ];
        dataset.arr_data_structural_property_query = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "structural_property_query__compact__for_web_application.tsv.gz.base64.txt" ];
        dataset.arr_data_structural_property_target = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "structural_property_target__compact__for_web_application.tsv.gz.base64.txt" ];

        // retrieve list of target species
        if ( object_data.flag.query_label_represents_target ) { // retrieve list of target species when the dataset of cross-reactivity between targetes has been loaded.
            if ( "Species" in dataset.dictarr_data_acc_query ) {
                dataset.l_target_species = Unique( dataset.dictarr_data_acc_query.Species );
            } else {
                
            }
        } else if ( "Species" in dataset.dictarr_data_acc_target ) { 
            dataset.l_target_species = Unique( dataset.dictarr_data_acc_target.Species );
        } else {
            dataset.l_target_species = [ "Severe acute respiratory syndrome coronatarget 2" ]; // target species is SARS-CoV-2 by default 
        }
        //  assign color to query proteins // build a colormap for representing accessions of query proteins
        if ( ! ( 'l_colormap_rainbow_acc_query' in dataset ) ) {
            let l_gene_symbol = dataset.acc_query.dict_data_all[ object_data.setting.name_acc_query ];
            dataset.l_colormap_rainbow_acc_query = [ ]; // initialize the list of mapped colors
            dataset.l_float_for_colormap_rainbow_acc_query = [ ];
            for ( let i = 0; i < l_gene_symbol.length; i ++ ) {
                let str_gene_symbol = l_gene_symbol[ i ], float_for_colormap = ( Math.abs( str_gene_symbol.hashCode( ) ) % 10000 ) / 10000, str_color = function_colormap_rainbow( float_for_colormap ).toString( );
                dataset.l_float_for_colormap_rainbow_acc_query.push( float_for_colormap )
                dataset.l_colormap_rainbow_acc_query.push( str_color ); // assign color to gene_symbol using a 32-bit hashing function
                
                object_data.main.dictionary_query_gene_symbol_lower_case_to_color[ str_gene_symbol.toLowerCase( ) ] = str_color; // update global colormap
            }
        }
        //  assign color to query proteins and target species // build a colormap for representing accessions of query proteins
        if ( ! ( 'dict_target_species_to_rainbow_color' in dataset ) ) {
            let int_hash = 4217, // integer used for retrieving float from the hash
                dict_target_species_to_float_rainbow_color_preset = { "Severe acute respiratory syndrome coronatarget 2" : 0.84,
                    "Severe acute respiratory syndrome-related coronatarget" : 0.04,
                    "Middle East respiratory syndrome-related coronatarget" : 0.12,
                    "Betacoronatarget 1" : 0.18,
                    "query coronatarget 229E" : 0.26,
                    "query coronatarget NL63" : 0.42,
                    "query coronatarget HKU1" : 0.5,
                    "Coronatarget cya-BetaCoV/2019" : 0.54,
                    "Coronatarget cyb-BetaCoV/2019" : 0.58,
                    "Coronatarget cyc-BetaCoV/2019" : 0.76 }; // manually selected colors for target species (for more intuitive visualization )
            dataset.dict_target_species_to_rainbow_color = { }; // initialize the list of mapped colors
            dataset.dict_target_species_to_float_rainbow_color = { };

            
            for ( let i = 0; i < dataset.l_target_species.length; i ++ ) {
                let str_target_species = dataset.l_target_species[ i ],
                    float_for_colormap = ( str_target_species in dict_target_species_to_float_rainbow_color_preset ) ? dict_target_species_to_float_rainbow_color_preset[ str_target_species ] : ( Math.abs( str_target_species.hashCode( ) ) % int_hash ) / int_hash, // assign float using string-based hashing
                    str_color = function_colormap_rainbow( float_for_colormap ).toString( );
                dataset.dict_target_species_to_float_rainbow_color[ str_target_species ] = float_for_colormap;
                dataset.dict_target_species_to_rainbow_color[ str_target_species ] = str_color; // assign color to gene_symbol using a 32-bit hashing function
                
                object_data.main.dictionary_target_species_to_color[ str_target_species ] = str_color; // update global colormap
            }
        }
        console.log( "[ParseData_DatasetCore] Core dataset initialized for " + name_dataset );
    }

    function ParseData_AlignmentToquery( name_dataset ) {
        if ( object_data.flag.query_label_represents_target ) { // when target proteins are not used, AlignmentToquery option is not available
            return -1
        }
        // parse dataset for visualization with AlignmentToquery alignment mode
        let dir_folder = object_data.file.base_url + "data/base64/" + name_dataset + "/", // retrieve directory of the current folder of the current dataset
            dataset = object_data.main.dataset[ name_dataset ];
        console.log( "[ParseData_AlignmentToquery] dataset initialization started for " + name_dataset + " visualized with 'AlignmentToquery' mode" );
        
        // modify HTML elements
        $( "#navbar_vaccine_design" ).collapse( 'hide' ); // hide vaccine design panel
        $( "#btn_for_opening_navbar_vaccine_design" ).prop( "disabled", true ); // disable vaccine design panel toggle button
        $( "#plotly_graph_query_protein" ).collapse( 'hide' ); // hide vaccine design panel
        $( "#btn_toggle_query_protein_metrics" ).prop( "disabled", true ); // disable query metrics plot
        $( "#button_update_query_protein_metrics_plot" ).prop( "disabled", true ); 
        $( "#toggle_vaccine_metrics_MolecularMimicryMap" ).prop( "disabled", true ); 
        $( "#toggle_vaccine_design_MolecularMimicryMap" ).prop( "disabled", true ); 
        
        dataset.arr_data_iedb_epitope_query = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "iedb_epitope_query.tsv.gz.base64.txt" ];
        
        // initialize dataset specific for alignment to query reference proteome
        if ( ! ( 'iedb_epitope_query' in dataset ) ) { 
            dataset.iedb_epitope_query = { };
            dataset.iedb_epitope_query.dict_data_all = Unpack_array_to_dict_data( object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "iedb_epitope_query.tsv.gz.base64.txt" ] );
            dataset.iedb_epitope_query.dict_data_all[ "humen_gene_symbol" ] = ArrayApply( dataset.iedb_epitope_query.dict_data_all[ "accession_query" ], function( i ) { return dataset.acc_query.dict_data_all[ "Gene_Symbol" ][ i ].toUpperCase( ); } ); // retrieve gene_symbol of query proteins // used for indexing (use upper case to make search case-insensitive)
            dataset.iedb_epitope_query.dictionary_query_gene_symbol_upper_case_to_l_index = Index_list_with_dictionary( dataset.iedb_epitope_query.dict_data_all[ "humen_gene_symbol" ] ); // index with query_gene_symbol
        }
        if ( ! ( 'interpro_query' in dataset ) ) { 
            dataset.interpro_query = { };
            dataset.interpro_query.show = $( "#toggle_ProteinAnnotation_MolecularMimicryMap" ).hasClass( "active" ); // set visibility of protein annotations
            dataset.interpro_query.arr_data_all = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "interpro_query.tsv.gz.base64.txt" ];
            dataset.interpro_query.dict_data_all = Unpack_array_to_dict_data( dataset.interpro_query.arr_data_all ); // interpro annotation of query proteins
            dataset.interpro_query.dict_data_all[ "humen_gene_symbol" ] = ArrayApply( dataset.interpro_query.dict_data_all[ "accession_query" ], function( i ) { return dataset.acc_query.dict_data_all[ "Gene_Symbol" ][ i ].toUpperCase( ); } ); // retrieve gene_symbol of query proteins // used for indexing (use upper case to make search case-insensitive)
            dataset.interpro_query.dictionary_query_gene_symbol_upper_case_to_l_index = Index_list_with_dictionary( dataset.interpro_query.dict_data_all[ "humen_gene_symbol" ] ); // index with query_gene_symbol
        }
        console.log( "[ParseData_AlignmentToquery] dataset initialized for " + name_dataset + " visualized with 'AlignmentTotarget' mode" );
    }
    async function ParseData( ) { // parse loaded data and prepare for plotting molecular mimicry map plots
        let l_name_dataset = object_data.main.l_name_dataset;
        
        for ( let i = 0; i < l_name_dataset.length; i ++ ) {
            let name_dataset = l_name_dataset[ i ];
            console.log( "[ParseData] parsing dataset for " + name_dataset );

            if ( ! ( name_dataset in object_data.main.dataset ) ) { // initialize data dictionary of a dataset
                object_data.main.dataset[ name_dataset ] = { flag: { vaccine_design_optivax_loaded: false }, 
                                                            dir_folder: `${object_data.file.base_url}data/base64/${name_dataset}/`,
                                                            object_plot_BCellCrossReactivity : { },
                                                            object_plot_TCellCrossReactivity : { }
                                                           };
            }
            let dir_folder = object_data.file.base_url + "data/base64/" + name_dataset + "/", // retrieve directory of the current folder of the current dataset
                dataset = object_data.main.dataset[ name_dataset ];
            
            ParseData_DatasetCore( name_dataset ); // parse core data
            
            if ( object_data.flag.alignment_to_target ) {
                ParseData_AlignmentTotarget( name_dataset );
            } else {
                ParseData_AlignmentToquery( name_dataset );
            }
        }
        
        return new Promise( async function( resolve, reject ) { 
            await DrawMolecularMimicryMap( );
            Display_DataTable( );
            console.log( "[ParseData] resolved" );
            Loading_Screen( false );
            resolve( "[ParseData] resolved" );
        });
    }
    
    var object_datatable_acc_query = [ ], df_datatable = null; // objects containing 2D-array for drawing datatable
    function Display_DataTable( ) { // load datatable with loaded datasets
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // use the first dataset to display data
        let name_data = document.getElementById( "select_datatable" ).value, columns = [ ], dataSet = [ ], df = null, l_col = [ ];
        console.log( "Loading datatable", name_data );
        if ( name_data == "acc_query.tsv" ) { // retrieve appropriate dataframe for each setting
            if( object_data.flag.query_label_represents_target ) { // do not show datatable of acc_query when query label represent target proteins
                return - 1
            }
            df = new DataFrame( dataset.arr_data_acc_query );
            df = df.select( "Gene_Symbol", "value", "n_counts", "seq_length", "description", "IEDB___n_unique_epitopes", "AAgAtlas___n_PubMed_ID" );
        } else if ( name_data == "acc_target_representative.tsv" ) {
            df = new DataFrame( dataset.arr_data_acc_target_representative );
            df = df.select( "name", "accession", "uniprot_acc", "length", "n_non_redundant_proteins" );
        } else if ( name_data == "mhc_allele.tsv" ) {
            df = new DataFrame( dataset.arr_data_mhc_allele );
        } else if ( name_data == "interpro_target.tsv" ) {
            df = new DataFrame( dataset.interpro_target.dict_data );
            df = df.select( "protein_name", "start", "end", "interpro_acc", "interpro_name", "annotation_acc" );
        } else if ( name_data == "iedb_epitope_target.tsv" ) {
//             if ( object_data.flag.alignment_to_target ) {
//                 df = new DataFrame( dataset.iedb_epitope_target.dict_data );
//                 df = df.select( "accession_iedb", "iedb_epitope_sequence", "number_of_positive_B_cell_assay", "number_of_positive_T_cell_assay", "protein_name", "start", "end", "percent_identity", "mismatch", "gapopen" );
//             }
        } 
        df_datatable = df;
        dataSet = df_datatable.toArray( ), l_col = df_datatable.listColumns( );
        for ( let i = 0; i < l_col.length; i ++ ) { columns.push( { title: l_col[ i ] } ); }

        $( '#container_datatable_MolecularMimicryMap' ).empty( ); // empty the datatable and redraw the datatable
        $( '#container_datatable_MolecularMimicryMap' ).append( '<table id="datatable_MolecularMimicryMap" class="display" width="100%"></table>' );
        $( '#datatable_MolecularMimicryMap' ).DataTable( { data: dataSet, columns: columns } ); // display the datatable
    }
    var string_csv_datatable = "";
    function Download_DataTable( ) { // download analysis result of vaccine candidate as a csv file
        if ( df_datatable != null ) {
            string_csv_datatable = df_datatable.toCSV( true );
        }
        let blob = new Blob( [ string_csv_datatable ], { type: "text/plain;charset=utf-8" } );
        let name_file = document.getElementById( "select_datatable" ).value // retrieve the name of the current data
        name_file = name_file.slice( 0, name_file.lastIndexOf( '.' ) ) + '_MolecularMimicryMap_of_SARS-CoV-2_datatable.csv' // change the extension of the filename
        saveAs( blob, name_file ); // save file 
    }
    
    var l_a = [ ];
    var l_b = [ ], l_xy = [ ];
    // settings for Plotly plots
    var float_line_type_opacity_MolecularMimicryMap_BCellCrossReactivity = 0.5, float_opacity_MolecularMimicryMap_TCellCrossReactivity = 0.5;
    // plot Plotly plots
    var dict_name_plot_to_trace_index__MolecularMimicryMap = { }; // dictionary mapping name of plot to trace index
    var object_plot_BCellCrossReactivity = { }, object_plot_TCellCrossReactivity = { };
    var arr_data_BCellCrossReactivity = [ ], arr_data_TCellCrossReactivity = [ ]; // lists containing data of currently plotted B/TCellCrossReactivity records
    var trace_point_type_MolecularMimicryMap_BCellCrossReactivity = { mode: 'markers', marker: { line: { } }, showlegend: false }, data_line_type_MolecularMimicryMap_BCellCrossReactivity = [ ], trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query = { mode: 'markers', marker: { line: { } }, showlegend: false }, trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target = { mode: 'markers', marker: { line: { } }, showlegend: false }, trace_BCellCrossReactivityMetrics = { type: 'parcoords', line: { color: "#aa00ff" }, dimensions: [ ] }, trace_TCellCrossReactivityMetrics = { type: 'parcoords', line: { color: '#aa00ff' }, dimensions: [ ] };
    // graph setting from graph setting panel
    var plotly_type_BCellCrossReactivity = 'scattergl', plotly_type_TCellCrossReactivity = 'scattergl', int_index_representation_TCellCrossReactivity = 1, int_index_MHC_class_TCellCrossReactivity = 3; 
    // variables for interactions
    var clicked_record = { }, clicked_record_parsed = { }, arr_data_clicked = [ ], trace_tableSequence = { };
    // general Plotly settings
    var config = { responsive: true, displaylogo: false, toImageButtonOptions: { hoverClosestCartesian: true, format: 'svg', filename: 'MolecularMimicryMap_of_SARS-CoV-2', height: 750, width: 1100, scale: 1 }, modeBarButtonsToRemove: [ 'autoScale2d', 'toggleSpikelines', 'hoverCompareCartesian', 'hoverClosestCartesian' ] } // flexible plot width according to the window size  // do not display plotly logo
    let config_MolecularMimicryMap = Object.assign( { toImageButtonOptions: { hoverClosestCartesian: true, format: 'svg', filename: 'MolecularMimicryMap_of_SARS-CoV-2', height: 750, width: 1100, scale: 1 }, modeBarButtonsToRemove: [ 'autoScale2d', 'toggleSpikelines', 'hoverCompareCartesian', 'hoverClosestCartesian' ] }, config ), layout_MolecularMimicryMap = { margin: { l: 60, r: 15, b: 10, t: 0, pad: 4 }, xaxis: { rangeslider: { borderwidth : 1, thickness : 0.07 }, zeroline: false }, yaxis: { fixedrange: true, zeroline: false, tickmode: "array", tickvals: [ 0, 2, 4, 6, 8, 10 ], ticktext: ArrayApply( [ 0, 2, 4, 6, 8, 10 ], String ) }, hovermode: "closest", hoverlabel: { bgcolor: "#ffffff", bordercolor: "#521a87" }, legend: { itemclick: false, itemdoubleclick: false } }; // title: 'Molecular Mimicry Map of SARS-CoV-2', // disable toggling of traces when clickng legends // do hot show y-tickes below 0
    let layout_PredictionMetrics = { margin: { l: 50, r: 65, b: 50, t: 50, pad: 4 } }, layout_tableSequence = { margin: { l: 50, r: 65, b: 5, t: 5, pad: 4 } };
    // for visualizing protein structures
    var object_pdb_query = { }, object_pdb_target = { }, object_data_tableSequence = { };
    var option_initialization_molstar = { customData: { url: object_data.file.base_url + "data/custom_cif/dummy.cif", format: 'cif', binary: false }, landscape: true, bgColor: {r:0,g:0,b:0}, hideControls: true }; // default option for Mol* when not displaying molecules
    var l_selectSections_PDB_target_Protein = [ ], flag_select_PDB_target_Protein = true, flag_focus_PDB_target_Protein = false, l_selectSections_PDB_query_Protein = [ ], flag_select_PDB_query_Protein = true, flag_focus_PDB_query_Protein = false; // flags for interaction with Mol* viewer
    // for highlighting specific entries
    // object for saving layout data
    var object_plot_MolecularMimicryMap = { hovermode: "closest", layout: { } };
    // for loading data from remote location
    // "Record Details" table styles settings
    var style_font_table_record_details = "font-family:Arial", int_n_residues_per_window_table_sequence = 20; // 'int_n_residues_per_window_table_sequence' number of residues per sequence in the table_sequence plot
    var object_plot_queryProteins = { }, trace_queryProteinMetrics = { type: 'parcoords', line: { color: "#aa00ff" }, dimensions: [ ] };
    function DrawqueryProteinMetricsPlot( ) {
        // assume there is only one dataset
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ];
        // prepare data
        object_plot_queryProteins.n_records = dataset.arr_data_acc_query.length;
        object_plot_queryProteins.dictarr = SubsetDictDictArr( dataset.gtex.dictdictarr, "Q2" )
        object_plot_queryProteins.dictarr_log10 = { };
        for ( let col in object_plot_queryProteins.dictarr ) { // log10 transformation of median count values
            object_plot_queryProteins.dictarr_log10[ col + ' (log10)' ] = nj.log( object_plot_queryProteins.dictarr[ col ] ).divide( 2.3025851 ).tolist( )
        }
        object_plot_queryProteins.dictarr = { ... object_plot_queryProteins.dictarr_log10, ... Unpack_array_to_dict_data( dataset.arr_data_acc_query ) }
            // prepare data based on selected options
        let l_option = document.getElementById( "selectmultiple_queryProteinMetrics" ).options, l_col = [ ], l_label = [ ];
        for ( let i = 0; i < l_option.length; i ++ ) {
            let option = l_option[ i ];
            if ( option.selected ) { l_col.push( option.value ); l_label.push( option.text ); } // retrieve column name and label for each selected column
        }
        trace_queryProteinMetrics.dimensions = [ ]; // initialize metrics data
        trace_queryProteinMetrics.line = { color: dataset.l_float_for_colormap_rainbow_acc_query, colorscale : "Rainbow", cmin : 0, cmax : 1, cmid : 0.5, colorscale : [ [ 0, '#ff0000' ], [ 0.33, '#00ff00' ], [ 0.66, '#0000ff' ], [ 1, '#ff0000' ] ] }
        for ( let i = 0; i < l_col.length; i ++ ) {
            let col = l_col[ i ], label = l_label[ i ];
            trace_queryProteinMetrics.dimensions.push( { values: object_plot_queryProteins.dictarr[ col ], label: label } );
        }
        Plotly.newPlot( plotqueryProteinMetrics, [ lodash.cloneDeep( trace_queryProteinMetrics ) ], { margin: { l: 70, r: 65, b: 50, t: 50, pad: 4 } }, config );
        // Add Plotly interactions // Selection event through a plot containing metrics (parallel coordinate plots) (BCellCrossReactivity prediction data)
        object_plot_queryProteins.l_mask = [ ]; // initialize list of masks
        for ( let i = 0; i < trace_queryProteinMetrics.dimensions.length; i ++ ) { object_plot_queryProteins.l_mask.push( ArrayFull( object_plot_queryProteins.n_records, true ) ); } // initialize masks used for retrieving selected entries
        object_plot_BCellCrossReactivity.mask_selected_queryProteinFilter = ArrayFull( object_plot_BCellCrossReactivity.arr_data.length, true );
        object_plot_TCellCrossReactivity.mask_selected_queryProteinFilter = ArrayFull( object_plot_TCellCrossReactivity.arr_data.length, true );
        plotqueryProteinMetrics.on( 'plotly_restyle', function( eventData ) { // update trace_MolecularMimicryMap_BCellCrossReactivity and trace_MolecularMimicryMap_TCellCrossReactivity based on selection in trace_BCellCrossReactivityMetrics
            let str_name_key = Object.keys( eventData[ 0 ] )[ 0 ];
            if ( str_name_key.includes( "constraintrange" ) ) { // when entries are selected or deselected (ignore event where fields are rearranged and no selection or deselection occurred)
                let index_field = parseInt( str_name_key.split( "].constraintrange" )[ 0 ].split( "dimensions[" )[ 1 ] ); // extract the index of field from the name of the key 
                let l_selectedRange = eventData[ 0 ][ str_name_key ];
                if ( l_selectedRange == null ) { // if all range of the current field is selected
                    object_plot_queryProteins.l_mask[ index_field ] = ArrayFull( object_plot_queryProteins.n_records, true ); // reset selection
                } else {
                    let l_mask_for_each_selectedRange = [ ]; // overlap mask for each selected ranges
                    for ( let i = 0; i < l_selectedRange.length; i++ ) { // for each selectedRange
                        let selectedRange = l_selectedRange[ i ].sort( SortFloat );
                        let l_data = trace_queryProteinMetrics.dimensions[ index_field ].values;
                        l_mask_for_each_selectedRange.push( ArrayBoolAND( [ ArrayGreaterThan( l_data, selectedRange[ 0 ] ), ArrayLessThan( l_data, selectedRange[ 1 ] ) ] ) );
                    }
                    object_plot_queryProteins.l_mask[ index_field ] = ArrayBoolOR( l_mask_for_each_selectedRange ); // update mask with the currently selected range
                }
                object_plot_queryProteins.mask_selected = ArrayBoolAND( object_plot_queryProteins.l_mask ); // retrieve a mask for the selected records
                // update masks for Bcell and Tcell cross-reactivity records
                object_plot_BCellCrossReactivity.mask_selected_queryProteinFilter = [ ]
                let l_acc_query = dataset.object_plot_BCellCrossReactivity.dict_data[ "query_accession" ];
                for ( let i = 0; i < l_acc_query.length; i ++ ) {
                    object_plot_BCellCrossReactivity.mask_selected_queryProteinFilter.push( object_plot_queryProteins.mask_selected[ l_acc_query[ i ] ] );
                }
                object_plot_TCellCrossReactivity.mask_selected_queryProteinFilter = [ ]
                for ( let i = 0; i < l_acc_query.length; i ++ ) {
                    object_plot_TCellCrossReactivity.mask_selected_queryProteinFilter.push( object_plot_queryProteins.mask_selected[ l_acc_query[ i ] ] );
                }
                Filter_BCellCrossReactivity( ); // apply the filter
                Filter_TCellCrossReactivity( );
            }
        });
    }
    async function LoadRemoteData_BasedOnSettings( ) { // load dataset based on setting
        let l_name_dataset = object_data.main.l_name_dataset,
            l_dir_file = [ ];
        for ( let index_dataset = 0; index_dataset < l_name_dataset.length; index_dataset ++ ) {
            let name_dataset = l_name_dataset[ index_dataset ]; // name_dataset 
            let dataset = object_data.main.dataset[ name_dataset ], // retrieve dataset
                float_thres_margin = 1.5; // a threshold for skipping writing a file if the number of records for subset is too close to the maximum number
            
            // retrieve file names appropriate for current setting
            dataset.object_plot_BCellCrossReactivity.n_records_from_setting = parseInt( document.getElementById( "input_n_alignments_for_plotting_BCellCrossReactivity" ).value );
            dataset.object_plot_BCellCrossReactivity.window_size = document.getElementById( "select_windowSize_BCellCrossReactivity" ).value;
            dataset.object_plot_BCellCrossReactivity.redundancy_level = document.getElementById( "select_redundancy_level_BCellCrossReactivity" ).value;
            dataset.object_plot_BCellCrossReactivity.n_records_max = object_data.file.dict_bcell_crossreactivity_data_to_n_records[ name_dataset ][ dataset.object_plot_BCellCrossReactivity.redundancy_level ][ dataset.object_plot_BCellCrossReactivity.window_size ];
            dataset.object_plot_BCellCrossReactivity.n_records_of_remote_file = 1000; // default is the smallest n_records
            if ( dataset.object_plot_BCellCrossReactivity.n_records_from_setting * float_thres_margin >= dataset.object_plot_BCellCrossReactivity.n_records_max ) {
                dataset.object_plot_BCellCrossReactivity.n_records_of_remote_file = dataset.object_plot_BCellCrossReactivity.n_records_max;
            } else {
                for ( let i = 1; i < object_data.file.l_n_records_for_each_step.length; i ++ ) {
                    if ( dataset.object_plot_BCellCrossReactivity.n_records_from_setting < object_data.file.l_n_records_for_each_step[ i ] ) { break; }
                    dataset.object_plot_BCellCrossReactivity.n_records_of_remote_file = object_data.file.l_n_records_for_each_step[ i ];
                }
            }
            dataset.object_plot_BCellCrossReactivity.dir_file = dataset.dir_folder + "BCellCrossReactivity." + dataset.object_plot_BCellCrossReactivity.redundancy_level + ".windowSize_" + dataset.object_plot_BCellCrossReactivity.window_size + ".top_" + String( dataset.object_plot_BCellCrossReactivity.n_records_of_remote_file ) + ".tsv.gz.base64.txt";
            l_dir_file.push( dataset.object_plot_BCellCrossReactivity.dir_file );
            if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) { // when mhc_ligand prediction data exists
                dataset.object_plot_TCellCrossReactivity.n_records_from_setting = parseInt( document.getElementById( "input_n_alignments_for_plotting_TCellCrossReactivity" ).value );
                dataset.object_plot_TCellCrossReactivity.redundancy_level = document.getElementById( "select_redundancy_level_TCellCrossReactivity" ).value;
                dataset.object_plot_TCellCrossReactivity.n_records_max = object_data.file.dict_tcell_crossreactivity_data_to_n_records[ name_dataset ][ dataset.object_plot_TCellCrossReactivity.redundancy_level ];
                dataset.object_plot_TCellCrossReactivity.n_records_of_remote_file = 1000; // default is the smallest n_records
                if ( dataset.object_plot_TCellCrossReactivity.n_records_from_setting * float_thres_margin >= dataset.object_plot_TCellCrossReactivity.n_records_max ) {
                    dataset.object_plot_TCellCrossReactivity.n_records_of_remote_file = dataset.object_plot_TCellCrossReactivity.n_records_max;
                } else {
                    for ( let i = 1; i < object_data.file.l_n_records_for_each_step.length; i ++ ) {
                        if ( dataset.object_plot_TCellCrossReactivity.n_records_from_setting < object_data.file.l_n_records_for_each_step[ i ] ) { break; }
                        dataset.object_plot_TCellCrossReactivity.n_records_of_remote_file = object_data.file.l_n_records_for_each_step[ i ];
                    }
                }
                dataset.object_plot_TCellCrossReactivity.dir_file = dataset.dir_folder + "TCellCrossReactivity." + dataset.object_plot_TCellCrossReactivity.redundancy_level + ".top_" + String( dataset.object_plot_TCellCrossReactivity.n_records_of_remote_file ) + ".tsv.gz.base64.txt";
                l_dir_file.push( dataset.object_plot_TCellCrossReactivity.dir_file ); 
            }
            gtag( 'event', 'loading_remote_data', { name_dataset: name_dataset, t_cell_n_records : ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) ? dataset.object_plot_TCellCrossReactivity.n_records_from_setting : 0, b_cell_n_records : dataset.object_plot_BCellCrossReactivity.n_records_from_setting, b_cell_window_size : dataset.object_plot_BCellCrossReactivity.window_size, t_cell_redundancy_level : dataset.object_plot_BCellCrossReactivity.redundancy_level, t_cell_redundancy_level : ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) ? dataset.object_plot_TCellCrossReactivity.redundancy_level : "nan" } ); // [Google Analytics] record which remote data is being downloaded to improve statistics
        }
        return LoadRemoteData( l_dir_file ); // load given list of files from remote locations
    }
    function Open_and_Draw_BCellCrossReactivityPredMetricsPlot( ) {
        str_jquery_container = "#plotly_graph_b_cell_cross_reactivity";
        if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { DrawBCellCrossReactivityPredMetricsPlot( ); // draw Plotly plot synchronously if the container is currently shown
        } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { DrawBCellCrossReactivityPredMetricsPlot( ); $('#plotly_graph_b_cell_cross_reactivity').collapse( 'hide' ); } ); } // draw Plotly plot once the container is shown if the container is currently hidden
    }        
    function DrawBCellCrossReactivityPredMetricsPlot( ) {
        // reset selection
        let l_index_traces_selected = [ ], l_index_traces_not_selected = [ ];
        if ( object_plot_BCellCrossReactivity.flag_bool_mode_is_lines ) { // restyle plot according to the type of BcellCrossReactivity data
            for ( let i = object_plot_BCellCrossReactivity.index_trace_start; i < object_plot_BCellCrossReactivity.index_trace_end; i ++ ) { if ( plotMolecularMimicryMap.data[ i ].visible == false ) { l_index_traces_selected.push( i ); } } // if previously not selected and hidden, show the record
            if ( l_index_traces_selected.length > 0 ) { Plotly.restyle( plotMolecularMimicryMap, { visible: true }, l_index_traces_selected ); } // show all records
        } else {
            Plotly.restyle( plotMolecularMimicryMap, { marker: { opacity: object_plot_BCellCrossReactivity.dict_data[ "opacity" ], size: trace_point_type_MolecularMimicryMap_BCellCrossReactivity.marker.size, color: trace_point_type_MolecularMimicryMap_BCellCrossReactivity.marker.color, line: { width: 0 } }, error_x: { type: 'data', array: object_plot_BCellCrossReactivity.dict_data[ "error_x" ], visible: true, width: 0, thickness: 1 } }, object_plot_BCellCrossReactivity.index_trace_start ) // reset selection of BCellCrossReactivity records on the plot
        }
        // prepare data
        let l_option = document.getElementById( "selectmultiple_BCellCrossReactivityMetrics" ).options, l_col = [ ], l_label = [ ];
        for ( let i = 0; i < l_option.length; i ++ ) {
            let option = l_option[ i ];
            if ( option.selected ) { l_col.push( option.value ); l_label.push( option.text ); } // retrieve column name and label for each selected column
        }
        trace_BCellCrossReactivityMetrics.dimensions = [ ]; // initialize metrics data
        for ( let i = 0; i < l_col.length; i ++ ) {
            let col = l_col[ i ], label = l_label[ i ];
            let l = col in object_plot_BCellCrossReactivity.metrics ? object_plot_BCellCrossReactivity.metrics[ col ] : object_plot_BCellCrossReactivity.dict_data[ col ];
            trace_BCellCrossReactivityMetrics.dimensions.push( { values: l, label: label } );
        }
        trace_BCellCrossReactivityMetrics.line = { color: object_plot_BCellCrossReactivity.dict_data[ 'float_color' ], cmin : 0, cmax : 1, cmid : 0.5, colorscale : [ [ 0, '#ff0000' ], [ 0.33, '#00ff00' ], [ 0.66, '#0000ff' ], [ 1, '#ff0000' ] ] }; // allow similar coloring of lines with the records in the main plots (pink colors are quite different, but other colors are similar)
        Plotly.newPlot( plotBCellCrossReactivityMetrics, [ lodash.cloneDeep( trace_BCellCrossReactivityMetrics ) ], layout_PredictionMetrics, config );
        // Add Plotly interactions // Selection event through a plot containing metrics (parallel coordinate plots) (BCellCrossReactivity prediction data)
        object_plot_BCellCrossReactivity.l_mask = [ ]; // initialize list of masks
        for ( let i = 0; i < trace_BCellCrossReactivityMetrics.dimensions.length; i ++ ) { object_plot_BCellCrossReactivity.l_mask.push( ArrayFull( object_plot_BCellCrossReactivity.arr_data.length, true ) ); } // initialize masks used for retrieving selected entries
        object_plot_BCellCrossReactivity.mask_selected_BCellCrossReactivityFilter = ArrayFull( object_plot_BCellCrossReactivity.arr_data.length, true );
        plotBCellCrossReactivityMetrics.on( 'plotly_restyle', function( eventData ) { // update trace_MolecularMimicryMap_BCellCrossReactivity based on selection in trace_BCellCrossReactivityMetrics
            let str_name_key = Object.keys( eventData[ 0 ] )[ 0 ];
            if ( str_name_key.includes( "constraintrange" ) ) { // when entries are selected or deselected (ignore event where fields are rearranged and no selection or deselection occurred)
                let index_field = parseInt( str_name_key.split( "].constraintrange" )[ 0 ].split( "dimensions[" )[ 1 ] ); // extract the index of field from the name of the key 
                let l_selectedRange = eventData[ 0 ][ str_name_key ];
                if ( l_selectedRange == null ) { // if all range of the current field is selected
                    object_plot_BCellCrossReactivity.l_mask[ index_field ] = ArrayFull( object_plot_BCellCrossReactivity.arr_data.length, true ); // reset selection
                } else {
                    let l_mask_for_each_selectedRange = [ ]; // overlap mask for each selected ranges
                    for ( let i = 0; i < l_selectedRange.length; i++ ) { // for each selectedRange
                        let selectedRange = l_selectedRange[ i ].sort( SortFloat );
                        let l_data = trace_BCellCrossReactivityMetrics.dimensions[ index_field ].values;
                        l_mask_for_each_selectedRange.push( ArrayBoolAND( [ ArrayGreaterThan( l_data, selectedRange[ 0 ] ), ArrayLessThan( l_data, selectedRange[ 1 ] ) ] ) );
                    }
                    object_plot_BCellCrossReactivity.l_mask[ index_field ] = ArrayBoolOR( l_mask_for_each_selectedRange ); // update mask with the currently selected range
                }
                object_plot_BCellCrossReactivity.mask_selected_BCellCrossReactivityFilter = ArrayBoolAND( object_plot_BCellCrossReactivity.l_mask ); // retrieve a mask for the selected records
                Filter_BCellCrossReactivity( ); // apply the filter
            }
        });
    }
    function Open_and_Draw_TCellCrossReactivityPredMetricsPlot( ) {
        str_jquery_container = "#plotly_graph_t_cell_cross_reactivity";
        if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { DrawTCellCrossReactivityPredMetricsPlot( ); // draw Plotly plot synchronously if the container is currently shown
        } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { DrawTCellCrossReactivityPredMetricsPlot( ); $('#plotly_graph_b_cell_cross_reactivity').collapse( 'hide' ); } ); } // draw Plotly plot once the container is shown if the container is currently hidden
    }        
    function DrawTCellCrossReactivityPredMetricsPlot( ) {
        // reset selection
        let update_query = { marker: { opacity: float_opacity_MolecularMimicryMap_TCellCrossReactivity, size: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.marker.size, color: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.marker.color, symbol: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.marker.symbol, line: { width: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.marker.line.width } } }, update_target = { marker: { opacity: float_opacity_MolecularMimicryMap_TCellCrossReactivity, size: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.marker.size, color: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.marker.color, symbol: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.marker.symbol, line: { width: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.marker.line.width } }, error_x: { type: 'data', array: object_plot_TCellCrossReactivity.dict_data[ "error_x" ], visible: true, width: 0, thickness: 1 } };
        Plotly.restyle( plotMolecularMimicryMap, update_query, object_plot_BCellCrossReactivity.index_trace_end ); // T-cell crossreactivity trace is situated next to B-cell cross-reactivity trace
        Plotly.restyle( plotMolecularMimicryMap, update_target, object_plot_BCellCrossReactivity.index_trace_end + 1 );
        // prepare data
        let l_option = document.getElementById( "selectmultiple_TCellCrossReactivityMetrics" ).options, l_col = [ ], l_label = [ ];
        for ( let i = 0; i < l_option.length; i ++ ) {
            let option = l_option[ i ];
            if ( option.selected ) { l_col.push( option.value ); l_label.push( option.text ); } // retrieve column name and label for each selected column
        }
        trace_TCellCrossReactivityMetrics.dimensions = [ ]; // initialize metrics data
        for ( let i = 0; i < l_col.length; i ++ ) {
            let col = l_col[ i ], label = l_label[ i ];
            let l = ( col in object_plot_TCellCrossReactivity.metrics ) ? object_plot_TCellCrossReactivity.metrics[ col ] : object_plot_TCellCrossReactivity.dict_data[ col ];
            trace_TCellCrossReactivityMetrics.dimensions.push( { values: l, label: label } );
        }
        trace_TCellCrossReactivityMetrics.line = { color: object_plot_TCellCrossReactivity.dict_data[ "float_color" ], cmin : 0, cmax : 1, cmid : 0.5, colorscale : [ [ 0, '#ff0000' ], [ 0.33, '#00ff00' ], [ 0.66, '#0000ff' ], [ 1, '#ff0000' ] ] };
        Plotly.newPlot( plotTCellCrossReactivityMetrics, [ lodash.cloneDeep( trace_TCellCrossReactivityMetrics ) ], layout_PredictionMetrics, config ); 
        // Add Plotly interactions // Selection event through a plot containing metrics (parallel coordinate plots) (TCellCrossReactivity prediction data)
        object_plot_TCellCrossReactivity.l_mask = [ ]; // initialize list of masks
        for ( let i = 0; i < trace_TCellCrossReactivityMetrics.dimensions.length; i ++ ) { object_plot_TCellCrossReactivity.l_mask.push( ArrayFull( object_plot_TCellCrossReactivity.arr_data.length, true ) ); } // initialize masks used for retrieving selected entries
        object_plot_TCellCrossReactivity.mask_selected_TCellCrossReactivityFilter = ArrayFull( object_plot_TCellCrossReactivity.arr_data.length, true );
        plotTCellCrossReactivityMetrics.on( 'plotly_restyle', function( eventData ) { // update trace_MolecularMimicryMap_TCellCrossReactivity based on selection in trace_TCellCrossReactivityMetrics
            let str_name_key = Object.keys( eventData[ 0 ] )[ 0 ];
            if ( str_name_key.includes( "constraintrange" ) ) { // when entries are selected or deselected (ignore event where fields are rearranged and no selection or deselection occurred)
                let index_field = parseInt( str_name_key.split( "].constraintrange" )[ 0 ].split( "dimensions[" )[ 1 ] ); // extract the index of field from the name of the key 
                let l_selectedRange = eventData[ 0 ][ str_name_key ];
                if ( l_selectedRange == null ) { // if all range of the current field is selected
                    object_plot_TCellCrossReactivity.l_mask[ index_field ] = ArrayFull( object_plot_TCellCrossReactivity.arr_data.length, true ); // reset selection
                } else {
                    let l_mask_for_each_selectedRange = [ ]; // overlap mask for each selected ranges
                    for ( let i = 0; i < l_selectedRange.length; i++ ) { // for each selectedRange
                        let selectedRange = l_selectedRange[ i ].sort( SortFloat );
                        let l_data = trace_TCellCrossReactivityMetrics.dimensions[ index_field ].values;
                        l_mask_for_each_selectedRange.push( ArrayBoolAND( [ ArrayGreaterThan( l_data, selectedRange[ 0 ] ), ArrayLessThan( l_data, selectedRange[ 1 ] ) ] ) );
                    }
                    object_plot_TCellCrossReactivity.l_mask[ index_field ] = ArrayBoolOR( l_mask_for_each_selectedRange ); // update mask with the currently selected range
                }
                object_plot_TCellCrossReactivity.mask_selected_TCellCrossReactivityFilter = ArrayBoolAND( object_plot_TCellCrossReactivity.l_mask ); // retrieve a mask for the selected records
                Filter_TCellCrossReactivity( ); // apply the filter
            }
        });
    }
    function Filter_BCellCrossReactivity( ) { // filter BCellCrossReactivity records
        // collect all filters
        let l_filter = [ ];
        if ( 'mask_selected_BCellCrossReactivityFilter' in object_plot_BCellCrossReactivity ) { // if metric plot has been drawn, add metric-based filter to the list of filters
            l_filter.push( object_plot_BCellCrossReactivity.mask_selected_BCellCrossReactivityFilter );
        }
        if ( object_data.flag.alignment_to_target & ( 'mask_selected_queryProteinFilter' in object_plot_BCellCrossReactivity ) ) { // if queryProteinMetrics plot has not been drawn and AlignmentTotarget mode is used (multiple protein visualized), use the queryProtein filter
            l_filter.push( object_plot_BCellCrossReactivity.mask_selected_queryProteinFilter );
        }
        if ( 'mask_selected_highlighting' in object_plot_BCellCrossReactivity ) { // if records were highlighted, add the filter for highlighting
            l_filter.push( object_plot_BCellCrossReactivity.mask_selected_highlighting );
        }
        object_plot_BCellCrossReactivity.mask_selected = ( l_filter.length == 0 ) ? ArrayFull( object_plot_BCellCrossReactivity.arr_data.length, true ) : ArrayBoolAND( l_filter ); // apply all available filters. if no filter is available, display all records
        
        object_plot_BCellCrossReactivity.selection = { }; // object for storing data related to selected records
        let mask_not_selected = ArrayBoolNOT( object_plot_BCellCrossReactivity.mask_selected );
        object_plot_BCellCrossReactivity.selection.l_opacity = ArrayBroadCasting( object_plot_BCellCrossReactivity.dict_data[ "opacity" ], mask_not_selected, 0 ); // retrieve modified opacity values of records
        object_plot_BCellCrossReactivity.selection.l_error_x = ArrayBroadCasting( object_plot_BCellCrossReactivity.dict_data[ "error_x" ], mask_not_selected, 0 ); // retrieve modified error_x values of records
        if ( object_plot_BCellCrossReactivity.flag_bool_mode_is_lines ) { // restyle plot according to the type of BcellCrossReactivity data
            l_index_traces_selected = [ ], l_index_traces_not_selected = [ ]; // retrieve trace indices that are newly selected or deselected
            for ( let i = object_plot_BCellCrossReactivity.index_trace_start; i < object_plot_BCellCrossReactivity.index_trace_end; i ++ ) { 
                if ( object_plot_BCellCrossReactivity.mask_selected[ i ] && plotMolecularMimicryMap.data[ i ].visible == false ) { l_index_traces_selected.push( i ); } // if previously not selected but currently selected 
                else if ( ! ( object_plot_BCellCrossReactivity.mask_selected[ i ] ) && plotMolecularMimicryMap.data[ i ].visible == true ) { l_index_traces_not_selected.push( i ); } // if previously selected but currently not selected 
            }
            if ( l_index_traces_selected.length > 0 ) { Plotly.restyle( plotMolecularMimicryMap, { visible: true }, l_index_traces_selected ); } // show selected records
            if ( l_index_traces_not_selected.length > 0 ) { Plotly.restyle( plotMolecularMimicryMap, { visible: false }, l_index_traces_not_selected ); } // hide non-selected records
        } else {
            Plotly.restyle( plotMolecularMimicryMap, { marker: { opacity: object_plot_BCellCrossReactivity.selection.l_opacity, size: trace_point_type_MolecularMimicryMap_BCellCrossReactivity.marker.size, color: trace_point_type_MolecularMimicryMap_BCellCrossReactivity.marker.color, line: { width: 0 } }, error_x: { type: 'data', array: object_plot_BCellCrossReactivity.selection.l_error_x, visible: true, width: 0, thickness: 1 } }, object_plot_BCellCrossReactivity.index_trace_start ) // set opacity of markers not selected in the metric plot 0
        }
    }
    function Filter_TCellCrossReactivity( ) { // filter TCellCrossReactivity records
        if ( ( ! object_data.flag.cross_reactive_mhc_ligand_data_exist ) ) { // exit when mhc_ligand data does not exist
            return -1;
        }
        // collect all filters
        let l_filter = [ ];
        if ( 'mask_selected_TCellCrossReactivityFilter' in object_plot_TCellCrossReactivity ) { // if metric plot has been drawn, add metric-based filter to the list of filters
            l_filter.push( object_plot_TCellCrossReactivity.mask_selected_TCellCrossReactivityFilter );
        }
        if ( object_data.flag.alignment_to_target & ( 'mask_selected_queryProteinFilter' in object_plot_TCellCrossReactivity ) ) { // if queryProteinMetrics plot has not been drawn and AlignmentTotarget mode is used (multiple protein visualized), use the queryProtein filter
            l_filter.push( object_plot_TCellCrossReactivity.mask_selected_queryProteinFilter );
        }
        if ( 'mask_selected_highlighting' in object_plot_TCellCrossReactivity ) { // if records were highlighted, add the filter for highlighting
            l_filter.push( object_plot_TCellCrossReactivity.mask_selected_highlighting );
        }
        object_plot_TCellCrossReactivity.mask_selected = ( l_filter.length == 0 ) ? ArrayFull( object_plot_TCellCrossReactivity.arr_data.length, true ) : ArrayBoolAND( l_filter ); // apply all available filters. if no filter is available, display all records
        
        object_plot_TCellCrossReactivity.selection = { l_opacity: [ ] };
        for ( let i = 0; i < object_plot_TCellCrossReactivity.mask_selected.length; i ++ ) { object_plot_TCellCrossReactivity.selection.l_opacity.push( object_plot_TCellCrossReactivity.mask_selected[ i ] ? float_opacity_MolecularMimicryMap_TCellCrossReactivity : 0 ); } // retrieve modified opacity values of records
        object_plot_TCellCrossReactivity.selection.l_error_x = ArrayBroadCasting( object_plot_TCellCrossReactivity.dict_data[ "error_x" ], ArrayBoolNOT( object_plot_TCellCrossReactivity.mask_selected ), 0 ); // retrieve modified error_x values of records
        update_query = { marker: { opacity: object_plot_TCellCrossReactivity.selection.l_opacity, size: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.marker.size, color: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.marker.color, symbol: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.marker.symbol, line: { width: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.marker.line.width } } }, update_target = { marker: { opacity: object_plot_TCellCrossReactivity.selection.l_opacity, size: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.marker.size, color: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.marker.color, symbol: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.marker.symbol, line: { width: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.marker.line.width } }, error_x: { type: 'data', array: object_plot_TCellCrossReactivity.selection.l_error_x, visible: true, width: 0, thickness: 1 } };
        Plotly.restyle( plotMolecularMimicryMap, update_query, object_plot_BCellCrossReactivity.index_trace_end ); // T-cell crossreactivity trace is situated next to B-cell cross-reactivity trace
        Plotly.restyle( plotMolecularMimicryMap, update_target, object_plot_BCellCrossReactivity.index_trace_end + 1 );
    }
    function UpdateBCellCrossReactivityPredMetricsPlot( ) {
        if( $( "#plotly_graph_b_cell_cross_reactivity" ).hasClass( "show" ) ) {
            DrawBCellCrossReactivityPredMetricsPlot( );
            object_data.flag.bcellmetrics_plot_is_drawn = true;
        } else {
            object_data.flag.bcellmetrics_plot_is_drawn = false;
        }
    }
    function UpdateTCellCrossReactivityPredMetricsPlot( ) {
        if( $( "#plotly_graph_t_cell_cross_reactivity" ).hasClass( "show" ) ) {
            DrawTCellCrossReactivityPredMetricsPlot( );
            object_data.flag.tcellmetrics_plot_is_drawn = true;
        } else {
            object_data.flag.tcellmetrics_plot_is_drawn = false;
        }
    }
    function UpdatequeryProteinMetricsPlot( ) {
        if( $( "#plotly_graph_query_protein" ).hasClass( "show" ) ) {
            DrawqueryProteinMetricsPlot( );
            object_data.flag.queryproteinmetrics_plot_is_drawn = true;
        } else {
            object_data.flag.queryproteinmetrics_plot_is_drawn = false;
        }
    }
    function Record_Details_Table( bool_create_table_div ) { // function to create and remove "record datails" table
        if ( ( ! bool_create_table_div ) && document.getElementById( "table_record_details" ) != null ) { // remove div for "record datails" table
            document.getElementById( "table_record_details" ).remove( ); // remove loading screen once plot is drawn
            document.getElementById( "container_graph_molecular_mimicry_map" ).removeAttribute( "style" );
            window.dispatchEvent( new Event( 'resize' ) ); // trigger resize events to allow Plotly plot to resize its plot
        } else if ( document.getElementById( "table_record_details" ) == null ) { // create div for "record datails" table
            $("#container_d3_table_metrics").append( [
                '<div id="table_record_details">',
                    '<div class="navbar navbar-dark bg-custom-navbar">',
                        '<a class="navbar-brand my-0 h6" id="title_d3_table_metrics">Record Details</a>',
                        '<button type="button" class="close" aria-label="Close container_d3_table_metrics" onclick="Record_Details_Table( false )"><span aria-hidden="true">&times;</span></button>',
                    '</div>',
                    '<div id="d3_table_metrics"></div>',
                    '<div id="footnote_d3_table_metrics" class="text-muted"></div>',
                '</div>' ].join( "" ) ); // display an SVG file during loading 
            document.getElementById( "container_graph_molecular_mimicry_map" ).setAttribute( "style", "display: grid;grid-template-columns: 1fr minmax(150px, 33%);" ); // add css to allow a grid representation of two divisions.
            window.dispatchEvent( new Event( 'resize' ) ); // trigger resize events to allow Plotly plot to resize its plot
        }
    }
    function DrawD3Table_for_Record_Details( arr_data_clicked ) { // draw d3 table for the given 'arr_data_clicked' record
        Record_Details_Table( true ); // make a div. for table
        // draw 'd3_table_metrics'
        d3.select( "#d3_table_metrics" ).select( "div" ).remove( ); // remove previously drawn table

        let table = d3.select( "#d3_table_metrics" ).append( "div" ).attr( "style", "overflow-x:auto;" ).append( "table" ), thead = table.append( "thead" ), tbody = table.append( "tbody" ).attr( "style", "overflow-y:auto;" ); // write a responsive table
        thead.append( "th" ).text( "Data Name" );
        thead.append( "th" ).text( "Value" );
        let tr = tbody.selectAll( "tr" ).data( arr_data_clicked ).enter( ).append( "tr" ).classed( "table_even", function( d, i ) { return i % 2 == 1; } );
        tr.each( function( d ) {
            var self = d3.select(this);
            self.append("td").attr( "class", "table_left" ).html(d["Data Name"]);
            if ( d.URL != null ) { // if there is available URL link, add the link to the cell
                self.append("td").append("a").attr( "class", "table_left" ).attr("href", d.URL).attr( "target", "_blank" ).attr( "rel", "noopener noreferrer" ).text(d.Value).attr( "style", d.style ); // open the link in a new tab  // security measure to prevent phishing 
            } else { self.append("td").append("a").attr( "class", "table_left" ).text(d.Value).attr( "style", d.style ); }
        });
    }
    async function DrawMolecularMimicryMap( ) {
        return new Promise ( async function( resolve, reject ) {
        Loading_Screen( true );
        let l = [ ], n_digits = 2,
            l_name_dataset = object_data.main.l_name_dataset,
            dict_l = { BCellCrossReactivity_dict_data: [ ], TCellCrossReactivity_dict_data: [ ], BCellCrossReactivity_arr_data: [ ], TCellCrossReactivity_arr_data: [ ] }; // a dictionary containing list of dictionary-arrays (each list containing dictionary-arrays of datasets in l_name_dataset.
        for ( let index_dataset = 0; index_dataset < l_name_dataset.length; index_dataset ++ ) {
            let name_dataset = l_name_dataset[ index_dataset ], // retrieve name_dataset 
                dataset = object_data.main.dataset[ name_dataset ];
            await LoadRemoteData_BasedOnSettings( name_dataset ); // download necessary data based on settings
            console.log( `[DrawMolecularMimicryMap] preprocessing of ${name_dataset} started with ${( object_data.flag.alignment_to_target )? "AlignmentTotarget" : "AlignmentToquery"} mode.` );
            console.log( "[DrawMolecularMimicryMap] Drawing graphs using following files:", dataset.object_plot_BCellCrossReactivity.dir_file, dataset.object_plot_TCellCrossReactivity.dir_file, "for dataset " + name_dataset );
            console.log( "[DrawMolecularMimicryMap] setting hovermode to", object_plot_MolecularMimicryMap.hovermode );

            // preprocess B cell cross reactivity prediction data 
            dataset.arr_data_BCellCrossReactivity = object_data.file.dict_dir_file_to_parsed_data[ dataset.object_plot_BCellCrossReactivity.dir_file ];
            dataset.object_plot_BCellCrossReactivity.n_records = Math.min( dataset.arr_data_BCellCrossReactivity.length, dataset.object_plot_BCellCrossReactivity.n_records_from_setting ); // retrieve the number of BCellCrossReactivity records to plot
            dataset.arr_data_BCellCrossReactivity = dataset.arr_data_BCellCrossReactivity.slice( 0, dataset.object_plot_BCellCrossReactivity.n_records ); // retrieve "dataset.object_plot_BCellCrossReactivity.n_records" number of records
            dict_l.BCellCrossReactivity_arr_data.push( dataset.arr_data_BCellCrossReactivity ); // add array to the list 
            dataset.object_plot_BCellCrossReactivity.dict_data = Unpack_array_to_dict_data( dataset.arr_data_BCellCrossReactivity ); // unpack data to dict_data format
            if ( object_data.flag.alignment_to_target ) { // when reference target proteins are used for visualization
                dataset.object_plot_BCellCrossReactivity.dict_data[ "name_protein_target" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "representative_accession" ], function( acc_rep ) { return dataset.arr_data_acc_target_representative[ acc_rep ].name; } ); 
            } 
            
            dataset.object_plot_BCellCrossReactivity.dict_data[ "e_value" ] =  dataset.object_plot_BCellCrossReactivity.dict_data[ "e_value" ].map( val => { return ( ( val == 0 ) ? 1e-230 : val ); } ); // replace 0 value with lowest e-value possible
            dataset.object_plot_BCellCrossReactivity.dict_data[ "name_dataset" ] =  ArrayFull( dataset.arr_data_BCellCrossReactivity.length, name_dataset ); // put name_dataset
            dataset.object_plot_BCellCrossReactivity.dict_data[ "name_protein_query" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "query_accession" ], function( acc ) { return ( object_data.flag.query_label_represents_target ) ? `${dataset.arr_data_acc_query[ acc ].Species} (${dataset.arr_data_acc_query[ acc ].Genus})` : dataset.arr_data_acc_query[ acc ].name; } ); // name_protein_query is the target species of target proteins labeled as 'query' proteins in this application
            dataset.object_plot_BCellCrossReactivity.dict_data[ "target_accession" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "target_accession" ], function( acc ) { return dataset.arr_data_acc_target[ acc ].value; } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "query_accession" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "query_accession" ], function( acc ) { return dataset.arr_data_acc_query[ acc ].value; } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "humen_gene_symbol" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "query_accession" ], function( i ) { return dataset.acc_query.dict_data_all[ object_data.setting.name_acc_query ][ i ].toUpperCase( ); } ); // retrieve gene_symbol of query proteins // used for indexing (use upper case to make search case-insensitive)
            dataset.object_plot_BCellCrossReactivity.dict_data[ "name_structure_query" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "structure_id_query" ], function( acc ) { if( acc == - 1 ) { return "not available" } else { return dataset.arr_data_acc_pdb[ acc ].value; } } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "name_structure_target" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "structure_id_target" ], function( acc ) { if( acc == - 1 ) { return "not available" } else { return dataset.arr_data_acc_pdb[ acc ].value; } } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "string_correl_coeffi_acc" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "correl_coeffi_acc" ], function( num ) { if( num == null ) { return "not available" } else { return String( num.toFixed( n_digits ) ); } } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "string_correl_coeffi_phi" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "correl_coeffi_phi" ], function( num ) { if( num == null ) { return "not available" } else { return String( num.toFixed( n_digits ) ); } } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "string_correl_coeffi_psi" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "correl_coeffi_psi" ], function( num ) { if( num == null ) { return "not available" } else { return String( num.toFixed( n_digits ) ); } } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "string_correl_p_value_acc" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "correl_p_value_acc" ], function( num ) { if( num == null ) { return "not available" } else { return num.toExponential( n_digits ); } } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "string_correl_p_value_phi" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "correl_p_value_phi" ], function( num ) { if( num == null ) { return "not available" } else { return num.toExponential( n_digits ); } } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "string_correl_p_value_psi" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "correl_p_value_psi" ], function( num ) { if( num == null ) { return "not available" } else { return num.toExponential( n_digits ); } } );
            
            // retrieve YAxis setting
            selOpt = Select_Get_Selected_Option_Using_ID( "select_YAxis_BCellCrossReactivity" );
            dataset.object_plot_BCellCrossReactivity.y_axis = { label : selOpt.text, name_value : selOpt.value };
            let l_y = dataset.object_plot_BCellCrossReactivity.dict_data[ dataset.object_plot_BCellCrossReactivity.y_axis.name_value ]; 
            dataset.object_plot_BCellCrossReactivity.dict_data[ "y" ] = l_y; // retrieve YAxis setting
            dataset.object_plot_BCellCrossReactivity.float_max_of_l_y = ArrayFindMinMax( l_y )[ 1 ]; // retrieve max value of Y-axis
            // retrieve l_size values
            selOpt = Select_Get_Selected_Option_Using_ID( "select_Size_BCellCrossReactivity" );
            dataset.object_plot_BCellCrossReactivity.size = { label : selOpt.text, name_value : selOpt.value };
            let l_size = dataset.object_plot_BCellCrossReactivity.dict_data[ dataset.object_plot_BCellCrossReactivity.size.name_value ];
            dataset.object_plot_BCellCrossReactivity.dict_data[ "size" ] = l_size; // retrieve l_size values
            // retrieve l_opacity values
            selOpt = Select_Get_Selected_Option_Using_ID( "select_Opacity_BCellCrossReactivity" );
            dataset.object_plot_BCellCrossReactivity.opacity = { label : selOpt.text, name_value : selOpt.value };
            let l_opacity = dataset.object_plot_BCellCrossReactivity.dict_data[ dataset.object_plot_BCellCrossReactivity.opacity.name_value ];
            dataset.object_plot_BCellCrossReactivity.dict_data[ "opacity" ] = l_opacity; // retrieve l_opacity values
            
            // retrieve x coordinates of records
            let arr_start = [ ], arr_end = [ ];
            if ( object_data.flag.alignment_to_target ) { // when reference target proteins are used for visualization
                arr_start = nj.array( dataset.object_plot_BCellCrossReactivity.dict_data[ 'target_representative_accumulated_start__for_web_application' ] );
                arr_end = nj.array( dataset.object_plot_BCellCrossReactivity.dict_data[ 'target_representative_accumulated_end__for_web_application' ] );
            } else {
                arr_start = nj.array( dataset.object_plot_BCellCrossReactivity.dict_data[ 'query_start' ] );
                arr_end = nj.array( dataset.object_plot_BCellCrossReactivity.dict_data[ 'query_end' ] );
            }
            // retrieve x coordinates of records
            dataset.object_plot_BCellCrossReactivity.dict_data[ "start" ] = arr_start.tolist( );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "end" ] = arr_end.tolist( );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "x" ] = arr_start.add( arr_end ).divide( 2 ).tolist( );
            
            let l_colors = [ ], l_float_colors = [ ], l_target_species = [ ], l_acc_query = dataset.object_plot_BCellCrossReactivity.dict_data[ 'query_accession' ], l_acc_target = dataset.object_plot_BCellCrossReactivity.dict_data[ "target_accession" ]; // retrieve colors for each alignment
            
            if ( object_data.flag.alignment_to_target ) { 
                for ( let i = 0; i < l_acc_query.length; i ++ ) { 
                    let color = "", 
                        float_color = 0;
                    // color with query_gene_symbol or target_species (cross-reactivity between target species)
                    if ( object_data.flag.query_label_represents_target ) {
                        let target_species = dataset.dictarr_data_acc_query.Species[ l_acc_query[ i ] ];
                        float_color = dataset.dict_target_species_to_float_rainbow_color[ target_species ];
                        color = dataset.dict_target_species_to_rainbow_color[ target_species ];
                        l_target_species.push( target_species ) // use target_species of 'query' dataset
                    } else {
                        float_color = dataset.l_float_for_colormap_rainbow_acc_query[ l_acc_query[ i ] ];
                        color = dataset.l_colormap_rainbow_acc_query[ l_acc_query[ i ] ];
                    }
                    l_colors.push( color );
                    l_float_colors.push( float_color );
                }
                if ( ( ! object_data.flag.query_label_represents_target ) ) {
                    l_target_species = ArrayFull( l_acc_query.length, "Severe acute respiratory syndrome coronatarget 2" ); // default target is SARS-CoV-2 // target_species of 'target' dataset
                }
            } else { 
                if ( ! ( "Species" in dataset.dictarr_data_acc_target ) ) { // if Species column does not exist, SARS-CoV-2 is the default target species 
                    l_target_species = ArrayFull( l_acc_target.length, "Severe acute respiratory syndrome coronatarget 2" ); // default target is SARS-CoV-2
                    l_colors = ArrayFull( l_acc_target.length, dataset.dict_target_species_to_rainbow_color[ "Severe acute respiratory syndrome coronatarget 2" ] );
                    l_float_colors = ArrayFull( l_acc_target.length, dataset.dict_target_species_to_float_rainbow_color[ "Severe acute respiratory syndrome coronatarget 2" ] );
                } else {   
                    for ( let i = 0; i < l_acc_target.length; i ++ ) { 
                        let int_acc_target = l_acc_target[ i ];
                        let str_target_species = dataset.dictarr_data_acc_target.Species[ l_acc_target[ i ] ];
                        l_target_species.push( str_target_species );
                        l_colors.push( dataset.dict_target_species_to_rainbow_color[ str_target_species ] );
                        l_float_colors.push( dataset.dict_target_species_to_float_rainbow_color[ str_target_species ] );
                    }
                }
            }
            // retrieve target species
            dataset.object_plot_BCellCrossReactivity.dict_data[ "target_species" ] = l_target_species; // target_species of query dataset
            // retrieve colors for each alignment
            dataset.object_plot_BCellCrossReactivity.dict_data[ "color" ] = l_colors;
            dataset.object_plot_BCellCrossReactivity.dict_data[ "float_color" ] = l_float_colors;
            dataset.object_plot_BCellCrossReactivity.dict_data[ "error_x" ] = arr_end.subtract( arr_start ).divide( 2 ).tolist( ); // retrieve error_x data (representing alignment length)    
            dataset.object_plot_BCellCrossReactivity.dict_data[ "minus_log10_e_value" ] = nj.array( dataset.object_plot_BCellCrossReactivity.dict_data[ 'e_value' ] ).log( ).divide( 2.302585 ).multiply( -1 ).tolist( ); // -log10 of e-values
            
            dict_l.BCellCrossReactivity_dict_data.push( dataset.object_plot_BCellCrossReactivity.dict_data ); // add dictionary-array to the list 

            // index data with acc_query (integer index)
            dataset.object_plot_BCellCrossReactivity.dictionary_int_index_acc_query_to_l_int_index = Index_list_with_dictionary( dataset.object_plot_BCellCrossReactivity.dict_data[ 'query_accession' ] ); // build indices of BCellCrossReactivity data with acc_query (integer index)

            // preprocess T cell cross reactivity prediction data when mhc_ligand prediction data exists
            if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) { // when mhc_ligand prediction data exists
                dataset.arr_data_TCellCrossReactivity = object_data.file.dict_dir_file_to_parsed_data[ dataset.object_plot_TCellCrossReactivity.dir_file ];
                dataset.object_plot_TCellCrossReactivity.n_records = Math.min( dataset.arr_data_TCellCrossReactivity.length, dataset.object_plot_TCellCrossReactivity.n_records_from_setting ); // retrieve the number of BCellCrossReactivity records to plot
                dataset.arr_data_TCellCrossReactivity = dataset.arr_data_TCellCrossReactivity.slice( 0, dataset.object_plot_TCellCrossReactivity.n_records ); // retrieve "dataset.object_plot_TCellCrossReactivity.n_records" number of records from 'dataset.arr_data_TCellCrossReactivity'
                dict_l.TCellCrossReactivity_arr_data.push( dataset.arr_data_TCellCrossReactivity ); // add array to the list 
                // retrieve protein and mhc_allele related data for hover info. 
                dataset.object_plot_TCellCrossReactivity.dict_data = Unpack_array_to_dict_data( dataset.arr_data_TCellCrossReactivity ); // unpack data to dict_data format
                dataset.object_plot_TCellCrossReactivity.dict_data[ "name_dataset" ] =  ArrayFull( dataset.arr_data_TCellCrossReactivity.length, name_dataset ); // put name_dataset
                if ( object_data.flag.alignment_to_target ) { // when reference target proteins are used for visualization
                    dataset.object_plot_TCellCrossReactivity.dict_data[ "name_protein_target" ] = ArrayApply( dataset.object_plot_TCellCrossReactivity.dict_data[ "representative_accession" ], function( acc_rep ) { return dataset.arr_data_acc_target_representative[ acc_rep ].name; } ); 
                }
                dataset.object_plot_TCellCrossReactivity.dict_data[ "name_protein_query" ] = ArrayApply( dataset.object_plot_TCellCrossReactivity.dict_data[ "query_accession" ], function( acc ) { return dataset.arr_data_acc_query[ acc ].name; } );
                dataset.object_plot_TCellCrossReactivity.dict_data[ "target_accession" ] = ArrayApply( dataset.object_plot_TCellCrossReactivity.dict_data[ "target_accession" ], function( acc ) { return dataset.arr_data_acc_target[ acc ].value; } );
                dataset.object_plot_TCellCrossReactivity.dict_data[ "query_accession" ] = ArrayApply( dataset.object_plot_TCellCrossReactivity.dict_data[ "query_accession" ], function( acc ) { return dataset.arr_data_acc_query[ acc ].value; } );
                dataset.object_plot_TCellCrossReactivity.dict_data[ "humen_gene_symbol" ] = ArrayApply( dataset.object_plot_TCellCrossReactivity.dict_data[ "query_accession" ], function( i ) { return dataset.acc_query.dict_data_all[ object_data.setting.name_acc_query ][ i ].toUpperCase( ); } ); // retrieve gene_symbol of query proteins // used for indexing (use upper case to make search case-insensitive)
                dataset.object_plot_TCellCrossReactivity.dict_data[ "name_mhc_allele" ] = ArrayApply( dataset.object_plot_TCellCrossReactivity.dict_data[ "mhc_allele" ], function( acc ) { return dataset.arr_data_mhc_allele[ acc ].value; } );
                dataset.object_plot_TCellCrossReactivity.dict_data[ "name_disease" ] = ArrayApply( dataset.object_plot_TCellCrossReactivity.dict_data[ "mhc_allele" ], function( acc ) { return dataset.arr_data_mhc_allele[ acc ].disease_name; } );
                dataset.object_plot_TCellCrossReactivity.dict_data[ "pubmed_id" ] = ArrayApply( dataset.object_plot_TCellCrossReactivity.dict_data[ "mhc_allele" ], function( acc ) { return dataset.arr_data_mhc_allele[ acc ].pubmed_id; } );

                // retrieve x coordinates of records
                if ( object_data.flag.alignment_to_target ) { // when reference target proteins are used for visualization
                    arr_start = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'target_representative_accumulated_start__for_web_application' ] );
                    arr_end = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'target_representative_accumulated_end__for_web_application' ] );
                } else {
                    arr_start = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'query_start' ] );
                    arr_end = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'query_end' ] );
                }
                // retrieve x coordinates of records
                dataset.object_plot_TCellCrossReactivity.dict_data[ "start" ] = arr_start.tolist( );
                dataset.object_plot_TCellCrossReactivity.dict_data[ "end" ] = arr_end.tolist( );

                let arr_score = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'score_blosum' ] ), arr_window_size = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'window_size' ] );
                l_avg_score = arr_score.divide( arr_window_size ).tolist( ); // retrieve sum of blosum62 scores per residue
                dataset.object_plot_TCellCrossReactivity.dict_data[ "avg_score" ] = l_avg_score; // retrieve sum of blosum62 scores per residue
                l_colors = [ ];
                l_float_colors = [ ];

                l_acc_query = dataset.object_plot_TCellCrossReactivity.dict_data[ 'query_accession' ];
                l_acc_target = dataset.object_plot_TCellCrossReactivity.dict_data[ "target_accession" ]; // retrieve colors for each alignment
                l_target_species = [ ]; // initialize l_target_species

                if ( object_data.flag.alignment_to_target ) { // when reference target proteins are used for visualization
                    for ( let i = 0; i < l_acc_query.length; i ++ ) { 
                        l_colors.push( dataset.l_colormap_rainbow_acc_query[ l_acc_query[ i ] ] );
                        l_float_colors.push( dataset.l_float_for_colormap_rainbow_acc_query[ l_acc_query[ i ] ] );
                    }
                    l_target_species = ArrayFull( l_acc_query.length, "Severe acute respiratory syndrome coronatarget 2" ); // default target is SARS-CoV-2
                } else {
                    if ( ! ( "Species" in dataset.dictarr_data_acc_target ) ) { // if Species column does not exist, SARS-CoV-2 is the default target species 
                        l_target_species = ArrayFull( l_acc_target.length, "Severe acute respiratory syndrome coronatarget 2" ); // default target is SARS-CoV-2
                        l_colors = ArrayFull( l_acc_target.length, dataset.dict_target_species_to_rainbow_color[ "Severe acute respiratory syndrome coronatarget 2" ] );
                        l_float_colors = ArrayFull( l_acc_target.length, dataset.dict_target_species_to_float_rainbow_color[ "Severe acute respiratory syndrome coronatarget 2" ] );
                    } else {   
                        for ( let i = 0; i < l_acc_target.length; i ++ ) { 
                            let int_acc_target = l_acc_target[ i ];
                            let str_target_species = dataset.dictarr_data_acc_target.Species[ l_acc_target[ i ] ];
                            l_target_species.push( str_target_species );
                            l_colors.push( dataset.dict_target_species_to_rainbow_color[ str_target_species ] );
                            l_float_colors.push( dataset.dict_target_species_to_float_rainbow_color[ str_target_species ] );
                        }
                    }
                }
                // retrieve target species
                dataset.object_plot_TCellCrossReactivity.dict_data[ "target_species" ] = l_target_species;
                // retrieve colors for each alignment
                dataset.object_plot_TCellCrossReactivity.dict_data[ "color" ] = l_colors;
                dataset.object_plot_TCellCrossReactivity.dict_data[ "float_color" ] = l_float_colors;

                let l_x = arr_start.add( arr_end ).divide( 2 ).tolist( ); // calculate the coordinate of the middle of each alignment;
                dataset.object_plot_TCellCrossReactivity.dict_data[ "x" ] = l_x; // calculate the coordinate of the middle of each alignment;
                let arr_score_geometric_mean_query = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'score_geometric_mean_query' ] ), arr_score_geometric_mean_target = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'score_geometric_mean_target' ] );  

                // retrieve l_y (YAxis values) values
                selOpt = Select_Get_Selected_Option_Using_ID( "select_YAxis_TCellCrossReactivity" );
                dataset.object_plot_TCellCrossReactivity.y_axis = { label : selOpt.text, name_value : selOpt.value };

                switch ( dataset.object_plot_TCellCrossReactivity.y_axis.name_value ) {
                    case "score_blosum":
                    l_y = dataset.object_plot_TCellCrossReactivity.dict_data[ 'score_blosum' ]; 
                    break;    
                    case "average_score_blosum":
                    l_y = l_avg_score; 
                    break;
                    case "score_geometric_mean":
                    l_y = nj.ones( l_avg_score.length ).multiply( 1.5 ).divide( nj.sqrt( arr_score_geometric_mean_query.multiply( arr_score_geometric_mean_target ) ).log( ).divide( 2.302585 ) ).tolist( );
                    break;
                    case "duplicate_counts":
                    l_y = dataset.object_plot_TCellCrossReactivity.dict_data[ dataset.object_plot_TCellCrossReactivity.y_axis.name_value ];
                    break;
                }
                dataset.object_plot_TCellCrossReactivity.dict_data[ "y" ] = l_y; // retrieve l_y (YAxis values) values
                dataset.object_plot_TCellCrossReactivity.float_max_of_l_y = ArrayFindMinMax( l_y )[ 1 ]; // retrieve max value of Y-axis

                dataset.object_plot_TCellCrossReactivity.dict_data[ "error_x" ] = arr_end.subtract( arr_start ).divide( 2 ).tolist( ); // retrieve error_x data (representing alignment length)
                dataset.object_plot_TCellCrossReactivity.dict_data[ "opacity" ] = ArrayFull( dataset.object_plot_TCellCrossReactivity.n_records, float_opacity_MolecularMimicryMap_TCellCrossReactivity ); // set opacity

                let arr_score_geometric_mean_query_log10 = arr_score_geometric_mean_query.log( ).divide( 2.302585 ), // calculate log10 of predicted binding values (IC50)
                    arr_score_geometric_mean_target_log10 = arr_score_geometric_mean_target.log( ).divide( 2.302585 ), // calculate log10 of predicted binding values (IC50)
                    arr_scale = nj.ones( dataset.object_plot_TCellCrossReactivity.n_records ).multiply( 20 ); // for scaling marker size

                dataset.object_plot_TCellCrossReactivity.dict_data[ "size_query" ] = ArrayCap( arr_scale.divide( arr_score_geometric_mean_query_log10 ).tolist( ), 30 ); // set size of markers for query peptides
                dataset.object_plot_TCellCrossReactivity.dict_data[ "size_target" ] = ArrayCap( arr_scale.divide( arr_score_geometric_mean_target_log10 ).tolist( ), 30 ); // set size of markers for target peptides
                dataset.object_plot_TCellCrossReactivity.dict_data[ "score_geometric_mean_query_log10" ] = arr_score_geometric_mean_query_log10.tolist( ); // retrieve list of log10 values of predicted IC50 values
                dataset.object_plot_TCellCrossReactivity.dict_data[ "score_geometric_mean_target_log10" ] = arr_score_geometric_mean_target_log10.tolist( ); // retrieve list of log10 values of predicted IC50 values
                dataset.object_plot_TCellCrossReactivity.dict_data[ "minus_log10_e_value" ] = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'e_value' ] ).log( ).divide( 2.302585 ).multiply( -1 ).tolist( ); // -log10 of e-values

                dict_l.TCellCrossReactivity_dict_data.push( dataset.object_plot_TCellCrossReactivity.dict_data ); // add dictionary-array to the list 
                // index data with acc_query (integer index)
                dataset.object_plot_TCellCrossReactivity.dictionary_int_index_acc_query_to_l_int_index = Index_list_with_dictionary( dataset.object_plot_TCellCrossReactivity.dict_data[ 'query_accession' ] ); // build indices of TCellCrossReactivity data with acc_query (integer index)
            }
        }
        console.log( "[DrawMolecularMimicryMap] proprocessing of data for each dataset is completed" )
            
        // initialize objects 
        object_plot_BCellCrossReactivity = { }
        object_plot_TCellCrossReactivity = { }
        // combine records of all datasets in l_name_dataset
        object_plot_BCellCrossReactivity.dict_data_all = DictArrayCombine( ... dict_l.BCellCrossReactivity_dict_data );
        object_plot_TCellCrossReactivity.dict_data_all = DictArrayCombine( ... dict_l.TCellCrossReactivity_dict_data );
        object_plot_BCellCrossReactivity.arr_data_all = ArrayCombine( ... dict_l.BCellCrossReactivity_arr_data );
        object_plot_TCellCrossReactivity.arr_data_all = ArrayCombine( ... dict_l.TCellCrossReactivity_arr_data );
        
        // index data with query_gene_symbol
        object_plot_BCellCrossReactivity.dictionary_query_gene_symbol_upper_case_to_l_index = Index_list_with_dictionary( object_plot_BCellCrossReactivity.dict_data_all[ "humen_gene_symbol" ] );
        if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) { // when mhc_ligand prediction data exists
            object_plot_TCellCrossReactivity.dictionary_query_gene_symbol_upper_case_to_l_index = Index_list_with_dictionary( object_plot_TCellCrossReactivity.dict_data_all[ "humen_gene_symbol" ] );
        }
            
        console.log( "[DrawMolecularMimicryMap] records of all datasets were combined and indexed with query_gene_symbol" )
        
        // Draw Plots according to Alignment modes
        object_plot_MolecularMimicryMap.query_gene_symbol_of_interest = null; // initialize 'query_gene_symbol_of_interest'
        if ( object_data.flag.alignment_to_target ) {
            await DrawMolecularMimicryMap_for_a_query_gene( ); // draw plot for all available query genes
        } else {
            let query_gene_symbol_upper_case = "PARP14"; // draw PARP14 by default
            if ( ! ( "destroy" in tagify_searchbox_main ) ) { // if tagify has not yet been attached to the search box
                searchbox_main.value = ( searchbox_main.value.length == 0 ) ? query_gene_symbol_upper_case : searchbox_main.value + ',' + query_gene_symbol_upper_case ; // Add tag event will be triggered
            } else  if ( ( "destroy" in tagify_searchbox_main ) & ( tagify_searchbox_main.isTagDuplicate( query_gene_symbol_upper_case ) == 0 ) ) { // if tagify has been attached and the gene has not been added as a tag, add gene as tag (will automatically trigger drawing plots for the gene)
                tagify_searchbox_main.addTags( query_gene_symbol_upper_case );
            } else { // manually trigger drawing plots in other cases
                await DrawMolecularMimicryMap_for_a_query_gene( query_gene_symbol_upper_case ); // draw plot for a query gene
            }
        }
        console.log( "[DrawMolecularMimicryMap] plots were drawn" )
        Initialize_SearchBox_Main( ); // initialize main search box
        console.log( "[DrawMolecularMimicryMap] searchbox initialized" )
        resolve( "[DrawMolecularMimicryMap] resolved" );
    });
    }
    async function DrawMolecularMimicryMap_for_a_query_gene( query_gene_symbol = '' ) { 
        return new Promise ( async function( resolve, reject ) {
        console.log( `[DrawMolecularMimicryMap_for_a_query_gene] Plotting started with query_gene_symbol = '${query_gene_symbol}'` );
        // draw plots using object_plot_BCellCrossReactivity.dict_data_all, object_plot_BCellCrossReactivity.arr_data_all, object_plot_TCellCrossReactivity.dict_data_all, object_plot_TCellCrossReactivity.arr_data_all
        let l_name_dataset = object_data.main.l_name_dataset;
        
        // initialize variable related to ploting
        object_data.main.highlight = { str_entry: "" }; // no entry is currently being highlighted
        
        // retrieve dict_data and arr_data
        if ( object_plot_MolecularMimicryMap.query_gene_symbol_of_interest == query_gene_symbol.toUpperCase( ) ) { // if the the query_gene is already being displayed, ignore the function call and exit.
            return;
        } else {
            object_plot_MolecularMimicryMap.query_gene_symbol_of_interest = query_gene_symbol.toUpperCase( ); // update gene of interest
        }
        if ( query_gene_symbol.length == 0 ) { // if 'query_gene_symbol' is an empty string, draw plots of all genes (AlignmentTotarget modes)
            object_plot_BCellCrossReactivity.dict_data = object_plot_BCellCrossReactivity.dict_data_all;
            object_plot_TCellCrossReactivity.dict_data = object_plot_TCellCrossReactivity.dict_data_all;
            object_plot_BCellCrossReactivity.arr_data = object_plot_BCellCrossReactivity.arr_data_all;
            object_plot_TCellCrossReactivity.arr_data = object_plot_TCellCrossReactivity.arr_data_all;
            
            // load data for plotting additional annotations
            let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // use the first dataset to retrieve annotations of target representative proteins
            object_data.plot.annotation_protein = dataset.annotation_representative_target_protein;
            object_data.plot.interpro = dataset.interpro_target;
            object_data.plot.consensus_sequence = dataset.consensus_sequence_target;
            object_data.plot.iedb_epitope = dataset.iedb_epitope_target;
        } else {
            let query_gene_symbol_upper_case = query_gene_symbol.toUpperCase( ),
                dict_index = { },
                l_index;
            // retrieve indices of a given query protein and subset B-Cell and T-Cell records
            dict_index = object_plot_BCellCrossReactivity.dictionary_query_gene_symbol_upper_case_to_l_index;
            l_index = ( query_gene_symbol_upper_case in dict_index ) ? dict_index[ query_gene_symbol_upper_case ] : [ ]; 
            object_plot_BCellCrossReactivity.dict_data = DictArrayIndexing( object_plot_BCellCrossReactivity.dict_data_all, l_index );
            object_plot_BCellCrossReactivity.arr_data = ArrayIndexing( object_plot_BCellCrossReactivity.arr_data_all, l_index );
            
            dict_index = object_plot_TCellCrossReactivity.dictionary_query_gene_symbol_upper_case_to_l_index;
            l_index = ( query_gene_symbol_upper_case in dict_index ) ? dict_index[ query_gene_symbol_upper_case ] : [ ]; 
            object_plot_TCellCrossReactivity.dict_data = DictArrayIndexing( object_plot_TCellCrossReactivity.dict_data_all, l_index );
            object_plot_TCellCrossReactivity.arr_data = ArrayIndexing( object_plot_TCellCrossReactivity.arr_data_all, l_index );
            
            // load data for plotting additional annotations
            // retrieve interpro and iedb records for a query protein
            for ( let index_dataset = 0; index_dataset < l_name_dataset.length; index_dataset ++ ) {
                let dataset = object_data.main.dataset[ l_name_dataset[ index_dataset ] ];
                
                if ( query_gene_symbol_upper_case in dataset.interpro_query.dictionary_query_gene_symbol_upper_case_to_l_index ) { // if current dataset contain data of the current query_gene_sumbol
                    // initialize
                    let dict_index = { },
                        l_index = [ ];
                    
                    object_data.plot.iedb_epitope = dataset.iedb_epitope_query;
                    dict_index = object_data.plot.iedb_epitope.dictionary_query_gene_symbol_upper_case_to_l_index;
                    object_data.plot.iedb_epitope.dict_data = DictArrayIndexing( dataset.iedb_epitope_query.dict_data_all, ( query_gene_symbol_upper_case in dict_index ) ? dict_index[ query_gene_symbol_upper_case ] : [ ] );
                    
                    // compose the protein sequence trace of the current query_gene_symbol
                    let protein = dataset.arr_data_acc_query[ dataset.acc_query.dictionary_query_gene_symbol_upper_case_to_l_index[ query_gene_symbol_upper_case ][ 0 ] ], // retrieve a protein record of a query_protein (use the first protein of the query_gene_symbol)
                        sequence = { }; // initialize consensus sequence object
                    sequence.accumulated_length = protein.seq_length
                    sequence.seq_consensus_concatenated = protein.seq
                    sequence.l_x = nj.arange( sequence.accumulated_length ).tolist( ) // 0-based coordinates of x-axis
                    sequence.data = [ { type: 'scattergl', mode: "text", x: sequence.l_x, y: ArrayFull( sequence.accumulated_length, - 0.75 ), text: sequence.seq_consensus_concatenated.split( "" ), textfont: { size: 15 }, hoverinfo: "x", hovertemplate: "<br><extra></extra>", showlegend: false, name: "concatanated_consensus_protein_sequence" } ]; // display only x position of residues // no hover info
                    object_data.plot.consensus_sequence = sequence; // initialize consensus sequence object
                    
                    // compose the protein annotation trace of the current query_gene_symbol
                    let annotation = { data: [ ] }, // initialize annotation object
                        pos_y = ( 0.5 - 1 ) / 4 - 0.15;
                    annotation.show = $( "#toggle_ProteinAnnotation_MolecularMimicryMap" ).hasClass( "active" ); // set visibility of SARS-CoV-2 proteins
                    annotation.data.push( { x: [ 0, protein.seq_length ], y: [ pos_y, pos_y ], name: protein[ object_data.setting.name_acc_query ] + "_Anno_Base", mode: "lines", type: "scatter", opacity: 1, showlegend: false, line: { width: 10, color: "#a3a3a3" }, visible: annotation.show } ); // 0-based coordinates
                    object_data.plot.annotation_protein = annotation; // initialize protein annotation object
                    
                    // compose interpro annotation traces for the current query_gene_symbol
                    let interpro = dataset.interpro_query;
                    interpro.data = [ ];
                    interpro.dict_color = { P: "#1f1994", G: "#08750a", S: "#781387", c: "#798514" }; // initialize interpro object
                    dict_index = interpro.dictionary_query_gene_symbol_upper_case_to_l_index;
                    l_index = ( query_gene_symbol_upper_case in dict_index ) ? dict_index[ query_gene_symbol_upper_case ] : [ ];
                    interpro.dict_data = DictArrayIndexing( interpro.dict_data_all, l_index );
                    interpro.arr_data = ArrayIndexing( interpro.arr_data_all, l_index );
                    interpro.show = $( "#toggle_ProteinAnnotation_MolecularMimicryMap" ).hasClass( "active" ); // set visibility of interpro domains
                    for ( let i = 0; i < interpro.arr_data.length; i ++ ) {
                        let step = 10, // anchor every 10 residues
                            domain = interpro.arr_data[ i ], 
                            pos_y = ( 0.5 - 1 ) / 4 - 0.15, 
                            customdata = [ protein[ object_data.setting.name_acc_query ], protein.seq_length, domain.interpro_name, domain.interpro_acc, domain.annotation_acc, domain.start, domain.end ], // 1-based coodinates
                            len_domain = domain.end - domain.start + 1,  
                            trace = { name: domain.interpro_name + "__InterPro", mode: "lines", type: "scatter", opacity: 0.2, showlegend: false, line: { width: 15, color: interpro.dict_color[ domain.annotation_acc.slice( 0, 1 ) ] }, visible: interpro.show, 
                                     hovertemplate: "InterPro Domain: <b>%{customdata[2]}</b> (%{customdata[3]})<br>Protein: <b>%{customdata[0]}</b> (from %{customdata[5]:.0f} to %{customdata[6]:.0f})<br>Database accession: %{customdata[4]}<br><extra></extra>", customdata: [ ], x: [ ], y: [ ] };
                        
                        for ( let j = 0; j <= len_domain / step + 1; j ++ ) { // for each domain, plot point every 10 residues for displaying information through hover
                            trace.customdata.push( customdata );
                            trace.y.push( pos_y );
                            let x = domain.start - 1 + j * step; // 0-based coordinates
                            trace.x.push( ( x > domain.end ) ? domain.end : x )
                        }
                        interpro.data.push( trace );
                    }
                    object_data.plot.interpro = interpro;
                }
            }
        }
        // index data with target_species of interest
        object_plot_BCellCrossReactivity.dictionary_target_species_to_l_index = Index_list_with_dictionary( ( object_data.flag.query_label_represents_target ) ? object_plot_BCellCrossReactivity.dict_data[ "target_species" ] : object_plot_BCellCrossReactivity.dict_data[ "target_species" ] );

        // compose customdata array and hovertemplate            
        object_plot_BCellCrossReactivity.hovertemplate = ["[ B-cell cross reactivity prediction ]",
                                                          ( object_data.flag.alignment_to_target ) ? "%{customdata[23]}:<br>          <b>%{customdata[25]}</b> from <b>%{customdata[26]:.0f}</b> to <b>%{customdata[27]:.0f}</b> (<b>%{customdata[0]}</b> from <b>%{customdata[1]:.0f}</b> to <b>%{customdata[2]:.0f}</b>)" : "%{customdata[23]}:<br>          <b>%{customdata[0]}</b> from <b>%{customdata[1]:.0f}</b> to <b>%{customdata[2]:.0f}</b>", // display coordinates on the representative target protein
                                                          "        structure: <b>%{customdata[6]}</b>",
                                                          ( object_data.flag.query_label_represents_target ) ? "%{customdata[3]}:<br>          <b>%{customdata[24]}</b> from <b>%{customdata[4]:.0f}</b> to <b>%{customdata[5]:.0f}</b>" : "query: <b>%{customdata[3]}</b> (<b>%{customdata[24]}</b>) from <b>%{customdata[4]:.0f}</b> to <b>%{customdata[5]:.0f}</b>",
                                                          "        structure: <b>%{customdata[7]}</b>",
                                                          "",
                                                          "Structure Similarity:",
                                                          "        secondary structure: <b>%{customdata[8]:.2f}</b>",
                                                          "        surface accessibility correlation (p-value): <b>%{customdata[9]}</b> (%{customdata[12]})",
                                                          "        torsion angle correlation (phi) (p-value): <b>%{customdata[10]}</b> (%{customdata[13]})",
                                                          "        torsion angle correlation (psi) (p-value): <b>%{customdata[11]}</b> (%{customdata[14]})",
                                                          "        global alignment identity (significance, e-value): <b>%{customdata[22]:.2f}</b> (<b>%{customdata[21]:.1e}</b>)",
                                                          "",
                                                          "Epitope Similarity:",
                                                          "        linear similarity (sum of BLOSUM62 scores): <b>%{customdata[16]:.1f}</b>",
                                                          "        discontinuous similarity (only co-accessible residues): <b>%{customdata[17]:.1f}</b>",
                                                          "        discontinuous similarity normalized by window length (%{customdata[19]:.0f} a.a.): <b>%{customdata[15]:.2f}</b>",
                                                          "        number of co-accessible residues: <b>%{customdata[18]:.1f}</b>",
                                                          "(this epitope represent <i>%{customdata[20]:.0f} epitopes</i> before redundancy reduction)",
                                                          "<br><extra></extra>" ].join( "<br>" );

        object_plot_BCellCrossReactivity.customdata = DictArrayToArray( object_plot_BCellCrossReactivity.dict_data, [ "target_accession", "target_start", "target_end", "name_protein_query", "query_start", "query_end", "name_structure_target", "name_structure_query", "score_similarity_ss8", "string_correl_coeffi_acc", "string_correl_coeffi_phi", "string_correl_coeffi_psi", "string_correl_p_value_acc", "string_correl_p_value_phi", "string_correl_p_value_psi", "avg_score_blosum_weighted", "score_blosum", "score_blosum_weighted", "sum_of_weights", "window_size", "duplicate_counts", "e_value", "identity", "target_species", "humen_gene_symbol" ] );
        if ( object_data.flag.alignment_to_target ) { // when reference target proteins are used for visualization
            object_plot_BCellCrossReactivity.customdata = ArrayCombine( object_plot_BCellCrossReactivity.customdata, DictArrayToArray( object_plot_BCellCrossReactivity.dict_data, [ "name_protein_target", "target_representative_start", "target_representative_end" ] ) );
        }
        object_plot_BCellCrossReactivity.customdata = ArrayTranspose( object_plot_BCellCrossReactivity.customdata );
                        
        object_plot_BCellCrossReactivity.selection = { l_error_x: object_plot_BCellCrossReactivity.dict_data[ 'error_x' ], l_opacity: object_plot_BCellCrossReactivity.dict_data[ 'opacity' ] }; // for highlighting specific records
        
        data_line_type_MolecularMimicryMap_BCellCrossReactivity = [ ]; // empty data for line-type MolecularMimicryMap_BCellCrossReactivity plot

        // retrieve general setting            
        layout_MolecularMimicryMap.hovermode = object_plot_MolecularMimicryMap.hovermode; // update hovermode
        object_plot_MolecularMimicryMap.showlegend = false // flag for showing name of certain traces (a legend of the graph)
        plotMolecularMimicryMap.style.height = String( Math.max( 200, Math.min( 1000, document.getElementById( "input_plot_height_MolecularMimicryMap" ).value ) ) ) + 'px' // set height of the MolecularMimicryMap plot // max height is 1000 // min height is 200
            
        object_plot_BCellCrossReactivity.flag_bool_mode_is_lines = document.getElementById( "select_representation_of_an_alignment_BCellCrossReactivity" ).value == 1? true : false; 
        plotly_type_BCellCrossReactivity = document.getElementById( "select_graphic_format_BCellCrossReactivity" ).value == 0? "scattergl" : "scatter"; // retrieve plot setting from the setting panel

        object_plot_BCellCrossReactivity.show = $( "#toggle_BCellCrossReactivityPrediction_MolecularMimicryMap" ).hasClass( "active" ); // retrieve visibility
        console.log( "[DrawMolecularMimicryMap] BCellCrossReactivity visibility:", object_plot_BCellCrossReactivity.show );

        
        // compose traces
        if ( object_plot_BCellCrossReactivity.flag_bool_mode_is_lines ) { 
            for ( let i = 0; i < object_plot_BCellCrossReactivity.arr_data.length; i ++ ) {
                let trace = {  };
                trace.x = [ object_plot_BCellCrossReactivity.dict_data[ 'start' ][ i ], object_plot_BCellCrossReactivity.dict_data[ 'end' ][ i ] ]; // retrieve start and end position
                trace.y = [ object_plot_BCellCrossReactivity.dict_data[ 'y' ][ i ], object_plot_BCellCrossReactivity.dict_data[ 'y' ][ i ] ];
                trace.type = plotly_type_BCellCrossReactivity
                trace.mode = 'lines'
                trace.name = "BCR_" + String( i ) // assign trace name for the current record
                trace.line = { width: object_plot_BCellCrossReactivity.dict_data[ 'size' ][ i ] }
                trace.opacity = float_line_type_opacity_MolecularMimicryMap_BCellCrossReactivity // fixed opacity for the line-type plot for efficient updating
                trace.line.color = object_plot_BCellCrossReactivity.dict_data[ 'color' ][ i ];
                trace.showlegend = false;
                trace.visible = object_plot_BCellCrossReactivity.show;
                trace.customdata = [ object_plot_BCellCrossReactivity.customdata[ i ], object_plot_BCellCrossReactivity.customdata[ i ] ];
                trace.hovertemplate = object_plot_BCellCrossReactivity.hovertemplate;
                data_line_type_MolecularMimicryMap_BCellCrossReactivity.push( trace )
            }
        } else {
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.x = object_plot_BCellCrossReactivity.dict_data[ 'x' ]; 
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.y = object_plot_BCellCrossReactivity.dict_data[ 'y' ];
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.marker.size = object_plot_BCellCrossReactivity.dict_data[ 'size' ];
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.marker.opacity = object_plot_BCellCrossReactivity.dict_data[ 'opacity' ];
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.marker.color = object_plot_BCellCrossReactivity.dict_data[ 'color' ];;
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.marker.line.width = 0
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.type = plotly_type_BCellCrossReactivity;
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.showlegend = false;
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.name = 'B Cell Cross-Reactivity Prediction'
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.visible = object_plot_BCellCrossReactivity.show;
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.error_x = { type: 'data', array: object_plot_BCellCrossReactivity.dict_data[ "error_x" ], visible: true, width: 0, thickness: 1 }; // represent alignment by using errorbar
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.customdata = object_plot_BCellCrossReactivity.customdata;
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.hovertemplate = object_plot_BCellCrossReactivity.hovertemplate;
        }
            
        object_plot_BCellCrossReactivity.metrics = { }; // initialize metrics
        object_plot_BCellCrossReactivity.metrics[ '-log10( e-value )' ] = object_plot_BCellCrossReactivity.dict_data[ "minus_log10_e_value" ];
        object_plot_BCellCrossReactivity.mask_selected = ArrayFull( object_plot_BCellCrossReactivity.arr_data.length, true ); // initialize mask for selection 
            
        if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) { // when mhc_ligand prediction data exists
            // index data with target_species
            object_plot_TCellCrossReactivity.dictionary_target_species_to_l_index = Index_list_with_dictionary( object_plot_TCellCrossReactivity.dict_data[ "target_species" ] );
            
            // compose customdata array and hovertemplate   
            object_plot_TCellCrossReactivity.hovertemplate = ["[ T-cell cross reactivity prediction ]",
                                                              "MHC allele (class): <b>%{customdata[12]}</b> (<b>%{customdata[15]}</b>)",
                                                              "        associated diseases: <b>%{customdata[13]}</b>",
                                                              "        PubMed ID: %{customdata[14]}",
                                                              "",
                                                              ( object_data.flag.alignment_to_target )? "%{customdata[21]}:<br>          <b>%{customdata[23]}</b> from <b>%{customdata[24]:.0f}</b> to <b>%{customdata[25]:.0f}</b> (<b>%{customdata[0]}</b> from <b>%{customdata[1]:.0f}</b> to <b>%{customdata[2]:.0f}</b>)" : "%{customdata[21]}:<br>          <b>%{customdata[0]}</b> from <b>%{customdata[1]:.0f}</b> to <b>%{customdata[2]:.0f}</b>",
                                                              "        sequence: <b>%{customdata[6]}</b>",
                                                              "        predicted binding affinity (IC50): <b>%{customdata[8]} nM</b>",
    //                                                           "        list of used algorithms: %{customdata[10]}",
                                                              "",
                                                              "query: <b>%{customdata[3]}</b> (<b>%{customdata[22]}</b>) from <b>%{customdata[4]:.0f}</b> to <b>%{customdata[5]:.0f}</b>",
                                                              "        sequence: <b>%{customdata[7]}</b>",
                                                              "        predicted binding affinity (IC50): <b>%{customdata[9]} nM</b>",
    //                                                           "        list of used algorithms: %{customdata[11]}",
                                                              "",
                                                              "Epitope Similarity:",
                                                              "        linear similarity (sum of BLOSUM62 scores): <b>%{customdata[16]:.1f}</b>",
                                                              "        linear similarity normalized by window length (%{customdata[19]:.0f} a.a.): <b>%{customdata[17]:.2f}</b>",
    //                                                           "    Global alignment significance (e-value): <b>%{customdata[20]:.2f}</b>",
                                                              "(this epitope represent <i>%{customdata[18]:.0f} epitopes</i> before redundancy reduction)",
                                                              "<br><extra></extra>" ].join( "<br>" );

            object_plot_TCellCrossReactivity.customdata = DictArrayToArray( object_plot_TCellCrossReactivity.dict_data, [ "target_accession", "target_start", "target_end", "name_protein_query", "query_start", "query_end", "target_subsequence", "query_subsequence", "score_geometric_mean_target", "score_geometric_mean_query", "algorithms_target", "algorithms_query", "name_mhc_allele", "name_disease", "pubmed_id", "mhc_class", "score_blosum", "avg_score", "duplicate_counts", "window_size", "e_value", "target_species", "humen_gene_symbol" ] );
            if ( object_data.flag.alignment_to_target ) { // when reference target proteins are used for visualization
                object_plot_TCellCrossReactivity.customdata = ArrayCombine( object_plot_TCellCrossReactivity.customdata, DictArrayToArray( object_plot_TCellCrossReactivity.dict_data, [ "name_protein_target", "target_representative_start", "target_representative_end" ] ) );
            }
            object_plot_TCellCrossReactivity.customdata = ArrayTranspose( object_plot_TCellCrossReactivity.customdata );
            
            
            object_plot_TCellCrossReactivity.selection = { l_error_x: object_plot_TCellCrossReactivity.dict_data[ 'error_x' ], l_opacity: object_plot_TCellCrossReactivity.dict_data[ 'opacity' ] }; // for highlighting specific records
            
            // retrieve general setting  
            int_index_representation_TCellCrossReactivity = document.getElementById( "select_representation_of_an_alignment_TCellCrossReactivity" ).value; // retrieve plot setting from the setting panel
            plotly_type_TCellCrossReactivity = document.getElementById( "select_graphic_format_TCellCrossReactivity" ).value == 0? "scattergl" : "scatter"; 
            object_plot_TCellCrossReactivity.show = $( "#toggle_TCellCrossReactivityPrediction_MolecularMimicryMap" ).hasClass( "active" ); // retrieve visibility
            console.log( "[DrawMolecularMimicryMap] TCellCrossReactivity visibility:", object_plot_TCellCrossReactivity.show );
            
            // compose traces
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.x = object_plot_TCellCrossReactivity.dict_data[ 'x' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.x = object_plot_TCellCrossReactivity.dict_data[ 'x' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.y = object_plot_TCellCrossReactivity.dict_data[ 'y' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.y = object_plot_TCellCrossReactivity.dict_data[ 'y' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.marker.symbol = [ "y-down-open", "star-triangle-down-dot", "bowtie" ][ int_index_representation_TCellCrossReactivity ]; // retrieve representation based on the given "int_index_representation_TCellCrossReactivity"
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.marker.symbol = [ "y-up-open", "star-triangle-up-dot", "hourglass" ][ int_index_representation_TCellCrossReactivity ];

            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.marker.size = object_plot_TCellCrossReactivity.dict_data[ 'size_query' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.marker.size = object_plot_TCellCrossReactivity.dict_data[ 'size_target' ];

            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.marker.line.width = int_index_representation_TCellCrossReactivity == 0 ? 2 : 0; // if symbol is "y-down-open", set line width to 3
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.marker.line.width = int_index_representation_TCellCrossReactivity == 0 ? 2 : 0; // if symbol is "y-down-open", set line width to 3
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.marker.color = object_plot_TCellCrossReactivity.dict_data[ 'color' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.marker.color = object_plot_TCellCrossReactivity.dict_data[ 'color' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.marker.opacity = object_plot_TCellCrossReactivity.dict_data[ 'opacity' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.marker.opacity = object_plot_TCellCrossReactivity.dict_data[ 'opacity' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.type = plotly_type_TCellCrossReactivity;
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.type = plotly_type_TCellCrossReactivity;
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.name = "T Cell Cross-Reactivity Prediction (query)";
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.name = "T Cell Cross-Reactivity Prediction (target)";
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.visible = object_plot_TCellCrossReactivity.show;
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.visible = object_plot_TCellCrossReactivity.show;
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.error_x = { type: 'data', array: ArrayFull( object_plot_TCellCrossReactivity.arr_data.length, 0 ), visible: true, width: 0, thickness: 1 }
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.error_x = { type: 'data', array: object_plot_TCellCrossReactivity.dict_data[ 'error_x' ], visible: true, width: 0, thickness: 1 }; // represent alignment by using errorbar of the trace containing data of target

            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query.hoverinfo = 'skip'; // skip hoverinfo for the other trace
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.hovertemplate = object_plot_TCellCrossReactivity.hovertemplate;
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target.customdata = object_plot_TCellCrossReactivity.customdata;

            object_plot_TCellCrossReactivity.metrics = { }; // initialize metrics
            object_plot_TCellCrossReactivity.metrics[ '-log10( e-value )' ] = object_plot_TCellCrossReactivity.dict_data[ "minus_log10_e_value" ];
            object_plot_TCellCrossReactivity.metrics[ "log10( score_geometric_mean_query )" ] = object_plot_TCellCrossReactivity.dict_data[ "score_geometric_mean_query_log10" ];
            object_plot_TCellCrossReactivity.metrics[ "log10( score_geometric_mean_target )" ] = object_plot_TCellCrossReactivity.dict_data[ "score_geometric_mean_target_log10" ];
            object_plot_TCellCrossReactivity.mask_selected = ArrayFull( object_plot_TCellCrossReactivity.arr_data.length, true ); // initialize mask for selection
        }
            
        // adjust layouts
        object_plot_MolecularMimicryMap.float_max_of_l_y = ArrayFindMinMax( ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) ? ArrayCombine( object_plot_BCellCrossReactivity.dict_data[ 'y' ], object_plot_TCellCrossReactivity.dict_data[ 'y' ] ) : object_plot_BCellCrossReactivity.dict_data[ 'y' ] )[ 1 ]; // retrieve the max value on the Y-axis for both T and B CellCrossReactivity prediction data
        if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) { 
            console.log( "[DrawMolecularMimicryMap] number of TCellCrossReactivity prediction records for plotting:", object_plot_TCellCrossReactivity.arr_data.length );
        }
        let y_ticks = TickFindOptimal( object_plot_MolecularMimicryMap.float_max_of_l_y ); // generate and assign appropriate y_ticks
        layout_MolecularMimicryMap.yaxis.tickvals = y_ticks;
        layout_MolecularMimicryMap.yaxis.ticktext = ArrayApply( y_ticks, String );
        layout_MolecularMimicryMap.margin.l = 13 + 20 * 2 + layout_MolecularMimicryMap.yaxis.ticktext[ y_ticks.length - 1 ].length * 7; // adjust margins // one digit of y_tick label is about 7 pixels
        console.log( "[DrawMolecularMimicryMap] setting margins of the main graph with following settings:", layout_MolecularMimicryMap.margin );
        console.log( "[DrawMolecularMimicryMap] number of BCellCrossReactivity prediction records for plotting:", object_plot_BCellCrossReactivity.arr_data.length );
        
        // set range of rangeslider according to Alignment mode
        layout_MolecularMimicryMap.xaxis.rangeslider.range = [ 0, object_data.plot.consensus_sequence.accumulated_length ]; // set range using accumulated length of consensus target sequences
        
        // Draw plots using Plotly.js
        object_plot_BCellCrossReactivity.index_trace_start = 0; // record index_start of traces
        // draw B cell cross reactivity prediction data
        if ( object_plot_BCellCrossReactivity.flag_bool_mode_is_lines ) { 
            Plotly.newPlot( plotMolecularMimicryMap, lodash.cloneDeep( data_line_type_MolecularMimicryMap_BCellCrossReactivity ), lodash.cloneDeep( layout_MolecularMimicryMap ), config_MolecularMimicryMap ); 
        } else {
            Plotly.newPlot( plotMolecularMimicryMap, [ lodash.cloneDeep( trace_point_type_MolecularMimicryMap_BCellCrossReactivity ) ], lodash.cloneDeep( layout_MolecularMimicryMap ), config_MolecularMimicryMap );
        }
        object_plot_BCellCrossReactivity.index_trace_end = plotMolecularMimicryMap.data.length; // record index_end of traces
        // update metrics plot
        UpdateBCellCrossReactivityPredMetricsPlot( );
            

        // draw T cell cross reactivity prediction data
        if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) { 
            // draw T cell cross reactivity prediction data
            object_plot_TCellCrossReactivity.index_trace_start = plotMolecularMimicryMap.data.length; // record index_start and index_end of traces
            Plotly.addTraces( plotMolecularMimicryMap, [ lodash.cloneDeep( trace_point_type_MolecularMimicryMap_TCellCrossReactivity_query ), lodash.cloneDeep( trace_point_type_MolecularMimicryMap_TCellCrossReactivity_target ) ] );
            object_plot_TCellCrossReactivity.index_trace_end = plotMolecularMimicryMap.data.length;
            // update metrics plot
            UpdateTCellCrossReactivityPredMetricsPlot( );
        }
        // compose traces
        UpdatequeryProteinMetricsPlot( );
        
        // Add protein annotations 
        console.log( '[DrawMolecularMimicryMap] plotting target protein annotation traces...' )
            // add annotation of proteins
        object_data.plot.annotation_protein.index_trace_start = plotMolecularMimicryMap.data.length; // record index_start and index_end of traces
        Plotly.addTraces( plotMolecularMimicryMap, lodash.cloneDeep( object_data.plot.annotation_protein.data ) );
        object_data.plot.annotation_protein.index_trace_end = plotMolecularMimicryMap.data.length;
            // add annotation of domains
        object_data.plot.interpro.index_trace_start = plotMolecularMimicryMap.data.length; // record index_start and index_end of traces
        Plotly.addTraces( plotMolecularMimicryMap, lodash.cloneDeep( object_data.plot.interpro.data ) );
        object_data.plot.interpro.index_trace_end = plotMolecularMimicryMap.data.length;
            // add annotation of consensus protein sequence
        object_data.plot.consensus_sequence.index_trace_start = plotMolecularMimicryMap.data.length; // record index_start and index_end of traces
        Plotly.addTraces( plotMolecularMimicryMap, lodash.cloneDeep( object_data.plot.consensus_sequence.data ) );
        object_data.plot.consensus_sequence.index_trace_end = plotMolecularMimicryMap.data.length;

        // update the visibility of protein annotation traces
        Toggle_ProteinAnnotation_MolecularMimicryMap( true );

        // Add IEDB epitopes with positive assays
        object_data.flag.iedb_epitope_drawn = false; // set flag indicating whether the plot has been drawn or not
        object_data.plot.iedb_epitope.show = $( "#toggle_iedb_epitope_MolecularMimicryMap" ).hasClass( "active" );
        if ( object_data.plot.iedb_epitope.show ) {
            Toggle_IEDB_Epitope_MolecularMimicryMap( true );
        }
        
        if ( object_data.flag.alignment_to_target ) {
            let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // use the first dataset to draw target annotations
            
            // Add metrics for vaccine design
            object_data.flag.vaccine_metric_drawn = false; // set flag indicating whether the plot has been drawn or not
            dataset.vaccine_metric.show = $( "#toggle_vaccine_metrics_MolecularMimicryMap" ).hasClass( "active" ); // set general visibility of all vaccine metric traces
            if ( dataset.vaccine_metric.show ) {
                VaccineMetrics_Apply_Visibility( true );
            }
            
            // retrieve mapping of name of each trace to trace index
            dict_name_plot_to_trace_index__MolecularMimicryMap = { }; // initialize the mapping
            for( let i = 0; i < plotMolecularMimicryMap.data.length; i ++ ) { dict_name_plot_to_trace_index__MolecularMimicryMap[ plotMolecularMimicryMap.data[ i ].name ] = i; }
            
            // draw vaccine candidates // draw DesignedVaccineTrace if the file has been loaded after trace index has been updated
            dataset.flag.vaccine_design_optivax_loaded = false; // assume reference genome changed 
            object_data.flag.vaccine_design_drawn = false; // set flag indicating whether the plot has been drawn or not
            dataset.vaccine_design.show = $( "#toggle_vaccine_design_MolecularMimicryMap" ).hasClass( "active" );
            if ( dataset.vaccine_design.show ) {
                Toggle_VaccineDesign_MolecularMimicryMap( );
            }
            
        } else {
            // retrieve mapping of name of each trace to trace index
            dict_name_plot_to_trace_index__MolecularMimicryMap = { }; // initialize the mapping
            for( let i = 0; i < plotMolecularMimicryMap.data.length; i ++ ) { dict_name_plot_to_trace_index__MolecularMimicryMap[ plotMolecularMimicryMap.data[ i ].name ] = i; }
        }
        Loading_Screen( false ); // remove loading screen once plot is drawn
        
        // Add Plotly interactions to MolecularMimicryMap main plot
        // draw tables and show molecular structure upon click
        console.log( '[DrawMolecularMimicryMap] adding interaction callbacks...' )
        plotMolecularMimicryMap.on( 'plotly_click', function( data ) {
            let clicked_point = data.points[ 0 ]; // only use the first point in the returned list of points to show a table containing alignment metrics and details
            let index = null, flag_data_type = null, name_trace = plotMolecularMimicryMap.data[ clicked_point.curveNumber ].name;
            console.log( name_trace );
            index = name_trace.slice( 0, 4 ) == "BCR_" ? clicked_point.curveNumber : clicked_point.pointIndex;
            if ( name_trace == "B Cell Cross-Reactivity Prediction" ) {
                flag_data_type = "B-Cell";
            } else if ( name_trace.slice( 0, 4 ) == "BCR_" ) {
                flag_data_type = "B-Cell";
            } else if ( name_trace.includes( "T Cell Cross-Reactivity Prediction" ) ) {
                flag_data_type = "T-Cell";
            } else if ( name_trace.includes( "IEDB_Epitopes" ) ) {
                flag_data_type = "IEDB";
            } else if ( name_trace.includes( "__InterPro" ) ) {
                flag_data_type = "InterPro";
            } else if ( name_trace == "vaccine_design" ) {
                flag_data_type = "vaccine_design";
            }
            gtag( 'event', 'main_graph_click_callback', { 'clicked_data_type' : flag_data_type } ); // [Google Analytics] record data_type of the clicked record to further improve the visualization of the data_type
            if ( flag_data_type == "B-Cell" ) { // when clicked data belongs to BCellCrossReactivity data         
                ClickCallBack_BCellCrossReactivity( index )
            } else if ( flag_data_type == "T-Cell" ) {
                Toggle_Exclusive_Tabs( "hide_all" ); // hide all supplementary tabs
                let name_dataset = object_plot_TCellCrossReactivity.dict_data[ "name_dataset" ][ index ],
                    dataset = object_data.main.dataset[ name_dataset ]; // retrieve namespace for a dataset
                clicked_record = object_plot_TCellCrossReactivity.arr_data[ index ]; // retrieve a clicked record
                
                object_data.main.expression = { name_dataset: name_dataset, int_index_acc_query: clicked_record.query_accession }; // setting for showing expression of a gene of interest
                UpdatePlotExpression( ); // Plot mRNA expression data
                console.log( "[plotMolecularMimicryMap] clicked record belongs to TCellCrossReactivity data:", clicked_record );
                arr_data_clicked = [ ]; // empty the array containing data of the clincked record
                if ( object_data.flag.alignment_to_target ) { // add information of representative target protein
                    let representative_target_protein = dataset.arr_data_acc_target_representative[ clicked_record.representative_accession ];
                    arr_data_clicked.push( { "Data Name": "[target] representative protein", Value: representative_target_protein.name + " (" + representative_target_protein.accession + ") from " + clicked_record.target_representative_start + " to " + clicked_record.target_representative_end, URL: "https://www.ncbi.nlm.nih.gov/protein/" + representative_target_protein.accession } );
                }
                arr_data_clicked.push( { "Data Name": "[query] protein name", Value: dataset.arr_data_acc_query[ clicked_record.query_accession ].name, URL: "https://www.google.com/search?q=" + dataset.arr_data_acc_query[ clicked_record.query_accession ].description.split( "OS=" )[ 0 ] } ); // add query protein description with a link to a google search
                arr_data_clicked.push( { "Data Name": "[target] protein accession", Value: dataset.arr_data_acc_target[ clicked_record.target_accession ].value + " from " + clicked_record.target_start + " to " + clicked_record.target_end, URL: "https://www.ncbi.nlm.nih.gov/protein/" + dataset.arr_data_acc_target[ clicked_record.target_accession ].value } );
                arr_data_clicked.push( { "Data Name": "[query] protein accession", Value: dataset.arr_data_acc_query[ clicked_record.query_accession ].value + " from " + clicked_record.query_start + " to " + clicked_record.query_end, URL: "https://www.uniprot.org/uniprot/" + dataset.arr_data_acc_query[ clicked_record.query_accession ].value } );
                arr_data_clicked.push( { "Data Name": "[target] peptide", Value: clicked_record.target_subsequence, URL: null, style: "font-family:Consolas" } );
                arr_data_clicked.push( { "Data Name": "[query] peptide", Value: clicked_record.query_subsequence, URL: null, style: "font-family:Consolas" } );
                arr_data_clicked.push( { "Data Name": "[target] predicted binding affinity*", Value: String( clicked_record.score_geometric_mean_target ) + " nM", URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "[query] predicted binding affinity*", Value: String( clicked_record.score_geometric_mean_query ) + " nM", URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "[target] prediction algorithms", Value: dataset.l_algorithm[ clicked_record.algorithms_target ], URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "[query] prediction algorithms", Value: dataset.l_algorithm[ clicked_record.algorithms_query ], URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "sum of BLOSUM62 scores", Value: clicked_record.score_blosum, URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "MHC class", Value: clicked_record.mhc_class, URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "MHC allele", Value: dataset.arr_data_mhc_allele[ clicked_record.mhc_allele ].value, URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "E-value (significance) of full-length alignment", Value: clicked_record.e_value, URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "alignment method", Value: clicked_record.source_is_blastp? "BLASTP" : "HMMER", URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "number of redundant alignments", Value: clicked_record.duplicate_counts, URL: null, style: "font-family:Arial" } );
                
                DrawD3Table_for_Record_Details( arr_data_clicked );
                document.getElementById( "title_d3_table_metrics" ).innerHTML = "T-Cell Cross-Reactivity Prediction data"; // update table title for 'd3_table_metrics' table
                document.getElementById( "footnote_d3_table_metrics" ).innerHTML = "A geometric average of predicted IC50 values. IC50 is the concentration that inhibits 50% binding of the fluorescein-labeled reference peptide."; // update table footnote for 'd3_table_metrics' table

                // draw Plotly table visualizing BLOSUM62 scores
                object_data_tableSequence.flag_data_type = "T-Cell";
                let len_alignment = clicked_record.query_subsequence.length, query_aligned_sequence = clicked_record.query_subsequence, target_aligned_sequence = clicked_record.target_subsequence, l_score_blosum = [ ];
                for ( let i = 0; i < query_aligned_sequence.length; i ++ ) { l_score_blosum.push( Math.round( object_data.main.dict_blosum62[ query_aligned_sequence[ i ] + target_aligned_sequence[ i ] ] ) ); } // round the blosum score so that step become 1
                let l_color_score_blosum = Color_for_score_blosum( l_score_blosum );

                let colors = [ ], values = [ ], header = [ ], l_col = [ 'target_seq', 'score_blosum', 'query_seq' ];
                values.push( ... [ target_aligned_sequence.split( "" ), l_score_blosum, query_aligned_sequence.split( "" ) ] );
                colors.push( ... [ ArrayFull( len_alignment, "#ffffff" ), l_color_score_blosum, ArrayFull( len_alignment, "#ffffff" ) ] );

                for ( let i = 0; i < l_col.length; i ++ ) { header.push( [ "<b>" + l_col[ i ] + "</b>" ] ); } // build header from 'l_col'
                object_data_tableSequence.data = [{
                    type: 'table',
                    header: { values: header, align: "center", height: 30, line: {width: 1, color: '#506784'}, fill: {color: '#f0f0f0'}, font: {family: "Arial", size: 12, color: "black"} },
                    cells: {values: values, align: "center", height: 20, line: {color: colors, width: 1}, fill: {color: colors }, font: {family: "Arial", size: 12, color: ["#3d3d3d"] }}
                }];
                document.getElementById( "plotly_table_sequence" ).style.height = String( Math.min( 20 * int_n_residues_per_window_table_sequence + 30 + 10, parseInt( l_score_blosum.length * 20 + 30 + 10 ) ) ) + "px"; // set height of table according to the length of alignment # max height is 640
//                 let layout_tableSequence_TCellCrossReactivity = Object.assign( { width: ( Math.min( , tableSequence.getBoundingClientRect( ).width ) ) }, layout_tableSequence )
                if ( "removeAllListeners" in tableSequence ) { 
                    tableSequence.removeAllListeners( "click" ); tableSequence.removeEventListener( 'click', Highlight_PDB_Residue__Click_Callback__Aligned_Sequence_Table ) } // remove previous listeners if a listener exists
                str_jquery_container = "#container_plotly_table_sequence";
                if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { Responsive_Column_Width_Aligned_Sequence_Table_TCellCrossReactivity( ); // draw Plotly plot synchronously if the container is currently shown
                } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { Responsive_Column_Width_Aligned_Sequence_Table_TCellCrossReactivity( ); } ); } // draw Plotly plot once the container is shown if the container is currently hidden
                document.getElementById( "description_clicked_position__table_sequence" ).innerHTML = ""; // empty the description
                
                // Render default molecular structures using the Mol* JS application
                str_jquery_container = "#container_PDB";
                let pos_protein = 0, pos_pdb = 0;
                // show dummy if T-cell cross-reactivity prediction record was been clicked. 
                if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { pdbqueryProtein.visual.update( option_initialization_molstar );; // render coordinates synchronously if the container is currently shown
                } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { pdbqueryProtein.visual.update( option_initialization_molstar ); } ); } // render coordinates once the container is shown if the container is currently hidden
                if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { pdbtargetProtein.visual.update( option_initialization_molstar );; // render coordinates synchronously if the container is currently shown
                } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { pdbtargetProtein.visual.update( option_initialization_molstar ); } ); } // render coordinates once the container is shown if the container is currently hidden
                // update protein id label (to increse interactivity)
                document.getElementById( "text_protein_structure_target" ).innerText = ( object_data.flag.query_label_represents_target ) ? `SARS-CoV-2 (----)` : `target (----)`;
                document.getElementById( "text_protein_structure_query" ).innerText = ( object_data.flag.query_label_represents_target ) ? `Coronatarget (----)` : `query (----)`;
            } else if ( flag_data_type == "IEDB" ) {
                let customdata = clicked_point.customdata; // retrieve custom data of clicked point
                console.log( "[plotMolecularMimicryMap] clicked record is IEDB epitope:", clicked_point );

                arr_data_clicked = [ ]; // empty the array containing data of the clincked record
                let url_iedb = "https://www.iedb.org/epitope/" + customdata[ 0 ];
                arr_data_clicked.push( { "Data Name": "representative target protein", Value: customdata[ 5 ] + " from " + customdata[ 3 ] + " to " + customdata[ 4 ], URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "IEDB epitope accession", Value: customdata[ 0 ], URL: url_iedb, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "number of positive B-cell assays", Value: customdata[ 1 ], URL: url_iedb, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "number of positive T-cell assays", Value: customdata[ 2 ], URL: url_iedb, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "percent_identity", Value: customdata[ 7 ], URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "mismatch", Value: customdata[ 8 ], URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "gapopen", Value: customdata[ 9 ], URL: null, style: "font-family:Arial" } );

                DrawD3Table_for_Record_Details( arr_data_clicked );
                document.getElementById( "title_d3_table_metrics" ).innerHTML = "Immune Epitope Database (IEDB) Epitope"; // update table title for 'd3_table_metrics' table
                document.getElementById( "footnote_d3_table_metrics" ).innerHTML = ""; // update table footnote for 'd3_table_metrics' table
            } else if ( flag_data_type == "InterPro" ) {
                let customdata = clicked_point.customdata; // retrieve custom data of clicked InterPro annotation
                console.log( "[plotMolecularMimicryMap] clicked record is InterPro protein annotation:", clicked_point );

                arr_data_clicked = [ ]; // empty the array containing data of the clincked record
                let url_interpro = "http://www.ebi.ac.uk/interpro/entry/InterPro/" + customdata[ 3 ] + '/';
                arr_data_clicked.push( { "Data Name": "representative target protein", Value: customdata[ 0 ] + " from " + customdata[ 5 ] + " to " + customdata[ 6 ], URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "InterPro accession", Value: customdata[ 3 ], URL: url_interpro, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "InterPro name", Value: customdata[ 2 ], URL: url_interpro, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "Database accession", Value: customdata[ 5 ], URL: url_interpro, style: "font-family:Arial" } );
                
                DrawD3Table_for_Record_Details( arr_data_clicked );
                document.getElementById( "title_d3_table_metrics" ).innerHTML = "InterPro Protein Domain Annotation"; // update table title for 'd3_table_metrics' table
                document.getElementById( "footnote_d3_table_metrics" ).innerHTML = ""; // update table footnote for 'd3_table_metrics' table
            } else if ( flag_data_type == "vaccine_design" ) { // selection of vaccine candidate through clicking // update selected status of clicked record
                let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // use the first dataset for 
                dataset.vaccine_design.interaction_mode = Retrieve_Selection_Mode_Using_Keydown_Status_VaccineDesign( ); // retrieve selection mode
                if( dataset.vaccine_design.interaction_mode == "Show_Info" ) { dataset.vaccine_design.interaction_mode = $('#radio__Vaccine_Design__Select_Mode label.active input').attr( "value" ); } // selection mode from keydown_status has a priority over selection mode from the radio button.
                if ( dataset.vaccine_design.interaction_mode == "Show_Info" ) {
                    let customdata = clicked_point.customdata; // retrieve custom data of clicked point
                    console.log( "[plotMolecularMimicryMap] clicked record is a (peptide) vaccine candidate:", clicked_point );

                    arr_data_clicked = [{ "Data Name": "header", Value: customdata[ 3 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "sequence", Value: customdata[ 4 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "aligned positions on SARS-CoV-2 proteome", Value: customdata[0] + ' from ' + customdata[1] + ' to ' + customdata[2] + ' (' + customdata[5] + ' mismatch)', URL: null, style: "font-family:Arial" },
                                        { "Data Name": "number of <b>mutated</b> proteins", Value: customdata[10], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "number of overlapped predicted <b>B-cell cross-reactive epitopes</b>", Value: customdata[ 6 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "number of overlapped predicted <b>T-cell cross-reactive MHC epitopes</b>", Value: customdata[ 7 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "number of overlapped predicted <b>MHC-I epitopes</b> (af<0.001)", Value: customdata[ 16 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "number of overlapped predicted <b>MHC-II epitopes</b> (af<0.001)", Value: customdata[ 17 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "number of <b>positive B-cell assays</b> for overlapped IEDB epitopes", Value: customdata[ 8 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "number of <b>positive T-cell assays</b> for overlapped IEDB epitopes", Value: customdata[ 9 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "Relative accessible surface area", Value: d3.format( ".1%" )( customdata[ 18 ] ), URL: null, style: "font-family:Arial" },
                                        { "Data Name": "B cell linear epitope prediction score (BepiPred)", Value: customdata[ 14 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "MHC-I epitope processing score (MHCflurry)", Value: customdata[ 15 ], URL: null, style: "font-family:Arial" },
                                       ]; // build d3 array
                    DrawD3Table_for_Record_Details( arr_data_clicked );
                    document.getElementById( "title_d3_table_metrics" ).innerHTML = "Potential Vaccine Candidate"; // update table title for 'd3_table_metrics' table
                    document.getElementById( "footnote_d3_table_metrics" ).innerHTML = ""; // update table footnote for 'd3_table_metrics' table
                } else {
                    let bool_selected = dataset.vaccine_design.interaction_mode == "Include";
                    if ( dataset.vaccine_design.dict_data[ "selected" ][ index ] != bool_selected ) { // update graph if current status is different from previous status. 
                        dataset.vaccine_design.dict_data[ "selected" ][ index ] = bool_selected;
                        Draw_DesignedVaccineTrace( "update_selection" ); // update selection
                    }
                }
            } 
        });
        plotMolecularMimicryMap.on( 'plotly_selected', function( data ) { // selection of vaccine candidate through selection
            console.log( data );
            if ( data == undefined ) { return; }
            dataset.vaccine_design.interaction_mode = Retrieve_Selection_Mode_Using_Keydown_Status_VaccineDesign( ); // retrieve selection mode
            if( dataset.vaccine_design.interaction_mode == "Show_Info" ) { dataset.vaccine_design.interaction_mode = $('#radio__Vaccine_Design__Select_Mode label.active input').attr( "value" ); } // selection mode from keydown_status has a priority over selection mode from the radio button.
            if ( dataset.vaccine_design.interaction_mode == "Show_Info" ) { return; } // if selection_mode == "Show_Info", do not update selection
            let l_point = [ ], index_vaccine_design = dict_name_plot_to_trace_index__MolecularMimicryMap[ "vaccine_design" ], bool_selected = dataset.vaccine_design.interaction_mode == "Include";
            data.points.forEach( function( pt ) { if ( pt.curveNumber == index_vaccine_design ) { l_point.push( pt ); } } ); // retrieve selected points of the vaccine_design trace
            for ( let i = 0; i < l_point.length; i ++ ) { dataset.vaccine_design.dict_data[ "selected" ][ l_point[ i ].pointIndex ] = bool_selected; } // update selected status of selected records
            Draw_DesignedVaccineTrace( "update_selection" ) // update colors
        });
        plotMolecularMimicryMap.on( 'plotly_relayout', EventHandler_plotly_relayout_MolecularMimicryMap ); // detect zooming and resizing
        plotMolecularMimicryMap.on( 'plotly_restyle', EventHandler_plotly_restyle_MolecularMimicryMap ); 
        plotMolecularMimicryMap.on( 'plotly_autosize', function( data ) { 
            console.log( "plotMolecularMimicryMap, plotly_autosize event triggered:", data );
//             Set_Visibility_of_Consensus_Protein_Sequence( );
        });// detect resizing of plot
        Loading_Screen( false ); // remove loading screen once plot is drawn
        console.log( "[DrawMolecularMimicryMap] resolved" );
        await Adjust_Layout_MolecularMimicryMap( );
            
        console.log( "[DrawMolecularMimicryMap_for_a_query_gene] resolved" );
        resolve( );
    });
    }
                
    function SortBoxTrace( trace_a, trace_b ) { return - ( trace_a.q3 - trace_b.q3 ) } // Sort Plotly Boxplot traces based on parameter values
    function SortViolinTrace_Expression( trace_a, trace_b ) { return - ( trace_a.mean_expression_for_sorting - trace_b.mean_expression_for_sorting ) } // Sort Plotly Violin traces displaying expression values based on parameter values
//     function SortViolineTrace_Proportion( l_a, l_b ) { // Sort Plotly Violin traces displaying proportion data values based on parameter values
//         let index_value_for_sorting = ( l_a.length == 4 ) ? 6 : 3 ; // set index_of_value_for_sorting based on whether the expresion of the gene of interest (ACE2) is available (number of counts = 4 (available) and 2 (unavailable))
//         return - ( l_a[ index_value_for_sorting ] - l_b[ index_value_for_sorting ] )
//     } 
    
    function UpdatePlotExpression( ) { // update plots showing expression of genes based on collapse/show status of the containers
        if( $( "#container_expression_panel_MolecularMimicryMap" ).hasClass( "show" ) ) {
            if( $( "#container_plotly_scrnaseq" ).hasClass( "show" ) ) {
                PlotExpression_scRNA_Seq( );
            }
            if( $( "#container_plotly_gtex" ).hasClass( "show" ) ) {
                PlotExpression_GTEX( );
            }
        }
    }
    function PlotExpression_GTEX( ) { // plot violin and boxplots showing mRNA expressions of the protein of interest
        if ( object_data.flag.query_label_represents_target ) { // when target proteins are not used, do not draw GTEx expression plot
            return -1
        }
        let expression = object_data.main.expression,
            name_dataset = expression.name_dataset,
            index_acc_query = expression.int_index_acc_query,
            dataset = object_data.main.dataset[ name_dataset ], // retrieve dataset
            l_trace = [ ],
            gene_symbol = dataset.arr_data_acc_query[ index_acc_query ].Gene_Symbol,
            str_title_nav = "GTEx Expression of " + gene_symbol;
        
        if ( $( "#expression_panel__link_to_GTEx_portal" ).html( ) == str_title_nav ) { // if plot of the current gene of interest has been already drawn, exit the function call
            console.log( `[PlotExpression_GTEX] expression of the gene of interest ${gene_symbol} has been already drawn, exiting` );
            return -1;
        }
        $( "#expression_panel__link_to_GTEx_portal" ).html( str_title_nav ) // set label to the link to GTEx portal
        $( "#expression_panel__link_to_GTEx_portal" ).attr( "href", "https://gtexportal.org/home/gene/" + gene_symbol ); // set a link to GTEx portal
        for ( let tissue in dataset.gtex.dictdictarr ) {
            let trace = { };
            trace.lowerfence = [ dataset.gtex.dictdictarr[ tissue ][ 'MIN' ][ index_acc_query ] ];
            trace.q1 = [ dataset.gtex.dictdictarr[ tissue ][ 'Q1' ][ index_acc_query ] ];
            trace.median = [ dataset.gtex.dictdictarr[ tissue ][ 'Q2' ][ index_acc_query ] ];
            trace.q3 = [ dataset.gtex.dictdictarr[ tissue ][ 'Q3' ][ index_acc_query ] ];
            trace.upperfence = [ dataset.gtex.dictdictarr[ tissue ][ 'MAX' ][ index_acc_query ] ];
            trace.name = tissue;
            trace.line = { color: dataset.gtex.dict_name_tissue_to_color[ tissue ] }; // use pre-defined color for each tissue
            trace.type = 'box';
            trace.x0 = tissue;
            l_trace.push( trace );
        }
        l_trace = l_trace.sort( SortBoxTrace )
        Plotly.newPlot( plotGTEx, l_trace, { margin: { l: 50, r: 65, b: 90, t: 50, pad: 4 }, yaxis: { title : "TPM" } }, { ... config, filename: '3M_of_SARS-CoV-2__GTEx__Expression_of_' + dataset.arr_data_acc_query[ index_acc_query ].Gene_Symbol, height: 750, width: 1100 } ); // draw boxplot of expression of the gene using GTEx data
    }
    function Select_RemoveOptions( selectElement ) { // remove all option in the select element
       let length = selectElement.options.length - 1;
       for( let i = length; i >= 0; i -- ) {
          selectElement.remove( i );
       }
    }
    function Select_Get_Selected_Option_Using_ID( id_selectElement ) { // get selected option in the select element with its id
        let sel = document.getElementById( id_selectElement )
        return sel.options[ sel.selectedIndex ]
    }

    function String_Check_Substring( string, l_substring ) {
        let flag_contains_substring = false;
        string = string.toLowerCase( );
        for ( let i = 0; i < l_substring.length; i ++ ) {
            let substring = l_substring[ i ].toLowerCase( );
            if ( string.includes( substring ) ) {
                flag_contains_substring = true;
                break;
            }
        }
        return flag_contains_substring;
    }

    async function ClickCallBack_BCellCrossReactivity( index ) { // a click callback function for a B-cell cross reactivity prediction result
        let name_dataset = object_plot_BCellCrossReactivity.dict_data[ "name_dataset" ][ index ],
            dataset = object_data.main.dataset[ name_dataset ]; // retrieve namespace for a dataset
        Toggle_Exclusive_Tabs( "hide_all" ); // hide all supplementary tabs
        clicked_record = object_plot_BCellCrossReactivity.arr_data[ index ]; // retrieve a clicked record
        object_data.main.expression = { name_dataset: name_dataset, int_index_acc_query: clicked_record.query_accession }; // setting for showing expression of a gene of interest
        UpdatePlotExpression( ); // Plot mRNA expression data
        console.log( "[plotMolecularMimicryMap] clicked record belongs to BCellCrossReactivity data:", clicked_record );
        arr_data_clicked = [ ]; // empty the array containing data of the clincked record
        // define tag of datatypes
        let str_tag_query = ( object_data.flag.query_label_represents_target ) ? "Coronatarget" : "query",
            str_tag_target = ( object_data.flag.query_label_represents_target ) ? "SARS-CoV-2" : "target";
        if ( object_data.flag.alignment_to_target ) { // add information of representative target protein
            let representative_target_protein = dataset.arr_data_acc_target_representative[ clicked_record.representative_accession ];
            arr_data_clicked.push( { "Data Name": `[${str_tag_target}] representative protein`, Value: representative_target_protein.name + " (" + representative_target_protein.accession + ") from " + clicked_record.target_representative_start + " to " + clicked_record.target_representative_end, URL: "https://www.ncbi.nlm.nih.gov/protein/" + representative_target_protein.accession } );
        }
        if ( ! object_data.flag.query_label_represents_target ) {
            arr_data_clicked.push( { "Data Name": `[${str_tag_query}] protein name`, Value: dataset.arr_data_acc_query[ clicked_record.query_accession ].name, URL: "https://www.google.com/search?q=" + dataset.arr_data_acc_query[ clicked_record.query_accession ].description.split( "OS=" )[ 0 ] } ); // add query protein description with a link to a google search
        }
        arr_data_clicked.push( { "Data Name": `[${str_tag_target}] protein accession`, Value: dataset.arr_data_acc_target[ clicked_record.target_accession ].value + " from " + clicked_record.target_start + " to " + clicked_record.target_end, URL: ( ( name_dataset.includes( "gisaid" ) ) ? "https://www.gisaid.org/" : "https://www.ncbi.nlm.nih.gov/protein/" + dataset.arr_data_acc_target[ clicked_record.target_accession ].value ) } ); 
        arr_data_clicked.push( { "Data Name": `[${str_tag_query}] protein accession`, Value: dataset.arr_data_acc_query[ clicked_record.query_accession ].value + " from " + clicked_record.query_start + " to " + clicked_record.query_end, URL: ( ( object_data.flag.query_label_represents_target ) ? "https://www.ncbi.nlm.nih.gov/protein/" : "https://www.uniprot.org/uniprot/" ) + dataset.arr_data_acc_query[ clicked_record.query_accession ].value } );
        let flag_structure_exist_for_query_sequence = clicked_record.structure_id_query != -1, 
            flag_structure_exist_for_target_sequence = clicked_record.structure_id_target != -1, // retrieve flag for structure property data availability for query and target sequence
            str_label_query = `${str_tag_query} (----)`, // default labels
            str_label_target = `${str_tag_target} (----)`,
            tag_pdb_query = document.getElementById( "text_protein_structure_query" ),
            tag_pdb_target = document.getElementById( "text_protein_structure_target" );

        if ( flag_structure_exist_for_target_sequence ) { 
            let str_id_pdb = dataset.arr_data_acc_pdb[ clicked_record.structure_id_target ].id_pdb.toUpperCase( ),
                url_pdb = ( str_id_pdb.includes( "_SOURCE_" ) ) ? `${object_data.file.base_url}data/custom_cif/${str_id_pdb}.cif` : "https://www.rcsb.org/structure/" + str_id_pdb; // update link to protein structure (for both modeling results and pdb structures)
            
            arr_data_clicked.push( { "Data Name": `[${str_tag_target}] PDB structure`, Value: dataset.arr_data_acc_pdb[ clicked_record.structure_id_target ].value + " (" + dataset.arr_data_acc_target[ clicked_record.target_accession ].value + " from " + clicked_record.target_structure_start + " to " + clicked_record.target_structure_end + ")", URL: url_pdb, style: "font-family:Arial" } );
            str_label_target = `${str_tag_target} (${str_id_pdb})`; // update protein id label (to increse interactivity)
            tag_pdb_target.href = url_pdb;
        } else {
            arr_data_clicked.push( { "Data Name": `[${str_tag_target}] PDB structure`, Value: "unavailable", URL: null, style: "font-family:Arial" } );
            tag_pdb_target.removeAttribute( 'href' );
        }
        if ( flag_structure_exist_for_query_sequence ) { 
            let str_id_pdb = dataset.arr_data_acc_pdb[ clicked_record.structure_id_query ].id_pdb.toUpperCase( ),
                url_pdb = ( str_id_pdb.includes( "_SOURCE_" ) ) ? `${object_data.file.base_url}data/custom_cif/${str_id_pdb}.cif` : "https://www.rcsb.org/structure/" + str_id_pdb; // update link to protein structure (for both modeling results and pdb structures)
            
            arr_data_clicked.push( { "Data Name": `[${str_tag_query}] PDB structure`, Value: dataset.arr_data_acc_pdb[ clicked_record.structure_id_query ].value + " (" + dataset.arr_data_acc_query[ clicked_record.query_accession ].value + " from " + clicked_record.query_structure_start + " to " + clicked_record.query_structure_end + ")", URL: url_pdb, style: "font-family:Arial" } );
            str_label_query = `${str_tag_query} (${str_id_pdb})`; // update protein id label (to increse interactivity)
            tag_pdb_query.href = url_pdb;
        } else {
            arr_data_clicked.push( { "Data Name": `[${str_tag_query}] PDB structure`, Value: "unavailable", URL: null, style: "font-family:Arial" } );
            tag_pdb_query.removeAttribute( 'href' );
        }
        tag_pdb_query.innerText = str_label_query
        tag_pdb_target.innerText = str_label_target

        arr_data_clicked.push( { "Data Name": "E-value (significance) of full-length alignment", Value: clicked_record.e_value, URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "identity (similarity) of full-length alignment", Value: clicked_record.identity, URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "number of redundant alignments", Value: clicked_record.duplicate_counts, URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "correl. coeffi. of accessibility (p-value)", Value: clicked_record.correl_coeffi_acc + " (" + String( clicked_record.correl_p_value_acc ) + ")", URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "correl. coeffi. of torsion angle (phi) (p-value)", Value: clicked_record.correl_coeffi_phi + " (" + String( clicked_record.correl_p_value_phi ) + ")", URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "correl. coeffi. of torsion angle (psi) (p-value)", Value: clicked_record.correl_coeffi_psi + " (" + String( clicked_record.correl_p_value_psi ) + ")", URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "score_blosum", Value: clicked_record.score_blosum, URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "score_blosum_weighted", Value: clicked_record.score_blosum_weighted, URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "score_similarity_ss8", Value: clicked_record.score_similarity_ss8, URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "prop_pdb_evidence_query", Value: clicked_record.prop_pdb_evidence_query, URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "prop_pdb_evidence_target", Value: clicked_record.prop_pdb_evidence_target, URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "sum_of_weights", Value: clicked_record.sum_of_weights, URL: null, style: "font-family:Arial" } );

        DrawD3Table_for_Record_Details( arr_data_clicked );
        document.getElementById( "title_d3_table_metrics" ).innerHTML = "B-Cell Cross-Reactivity Prediction data"; // update table title for 'd3_table_metrics' table
        document.getElementById( "footnote_d3_table_metrics" ).innerHTML = ""; // update table footnote for 'd3_table_metrics' table

        // draw interactive table displaying structural properties of aligned regions
        let alignment_BCellCrossReactivity = dataset.arr_data_alignment_query_target[ clicked_record.id_alignment ], structure_property_query_protein = dataset.arr_data_structural_property_query[ clicked_record.query_accession ], structure_property_target_protein = dataset.arr_data_structural_property_target[ clicked_record.target_accession ];
        let alignment_start = clicked_record.alignment_start - 1, alignment_end = clicked_record.alignment_end, query_start = clicked_record.query_start - 1, query_end = clicked_record.query_end, target_start = clicked_record.target_start - 1, target_end = clicked_record.target_end; // 1-based coordinates to 0-based coordinates // initial start and end positions
        let len_discarded_sequence_alignment = RetrieveDiscardedLength( alignment_BCellCrossReactivity.discarded_regions, alignment_start ), len_discarded_sequence_query = RetrieveDiscardedLength( structure_property_query_protein.discarded_regions, query_start ), len_discarded_sequence_target = RetrieveDiscardedLength( structure_property_target_protein.discarded_regions, target_start );
        alignment_start -= len_discarded_sequence_alignment; alignment_end -= len_discarded_sequence_alignment; query_start -= len_discarded_sequence_query; query_end -= len_discarded_sequence_query; target_start -= len_discarded_sequence_target; target_end -= len_discarded_sequence_target; // retrieve coordinates excluding discarded regions
        let query_aligned_sequence = alignment_BCellCrossReactivity.query_alignment__compact__for_web_application.slice( alignment_start, alignment_end ), target_aligned_sequence = alignment_BCellCrossReactivity.target_alignment__compact__for_web_application.slice( alignment_start, alignment_end );
        let len_alignment = query_aligned_sequence.length;
        let structure_property_query_sequence = { }, structure_property_target_sequence = { }; // retrieve and parse structural property of aligned sequences
        structure_property_query_sequence.rsa = Unpack_String_rsa( structure_property_query_protein[ "rsa_combined___ascii_encoding_1_character_from_33_to_126__from_0_to_1__for_web_application__compact__for_web_application" ].slice( query_start, query_end ) )
        structure_property_query_sequence.ss8 = Unpack_String_ss8( structure_property_query_protein[ "ss8_combined___ascii_encoding_1_character_from_33_to_41__states_G_H_I_E_B_T_S_C__compact__for_web_application" ].slice( query_start, query_end ) )
        structure_property_query_sequence.datatype = Unpack_String_datatype( structure_property_query_protein[ "rsa_datatype_combined___ascii_encoding_1_character_from_33_to_36__states_Pred_Model_PDB__compact__for_web_application" ].slice( query_start, query_end ) )
        if ( flag_structure_exist_for_query_sequence ) { 
            structure_property_query_sequence.phi = Unpack_String_torsion_angle( structure_property_query_protein[ ( object_data.flag.query_label_represents_target ) ? "phi_combined___ascii_encoding_1_character_from_33_to_126__from_-180_to_180__for_web_application__compact__for_web_application" : "phi___ascii_encoding_1_character_from_33_to_126__from_-180_to_180__for_web_application__compact__for_web_application" ].slice( query_start, query_end ) );
            structure_property_query_sequence.psi = Unpack_String_torsion_angle( structure_property_query_protein[ ( object_data.flag.query_label_represents_target ) ? "psi_combined___ascii_encoding_1_character_from_33_to_126__from_-180_to_180__for_web_application__compact__for_web_application" : "psi___ascii_encoding_1_character_from_33_to_126__from_-180_to_180__for_web_application__compact__for_web_application" ].slice( query_start, query_end ) );
            structure_property_query_sequence.structure_id = Unpack_String_structure_id( structure_property_query_protein[ "structure_id__compact__for_web_application" ] ).slice( query_start, query_end );
        }
        structure_property_target_sequence.rsa = Unpack_String_rsa( structure_property_target_protein[ "rsa_combined___ascii_encoding_1_character_from_33_to_126__from_0_to_1__for_web_application__compact__for_web_application" ].slice( target_start, target_end ) )
        structure_property_target_sequence.ss8 = Unpack_String_ss8( structure_property_target_protein[ "ss8_combined___ascii_encoding_1_character_from_33_to_41__states_G_H_I_E_B_T_S_C__compact__for_web_application" ].slice( target_start, target_end ) )
        structure_property_target_sequence.datatype = Unpack_String_datatype( structure_property_target_protein[ "rsa_datatype_combined___ascii_encoding_1_character_from_33_to_36__states_Pred_Model_PDB__compact__for_web_application" ].slice( target_start, target_end ) )
        if ( flag_structure_exist_for_target_sequence ) { 
            structure_property_target_sequence.phi = Unpack_String_torsion_angle( structure_property_target_protein[ "phi_combined___ascii_encoding_1_character_from_33_to_126__from_-180_to_180__for_web_application__compact__for_web_application" ].slice( target_start, target_end ) );
            structure_property_target_sequence.psi = Unpack_String_torsion_angle( structure_property_target_protein[ "psi_combined___ascii_encoding_1_character_from_33_to_126__from_-180_to_180__for_web_application__compact__for_web_application" ].slice( target_start, target_end ) );
            structure_property_target_sequence.structure_id = Unpack_String_structure_id( structure_property_target_protein[ "structure_id__compact__for_web_application" ] ).slice( target_start, target_end );
        }
        // represent structural property with color 
        structure_property_query_sequence.color_rsa = Color_for_rsa( structure_property_query_sequence.rsa )
        structure_property_query_sequence.color_ss8 = Color_for_ss8( structure_property_query_sequence.ss8 )
        structure_property_query_sequence.color_datatype = Color_for_datatype( structure_property_query_sequence.datatype )
        if ( flag_structure_exist_for_query_sequence ) { 
            structure_property_query_sequence.color_phi = Color_for_torsion_angle( structure_property_query_sequence.phi )
            structure_property_query_sequence.color_psi = Color_for_torsion_angle( structure_property_query_sequence.psi )
            structure_property_query_sequence.color_structure_id = Color_for_structure_id( structure_property_query_sequence.structure_id )
        }

        structure_property_target_sequence.color_rsa = Color_for_rsa( structure_property_target_sequence.rsa )
        structure_property_target_sequence.color_ss8 = Color_for_ss8( structure_property_target_sequence.ss8 )
        structure_property_target_sequence.color_datatype = Color_for_datatype( structure_property_target_sequence.datatype )
        if ( flag_structure_exist_for_target_sequence ) { 
            structure_property_target_sequence.color_phi = Color_for_torsion_angle( structure_property_target_sequence.phi )
            structure_property_target_sequence.color_psi = Color_for_torsion_angle( structure_property_target_sequence.psi )
            structure_property_target_sequence.color_structure_id = Color_for_structure_id( structure_property_target_sequence.structure_id )
        }

        // align retrieved structure property using the alignment
        structure_property_query_sequence = Align_Structural_Property( structure_property_query_sequence, query_aligned_sequence );
        structure_property_target_sequence = Align_Structural_Property( structure_property_target_sequence, target_aligned_sequence );
        structure_property_query_sequence.seq = query_aligned_sequence.split( "" ); // add aligned sequence to the data
        structure_property_target_sequence.seq = target_aligned_sequence.split( "" );
        let l_score_blosum = [ ], l_score_blosum_query = [ ], l_score_blosum_target = [ ], pos_target = clicked_record.target_start - 1, pos_query = clicked_record.query_start - 1;
        object_pdb_query.dict_index_alignment_to_pos_query = { }, object_pdb_target.dict_index_alignment_to_pos_target = { };
        for ( let i = 0; i < query_aligned_sequence.length; i ++ ) { 
            let score_blosum62 = Math.round( object_data.main.dict_blosum62[ query_aligned_sequence[ i ] + target_aligned_sequence[ i ] ] ), residue_query = query_aligned_sequence[ i ], residue_target = target_aligned_sequence[ i ]; // round the blosum score so that step become 1
            l_score_blosum.push( score_blosum62 );
            // retrieve blosum score for query and target sequence
            if ( residue_query == '-' ) {
                pos_target += 1;
                l_score_blosum_target.push( score_blosum62 );
                object_pdb_target.dict_index_alignment_to_pos_target[ i ] = pos_target;
            } else if ( residue_target == '-' ) {
                pos_query += 1;
                l_score_blosum_query.push( score_blosum62 );
                object_pdb_query.dict_index_alignment_to_pos_query[ i ] = pos_query;
            } else {
                pos_query += 1; pos_target += 1;
                l_score_blosum_query.push( score_blosum62 );
                l_score_blosum_target.push( score_blosum62 );
                object_pdb_target.dict_index_alignment_to_pos_target[ i ] = pos_target;
                object_pdb_query.dict_index_alignment_to_pos_query[ i ] = pos_query;
            }
        }
        let l_color_score_blosum = Color_for_score_blosum( l_score_blosum ), l_color_score_blosum_query = Color_for_score_blosum( l_score_blosum_query ), l_color_score_blosum_target = Color_for_score_blosum( l_score_blosum_target ); // retrieve colors for blosum scores

        console.log( "structural property query sequence:", structure_property_query_sequence );
        console.log( "structural property target sequence:", structure_property_target_sequence );
        // draw Plotly table for aligned sequences
        object_data_tableSequence.flag_data_type = "B-Cell";
        let colors = [ ], values = [ ], header = [ ], l_col = [ ];
        if ( flag_structure_exist_for_target_sequence ) { 
            l_col.push( ... [ `${str_tag_target}<br>structure_id`, `${str_tag_target}<br>psi`, `${str_tag_target}<br>phi` ] );
            values.push( ... [ structure_property_target_sequence.structure_id, structure_property_target_sequence.psi, structure_property_target_sequence.phi ] );
            colors.push( ... [ structure_property_target_sequence.color_structure_id, structure_property_target_sequence.color_psi, structure_property_target_sequence.color_phi ] );
        }
        l_col.push( ... [ `${str_tag_target}<br>datatype`, `${str_tag_target}<br>ss8`, `${str_tag_target}<br>rsa`, `${str_tag_target}<br>seq` ] );
        values.push( ... [ structure_property_target_sequence.datatype, structure_property_target_sequence.ss8, structure_property_target_sequence.rsa, structure_property_target_sequence.seq ] );
        colors.push( ... [ structure_property_target_sequence.color_datatype, structure_property_target_sequence.color_ss8, structure_property_target_sequence.color_rsa, ArrayFull( len_alignment, "#ffffff" ) ] );
        l_col.push( 'BLOSUM62' );
        values.push( l_score_blosum );
        colors.push( l_color_score_blosum );
        l_col.push( ... [ `${str_tag_query}<br>seq`, `${str_tag_query}<br>rsa`, `${str_tag_query}<br>ss8`, `${str_tag_query}<br>datatype` ] );
        values.push( ... [ structure_property_query_sequence.seq, structure_property_query_sequence.rsa, structure_property_query_sequence.ss8, structure_property_query_sequence.datatype ] );
        colors.push( ... [ ArrayFull( len_alignment, "#ffffff" ), structure_property_query_sequence.color_rsa, structure_property_query_sequence.color_ss8, structure_property_query_sequence.color_datatype ] );
        if ( flag_structure_exist_for_query_sequence ) { 
            l_col.push( ... [ `${str_tag_query}<br>phi`, `${str_tag_query}<br>psi`, `${str_tag_query}<br>structure_id` ] );
            values.push( ... [ structure_property_query_sequence.phi, structure_property_query_sequence.psi, structure_property_query_sequence.structure_id ] );
            colors.push( ... [ structure_property_query_sequence.color_phi, structure_property_query_sequence.color_psi, structure_property_query_sequence.color_structure_id ] );
        }
        for ( let i = 0; i < l_col.length; i ++ ) { header.push( [ "<b>" + l_col[ i ] + "</b>" ] ); } // build header from 'l_col'
        let data = [{
            type: 'table', 
            header: { values: header, align: "center", height: 30, line: {width: 1, color: '#506784'}, fill: {color: '#f0f0f0'}, font: {family: "Arial", size: 12, color: "black"} },
            cells: {values: values, align: "center", height: 20, line: {color: colors, width: 1}, fill: {color: colors }, font: {family: "Arial", size: 12, color: ["#3d3d3d"] }}
        }]

        document.getElementById( "plotly_table_sequence" ).style.height = String( Math.min( 20 * int_n_residues_per_window_table_sequence + 30 + 10, parseInt( l_score_blosum.length * 20 + 30 + 10 ) ) ) + "px" // set height of table according to the length of alignment # max height is 640
        object_data_tableSequence.len_alignment = l_score_blosum.length; // retrieve the length of the alignment
        str_jquery_container = "#container_plotly_table_sequence";
        if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { Plotly.newPlot( tableSequence, data, lodash.cloneDeep( layout_tableSequence ), config_MolecularMimicryMap ); Add_Click_Callback_Aligned_Sequence_Table( ); // draw Plotly plot synchronously if the container is currently shown
        } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { Plotly.newPlot( tableSequence, data, lodash.cloneDeep( layout_tableSequence ), config_MolecularMimicryMap ); Add_Click_Callback_Aligned_Sequence_Table( ); } ); } // draw Plotly plot once the container is shown if the container is currently hidden

        // Render molecular structures using the Mol* JS application
        str_jquery_container = "#container_PDB";
        let pos_protein = 0, pos_pdb = 0;
        if ( flag_structure_exist_for_query_sequence ) { 
            object_pdb_query = Object.assign( object_pdb_query, dataset.arr_data_acc_pdb[ clicked_record.structure_id_query ] );
            object_pdb_query.id_chain = String( object_pdb_query.id_chain ) // 'auth_asym_id' should be a string
            object_pdb_query.start_pdb = clicked_record.structure_id_query_start;
            object_pdb_query.end_pdb = clicked_record.structure_id_query_end;
            object_pdb_query.alignment = { data: dataset.arr_data_alignment_query_pdb[ clicked_record.id_alignment_structure_query ], start: clicked_record.alignment_structure_query_start - 1, end: clicked_record.alignment_structure_query_end } // retrieve alignment data // 0-based coordinates
            object_pdb_query.alignment.data.len_discarded_sequence = RetrieveDiscardedLength( object_pdb_query.alignment.data.discarded_regions, object_pdb_query.alignment.start );
            object_pdb_query.alignment.start -= object_pdb_query.alignment.data.len_discarded_sequence;
            object_pdb_query.alignment.end -= object_pdb_query.alignment.data.len_discarded_sequence;
            object_pdb_query.aligned_sequence_pdb = object_pdb_query.alignment.data.target_alignment__compact__for_web_application.slice( object_pdb_query.alignment.start, object_pdb_query.alignment.end );
            object_pdb_query.aligned_sequence_protein = object_pdb_query.alignment.data.query_alignment__compact__for_web_application.slice( object_pdb_query.alignment.start, object_pdb_query.alignment.end );
            object_pdb_query.start_protein = clicked_record.query_structure_start;
            object_pdb_query.end_protein = clicked_record.query_structure_end;
            object_pdb_query.l_color_score_blosum_protein = l_color_score_blosum_query.slice( clicked_record.query_start - clicked_record.query_structure_start, l_color_score_blosum_query.length - ( clicked_record.query_end - clicked_record.query_structure_end ) );

            object_pdb_query.dict_pos_query_to_pos_pdb_query = { }, object_pdb_query.dict_index_alignment_to_pos_pdb_query = { };
            pos_protein = - 1, pos_pdb = object_pdb_query.start_pdb - 1, object_pdb_query.l_color_score_blosum_pdb = [ ];
            for ( let i = 0; i < object_pdb_query.aligned_sequence_pdb.length; i ++ ) {
                if ( object_pdb_query.aligned_sequence_pdb[ i ] == '-' ) { 
                    pos_protein += 1;
                    object_pdb_query.dict_pos_query_to_pos_pdb_query[ pos_protein + object_pdb_query.start_protein ] = pos_pdb;
                }
                else if ( object_pdb_query.aligned_sequence_protein[ i ] == '-' ) { 
                    pos_pdb += 1;
                    object_pdb_query.l_color_score_blosum_pdb.push( null );
                } // if there is a gap in the protein (so the residue in pdb does not exist in the protein sequence, push null value representing an invalid color)
                else { 
                    pos_protein += 1; pos_pdb += 1;
                    object_pdb_query.l_color_score_blosum_pdb.push( object_pdb_query.l_color_score_blosum_protein[ pos_protein ] );
                    object_pdb_query.dict_pos_query_to_pos_pdb_query[ pos_protein + object_pdb_query.start_protein ] = pos_pdb;
                }
            }
            for ( let i = 0; i < object_data_tableSequence.len_alignment; i ++ ) {
                object_pdb_query.dict_index_alignment_to_pos_pdb_query[ i ] = object_pdb_query.dict_pos_query_to_pos_pdb_query[ object_pdb_query.dict_index_alignment_to_pos_query[ i ] ];
            }
            object_pdb_query.option_update = { landscape: true, bgColor: {r:255,g:255,b:255}, hideControls: true, hideStructure: [ 'water', 'carbs' ] };
            if ( object_pdb_query.value.includes( "_source_" ) ) { object_pdb_query.option_update.customData = { url: object_data.file.base_url + "data/custom_cif/" + object_pdb_query.value + ".cif", format: 'cif', binary: false }; } // if structure is structural model, retrieve data from github
            else { // use coordinate server to retrieve coordinates of a specific chain if the structure belongs to RCSB PDB db
                object_pdb_query.option_update.customData = { url: "https://www.ebi.ac.uk/pdbe/coordinates/" + object_pdb_query.id_pdb + "/chains?entityId=" + object_pdb_query.id_entity + "&authAsymId=" + object_pdb_query.id_chain + "&encoding=bcif", binary: true, format: 'cif' }; 
                if ( object_pdb_query.id_model != null ) { object_pdb_query.option_update.customData.url += "&modelId=" + object_pdb_query.id_model; } // use id_model to retrieve specific coordinates if it is available
            } 
            object_pdb_query.selection_showing_side_chain = [ ], object_pdb_query.selection = [ ];
            for ( let i = 0; i < object_pdb_query.l_color_score_blosum_pdb.length; i ++ ) {
                let color = object_pdb_query.l_color_score_blosum_pdb[ i ], pos = object_pdb_query.start_pdb + i;
                if ( color === null ) { continue; }
                object_pdb_query.selection_showing_side_chain.push( { auth_asym_id: object_pdb_query.id_chain, start_residue_number: pos, end_residue_number: pos, sideChain: true, color: color } );
                object_pdb_query.selection.push( { auth_asym_id: object_pdb_query.id_chain, start_residue_number: pos, end_residue_number: pos, color: color } );
            }
            object_pdb_query.bool_flag_selected = false, object_pdb_query.bool_flag_focused = false; // set viewer setting
            if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { 
                pdbqueryProtein.visual.update( object_pdb_query.option_update );
                MolStarRenderCompletePromise( pdbqueryProtein ).then( Select_View_of_PDB_query_Protein ); // render coordinates synchronously if the container is currently shown // then select the subsequence once loading is completed
            } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { 
                pdbqueryProtein.visual.update( object_pdb_query.option_update );
                MolStarRenderCompletePromise( pdbqueryProtein ).then( Select_View_of_PDB_query_Protein );
            } ); } // render coordinates once the container is shown if the container is currently hidden // then select the subsequence once loading is completed
        } else {  // show dummy if coordinates are not available
            if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { // render coordinates synchronously if the container is currently shown
                pdbqueryProtein.visual.update( option_initialization_molstar );
            } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { 
                pdbqueryProtein.visual.update( option_initialization_molstar );
            } ); } // render coordinates once the container is shown if the container is currently hidden
        }
        if ( flag_structure_exist_for_target_sequence ) { 
            object_pdb_target = Object.assign( object_pdb_target, dataset.arr_data_acc_pdb[ clicked_record.structure_id_target ] );
            object_pdb_target.id_chain = String( object_pdb_target.id_chain ) // 'auth_asym_id' should be a string
            object_pdb_target.start_pdb = clicked_record.structure_id_target_start;
            object_pdb_target.end_pdb = clicked_record.structure_id_target_end;
            object_pdb_target.alignment = { data: dataset.arr_data_alignment_target_pdb[ clicked_record.id_alignment_structure_target ], start: clicked_record.alignment_structure_target_start - 1, end: clicked_record.alignment_structure_target_end } // retrieve alignment data // 0-based coordinates
            object_pdb_target.alignment.data.len_discarded_sequence = RetrieveDiscardedLength( object_pdb_target.alignment.data.discarded_regions, object_pdb_target.alignment.start );
            object_pdb_target.alignment.start -= object_pdb_target.alignment.data.len_discarded_sequence;
            object_pdb_target.alignment.end -= object_pdb_target.alignment.data.len_discarded_sequence;
            object_pdb_target.aligned_sequence_pdb = object_pdb_target.alignment.data.target_alignment__compact__for_web_application.slice( object_pdb_target.alignment.start, object_pdb_target.alignment.end );
            object_pdb_target.aligned_sequence_protein = object_pdb_target.alignment.data.target_alignment__compact__for_web_application.slice( object_pdb_target.alignment.start, object_pdb_target.alignment.end );
            object_pdb_target.start_protein = clicked_record.target_structure_start;
            object_pdb_target.end_protein = clicked_record.target_structure_end;
            object_pdb_target.l_color_score_blosum_protein = l_color_score_blosum_target.slice( clicked_record.target_start - clicked_record.target_structure_start, l_color_score_blosum_target.length - ( clicked_record.target_end - clicked_record.target_structure_end ) );

            object_pdb_target.dict_pos_target_to_pos_pdb_target = { }, object_pdb_target.dict_index_alignment_to_pos_pdb_target = { };
            pos_protein = - 1, pos_pdb = object_pdb_target.start_pdb - 1, object_pdb_target.l_color_score_blosum_pdb = [ ];
            for ( let i = 0; i < object_pdb_target.aligned_sequence_pdb.length; i ++ ) {
                if ( object_pdb_target.aligned_sequence_pdb[ i ] == '-' ) { 
                    pos_protein += 1;
                    object_pdb_target.dict_pos_target_to_pos_pdb_target[ pos_protein + object_pdb_target.start_protein ] = pos_pdb;
                }
                else if ( object_pdb_target.aligned_sequence_protein[ i ] == '-' ) { 
                    pos_pdb += 1;
                    object_pdb_target.l_color_score_blosum_pdb.push( null );
                } // if there is a gap in the protein (so the residue in pdb does not exist in the protein sequence, push null value representing an invalid color)
                else { 
                    pos_protein += 1; pos_pdb += 1;
                    object_pdb_target.l_color_score_blosum_pdb.push( object_pdb_target.l_color_score_blosum_protein[ pos_protein ] );
                    object_pdb_target.dict_pos_target_to_pos_pdb_target[ pos_protein + object_pdb_target.start_protein ] = pos_pdb;
                }
            }
            for ( let i = 0; i < object_data_tableSequence.len_alignment; i ++ ) {
                object_pdb_target.dict_index_alignment_to_pos_pdb_target[ i ] = object_pdb_target.dict_pos_target_to_pos_pdb_target[ object_pdb_target.dict_index_alignment_to_pos_target[ i ] ];
            }
            object_pdb_target.option_update = { landscape: true, bgColor: {r:255,g:255,b:255}, hideControls: true, hideStructure: [ 'water', 'carbs' ] };
            if ( object_pdb_target.value.includes( "_source_" ) ) { object_pdb_target.option_update.customData = { url: object_data.file.base_url + "data/custom_cif/" + object_pdb_target.value + ".cif", format: 'cif', binary: false }; } // if structure is structural model, retrieve data from github
            else { // use coordinate server to retrieve coordinates of a specific chain if the structure belongs to RCSB PDB db
                object_pdb_target.option_update.customData = { url: "https://www.ebi.ac.uk/pdbe/coordinates/" + object_pdb_target.id_pdb + "/chains?entityId=" + object_pdb_target.id_entity + "&authAsymId=" + object_pdb_target.id_chain + "&encoding=bcif", binary: true, format: 'cif' }; 
                if ( object_pdb_target.id_model != null ) { object_pdb_target.option_update.customData.url += "&modelId=" + object_pdb_target.id_model; } // use id_model to retrieve specific coordinates if it is available
            } 
            object_pdb_target.selection_showing_side_chain = [ ], object_pdb_target.selection = [ ];
            for ( let i = 0; i < object_pdb_target.l_color_score_blosum_pdb.length; i ++ ) {
                let color = object_pdb_target.l_color_score_blosum_pdb[ i ], pos = object_pdb_target.start_pdb + i;
                if ( color === null ) { continue; }
                object_pdb_target.selection_showing_side_chain.push( { auth_asym_id: object_pdb_target.id_chain, start_residue_number: pos, end_residue_number: pos, sideChain: true, color: color } );
                object_pdb_target.selection.push( { auth_asym_id: object_pdb_target.id_chain, start_residue_number: pos, end_residue_number: pos, color: color } );
            }
            object_pdb_target.bool_flag_selected = false, object_pdb_target.bool_flag_focused = false; // set viewer setting
            if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { 
                pdbtargetProtein.visual.update( object_pdb_target.option_update );
                MolStarRenderCompletePromise( pdbtargetProtein ).then( Select_View_of_PDB_target_Protein ); // render coordinates synchronously if the container is currently shown // then select the subsequence once loading is completed
            } else { 
                BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { 
                    pdbtargetProtein.visual.update( object_pdb_target.option_update );
                    MolStarRenderCompletePromise( pdbtargetProtein ).then( Select_View_of_PDB_target_Protein );
                } );
            } // render coordinates once the container is shown if the container is currently hidden // then select the subsequence once loading is completed
        } else {  // show dummy if coordinates are not available
            if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { 
                pdbtargetProtein.visual.update( option_initialization_molstar ); // render coordinates synchronously if the container is currently shown
            } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { 
                pdbtargetProtein.visual.update( option_initialization_molstar );
            } ); } // render coordinates once the container is shown if the container is currently hidden
        }
        document.getElementById( "description_clicked_position__table_sequence" ).innerHTML = "";
    }
    
    var color_pdb_highlight = {r:255,g:255,b:0};
    function Highlight_PDB_Residue__Click_Callback__Aligned_Sequence_Table( event ) {
        let height_cell_value = 20, height_cell_header = 47, n_extra_pixels = 4; // it seems a couple of extra pixels added to the top of the slider. To account this, the silder height will be expanded by 2 * this_value // height cell header (1 line = 30px, 2 line = 47px)
        let str_description = "";
        let object_slider_boundary = object_data_tableSequence.object_slider.getBoundingClientRect( );
        let object_table_boundary = tableSequence.getBoundingClientRect( );
        object_data_tableSequence.object_slider_boundary = object_slider_boundary;
        object_data_tableSequence.object_table_boundary = object_table_boundary;
        object_data_tableSequence.mouse_event = event;
        object_data_tableSequence.table_body_range = { top: object_table_boundary.top + height_cell_header + layout_tableSequence.margin.t, bottom: object_table_boundary.bottom - layout_tableSequence.margin.b };
        object_data_tableSequence.table_body_range.height = object_data_tableSequence.table_body_range.bottom - object_data_tableSequence.table_body_range.top;
        object_data_tableSequence.table_body_range.n_rows_per_window = object_data_tableSequence.table_body_range.height / height_cell_value;
        if ( Math.round( object_data_tableSequence.table_body_range.n_rows_per_window ) < object_data_tableSequence.len_alignment ) { // if slider is present, calculate hidden height above the currently shown window.
            object_data_tableSequence.silder_range = { top: object_data_tableSequence.table_body_range.top + n_extra_pixels, bottom: object_data_tableSequence.table_body_range.bottom - object_slider_boundary.height - n_extra_pixels }; 
            object_data_tableSequence.silder_relative_position = ( object_slider_boundary.top - object_data_tableSequence.silder_range.top ) / ( object_data_tableSequence.silder_range.bottom - object_data_tableSequence.silder_range.top ); 
            object_data_tableSequence.hidden_height = ( object_data_tableSequence.len_alignment - object_data_tableSequence.table_body_range.n_rows_per_window ) * height_cell_value * object_data_tableSequence.silder_relative_position;
        } else {
            object_data_tableSequence.hidden_height = 0;
        }
        object_data_tableSequence.clicked_pos_alignment = parseInt( ( object_data_tableSequence.mouse_event.clientY - object_data_tableSequence.table_body_range.top + object_data_tableSequence.hidden_height ) / height_cell_value );
        str_description += "position in the alignment: " + String( object_data_tableSequence.clicked_pos_alignment );
        // retrieve position of query and target protein structure of the clicked residue in the alignment table
        object_data_tableSequence.clicked_pos_pdb_query = parseInt( object_pdb_query.dict_index_alignment_to_pos_pdb_query[ object_data_tableSequence.clicked_pos_alignment ] ); 
        object_data_tableSequence.clicked_pos_pdb_target = parseInt( object_pdb_target.dict_index_alignment_to_pos_pdb_target[ object_data_tableSequence.clicked_pos_alignment ] );
        object_data_tableSequence.clicked_pos_query = parseInt( object_pdb_query.dict_index_alignment_to_pos_query[ object_data_tableSequence.clicked_pos_alignment ] ); 
        object_data_tableSequence.clicked_pos_target = parseInt( object_pdb_target.dict_index_alignment_to_pos_target[ object_data_tableSequence.clicked_pos_alignment ] );

        if( ! isNaN( object_data_tableSequence.clicked_pos_pdb_query ) ) {
            pdbqueryProtein.visual.highlight( { data: [ { auth_asym_id: object_pdb_query.id_chain, start_residue_number: object_data_tableSequence.clicked_pos_pdb_query, end_residue_number: object_data_tableSequence.clicked_pos_pdb_query } ], color: color_pdb_highlight } )
            str_description += ", position on the query protein (structure): " + String( object_data_tableSequence.clicked_pos_query ) + " (" + String( object_data_tableSequence.clicked_pos_pdb_query ) + ")";
        }
        if( ! isNaN( object_data_tableSequence.clicked_pos_pdb_target ) ) {
            pdbtargetProtein.visual.highlight( { data: [ { auth_asym_id: object_pdb_target.id_chain, start_residue_number: object_data_tableSequence.clicked_pos_pdb_target, end_residue_number: object_data_tableSequence.clicked_pos_pdb_target } ], color: color_pdb_highlight } )
            str_description += ", position on the target protein (structure): " + String( object_data_tableSequence.clicked_pos_target ) + " (" + String( object_data_tableSequence.clicked_pos_pdb_target ) + ")";
        }
        document.getElementById( "description_clicked_position__table_sequence" ).innerHTML = str_description; // update description
        console.log( "[Add_Click_Callback_Aligned_Sequence_Table] position in alignment is : ", object_data_tableSequence.clicked_pos_alignment );
    }
    function Add_Click_Callback_Aligned_Sequence_Table( ) {
        if ( "removeAllListeners" in tableSequence ) { tableSequence.removeAllListeners( "click" ); } // remove previous listeners if a listener exists
        object_data_tableSequence.object_slider = $( "#plotly_table_sequence g.table g.scrollbar-slider" )[ 0 ]; // retrieve slider
        tableSequence.addEventListener( "click", Highlight_PDB_Residue__Click_Callback__Aligned_Sequence_Table ); // add callbacks
    }
    function Responsive_Column_Width_Aligned_Sequence_Table_TCellCrossReactivity( event ) { // a callback function to adjust Aligned_Sequence_Table for TCellCrossReactivity record when web page width was changed
        if ( object_data_tableSequence.flag_data_type != "T-Cell" ) { return; } // only resize table when tableSequence object is for T-Cell CrossReactivity record
        let width_col_seq = 100, width_max_col_score = 300; // width of columns containing a.a. sequence in pixels
        let width_window = tableSequence.getBoundingClientRect( ).width;
        arr_width_col = nj.array( [ width_col_seq, Math.min( width_window - 2 * width_col_seq, width_max_col_score ), width_col_seq ] );
        let margin_horizontal = ( width_window - arr_width_col.sum( ) ) / 2;
        object_data_tableSequence.data[ 0 ].columnwidth = arr_width_col.divide( arr_width_col.sum( ) ).tolist( );
        Plotly.newPlot( tableSequence, object_data_tableSequence.data, { margin: { l: Math.max( margin_horizontal - 7.5, 0 ), r: Math.max( margin_horizontal + 7.5, 15 ), t: layout_tableSequence.margin.t, b: layout_tableSequence.margin.b } }, config_MolecularMimicryMap );
    }
    // trigger functions when window size changes
    $(window).resize( function( ) {
        Responsive_Column_Width_Aligned_Sequence_Table_TCellCrossReactivity( );
    });
    function Retrieve_Selection_Mode_Using_Keydown_Status_VaccineDesign( ) { // retrieve selection mode using keydown status
        let key_include = 'a', key_exclude = 'r';
        let bool_flag_include = key_include in object_data_keydown.dict_status && object_data_keydown.dict_status[ key_include ] != 'keyup';
        let bool_flag_exclude = key_exclude in object_data_keydown.dict_status && object_data_keydown.dict_status[ key_exclude ] != 'keyup';
        if ( bool_flag_include && ! bool_flag_exclude ) { return "Include"; }
        else if ( ! bool_flag_include && bool_flag_exclude ) { return "Exclude"; }
        else { return "Show_Info"; }
    }
    
    function Set_Visibility_of_Consensus_Protein_Sequence( ) { // set visibility of consensus protein sequence based on number of residues displayed on the window
        object_data.plot.consensus_sequence.window_width = plotMolecularMimicryMap.offsetWidth; // retrieve the width of the "molecular mimicry map" plot in number of pixels 
        let x_range = plotMolecularMimicryMap.layout.xaxis.range;
        object_data.plot.consensus_sequence.n_residues_displayed = x_range[ 1 ] - x_range[ 0 ]; // retrieve number of plotted residues
        object_data.plot.consensus_sequence.show = object_data.plot.consensus_sequence.n_residues_displayed / object_data.plot.consensus_sequence.window_width <= ( 160 / 1270 ) // if more than 160residues/1270pixels are displayed, hide the protein sequence trace
        let index_trace = object_data.plot.consensus_sequence.index_trace_start; // only trace for 'object_data.plot.consensus_sequence' is consensus sequence trace
        if ( plotMolecularMimicryMap.data[ index_trace ].visible != object_data.plot.consensus_sequence.show ) { // if current visibility is different with previous visibility, update the visibility
            Plotly.restyle( plotMolecularMimicryMap, { visible: object_data.plot.consensus_sequence.show }, index_trace );
        }
    }
    // Modification of plots using buttons and functions
    function Toggle_Hovermode_MolecularMimicryMap( ) { // toggle hovermode
        console.log( object_plot_MolecularMimicryMap.hovermode );
        object_plot_MolecularMimicryMap.hovermode = object_plot_MolecularMimicryMap.hovermode == false ? "closest" : false; // toggle hovermode
        if ( ! ( "data" in plotMolecularMimicryMap ) ) { return; } // if a plot has not been drawn, do not modify layout
        let hovermode_previous = plotMolecularMimicryMap.data[ 0 ].hovermode, hovermode_current = object_plot_MolecularMimicryMap.hovermode;
        console.log( "hovermode is being set to ", hovermode_current, "..." );
        if ( ( hovermode_previous == undefined && hovermode_current == false ) || ( hovermode_previous != hovermode_current ) ) { Plotly.relayout( plotMolecularMimicryMap, { hovermode: hovermode_current } ); }
        console.log( "done." );
    }
    function Toggle_ProteinAnnotation_MolecularMimicryMap( flag_function_call_within_script = null ) { // toggle SARS-CoV-2 targetProteinAnnotation
        // if this function is called within another script and not by onclick event, set 'flag_function_call_within_script' to true
        object_data.plot.annotation_protein.show = ! $( "#toggle_ProteinAnnotation_MolecularMimicryMap" ).hasClass( "active" ); // inverse the flag (works in practice when called by the onclick event)
        if ( flag_function_call_within_script == true ) {
            object_data.plot.annotation_protein.show = ! object_data.plot.annotation_protein.show; // if the function is called by another script, do not inverse the flag
        }
        if ( object_data.plot.annotation_protein.data.length > 0 ) { Plotly.restyle( plotMolecularMimicryMap, { visible: object_data.plot.annotation_protein.show }, nj.arange( object_data.plot.annotation_protein.index_trace_start, object_data.plot.consensus_sequence.index_trace_end ).tolist( ) ); } // set visibility based on the toggled flag for the visibiligy of the track
        Set_Visibility_of_Consensus_Protein_Sequence( ); // set visibility of consensus protein sequence
    }
    function Toggle_IEDB_Epitope_MolecularMimicryMap( flag_function_call_within_script = null ) {
        let dict_data = object_data.plot.iedb_epitope.dict_data,
            n_residues = object_data.plot.consensus_sequence.accumulated_length;
        object_data.plot.iedb_epitope.show = ! $( "#toggle_iedb_epitope_MolecularMimicryMap" ).hasClass( "active" ); // set visibility of IEDB epitopes of SARS-CoV-2 // inversing the toggled status works in practice (modification class label takes time)
        if ( flag_function_call_within_script == true ) {
            object_data.plot.iedb_epitope.show = ! object_data.plot.iedb_epitope.show; // if the function is called by another script, do not inverse the flag
        }
        if ( ! object_data.flag.iedb_epitope_drawn ) {
            // retrieve a trace IEDB epitope records of target proteins
            console.log( '[Toggle_IEDB_Epitope_MolecularMimicryMap] Processing of data started' );
            // initialize 
            let l_start = [ ],
                l_end = [ ],
                float_floor = - 4, // floor of the trace
                float_height = 1; // height of the trace
            
            if ( object_data.flag.alignment_to_target ) {
                let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // use first dataset for target protein annotations
                l_start = nj.array( dict_data[ "start_accumulated" ] ).subtract( 1 ).tolist( ), 
                l_end = dict_data[ "end_accumulated" ]; // 0-based coordinate 
                dict_data[ "start" ] = nj.array( ArrayMap( l_start, object_data.plot.consensus_sequence.dict_accumulated_coord_to_individual_coord ) ).add( 1 ).tolist( ); // 1-based coordinates
                dict_data[ "end" ] = ArrayMap( l_end, object_data.plot.consensus_sequence.dict_accumulated_coord_to_individual_coord );
                dict_data[ "protein_name" ] = ArrayApply( dict_data[ "accession_representative" ], acc => dataset.arr_data_acc_target_representative[ acc ].name );
                float_floor = - 4, 
                float_height = 1;  
            } else {
                dict_data[ "start" ] = dict_data[ "start_query" ].map( ( start ) => { return start - 1; } ); 
                dict_data[ "end" ] = dict_data[ "end_query" ]; // 0-based coordinate 
                l_start = dict_data[ "start" ];
                l_end = dict_data[ "end" ];
                dict_data[ "protein_name" ] = dict_data[ "humen_gene_symbol" ];
                float_floor = - 2.5,
                float_height = 1.5;
            }
            dict_data[ "error_x" ] = nj.array( l_end ).subtract( l_start ).divide( 2 ).tolist( );
            let arr_y = nj.array( ArrayCap( nj.array( dict_data[ "number_of_positive_B_cell_assay" ] ).add( dict_data[ "number_of_positive_T_cell_assay" ] ).multiply( dict_data[ "percent_identity" ] ).divide( 100 ).tolist( ), 5 ) ); // retrieve combined score for IEDB epitopes (y-axis)
            dict_data[ "x" ] = nj.array( l_start ).add( l_end ).divide( 2 ).tolist( );
            dict_data[ "y" ] = arr_y.divide( arr_y.max( ) / ( 0.75 * float_height ) ).subtract( 0.05 - float_floor ).tolist( );
            object_data.plot.iedb_epitope.dict_data = dict_data;
            
            object_data.plot.iedb_epitope.hovertemplate = ["IEDB Epitope #%{customdata[0]:.0f}",
                                                            "        seq: %{customdata[6]}",
                                                            "<b>%{customdata[5]}</b> from <b>%{customdata[3]:.0f}</b> to <b>%{customdata[4]:.0f}</b>",
                                                            "(%{customdata[7]:.0f}% identical, %{customdata[8]:.0f} mismatch, %{customdata[9]:.0f} gaps)",
                                                            "",
                                                            "number of positive B-cell assays: <b>%{customdata[1]:.0f}</b>",
                                                            "number of positive T-cell assays: <b>%{customdata[2]:.0f}</b>",
                                                            "<extra></extra>" ].join( "<br>" );
            object_data.plot.iedb_epitope.customdata = ArrayTranspose( DictArrayToArray( dict_data, [ "accession_iedb", "number_of_positive_B_cell_assay", "number_of_positive_T_cell_assay", "start", "end", "protein_name", "iedb_epitope_sequence", "percent_identity", "mismatch", "gapopen" ] ) );
            
    
            // retrieve mask for IEDB epitopes with b-cell assay count larger than t-cell assay count
            let l_b_cell_assay_count = dict_data[ "number_of_positive_B_cell_assay" ], 
                l_t_cell_assay_count = dict_data[ "number_of_positive_T_cell_assay" ], 
                l_bool_flag_b_cell_epitope = [ ]; 
            for ( let i = 0; i < l_b_cell_assay_count.length; i ++ ) { l_bool_flag_b_cell_epitope.push( l_b_cell_assay_count[ i ] >= l_t_cell_assay_count[ i ] ); }
            object_data.plot.iedb_epitope.l_bool_flag_b_cell_epitope = l_bool_flag_b_cell_epitope;
            object_data.plot.iedb_epitope.l_bool_flag_t_cell_epitope = ArrayBoolNOT( l_bool_flag_b_cell_epitope );

            let trace_iedb_epitope_b_cell_assay = { visible: object_data.plot.iedb_epitope.show, name: "IEDB_Epitopes__Positive_B_Cell_Assays", x: ArrayBooleanIndexing( dict_data[ "x" ], object_data.plot.iedb_epitope.l_bool_flag_b_cell_epitope ), y: ArrayBooleanIndexing( dict_data[ "y" ], object_data.plot.iedb_epitope.l_bool_flag_b_cell_epitope ), type: 'scattergl', mode: "markers", error_x: { type: 'data', array: ArrayBooleanIndexing( dict_data[ "error_x" ], object_data.plot.iedb_epitope.l_bool_flag_b_cell_epitope ), visible: true, width: 0, thickness: 1 }, customdata: ArrayBooleanIndexing( object_data.plot.iedb_epitope.customdata, object_data.plot.iedb_epitope.l_bool_flag_b_cell_epitope ), hovertemplate: object_data.plot.iedb_epitope.hovertemplate, showlegend: false, marker: { symbol: "star-open", size: 10, opacity: 0.5, line: { width: 2 }, color: "#00ff08" } };
            let trace_iedb_epitope_t_cell_assay = { visible: object_data.plot.iedb_epitope.show, name: "IEDB_Epitopes__Positive_T_Cell_Assays", x: ArrayBooleanIndexing( dict_data[ "x" ], object_data.plot.iedb_epitope.l_bool_flag_t_cell_epitope ), y: ArrayBooleanIndexing( dict_data[ "y" ], object_data.plot.iedb_epitope.l_bool_flag_t_cell_epitope ), type: 'scattergl', mode: "markers", error_x: { type: 'data', array: ArrayBooleanIndexing( dict_data[ "error_x" ], object_data.plot.iedb_epitope.l_bool_flag_t_cell_epitope ), visible: true, width: 0, thickness: 1 }, customdata: ArrayBooleanIndexing( object_data.plot.iedb_epitope.customdata, object_data.plot.iedb_epitope.l_bool_flag_t_cell_epitope ), hovertemplate: object_data.plot.iedb_epitope.hovertemplate, showlegend: false, marker: { symbol: "star-open", size: 10, opacity: 0.5, line: { width: 2 }, color: "#f003fc" } };
            let trace_iedb_epitope_lower_bound = { x : [ 0, n_residues ], y : [ float_floor + float_height - 0.01, float_floor + float_height - 0.01 ], type : "scattergl", mode : 'lines', line : { color: '#000000', width: 1 }, showlegend : false, name: "iedb_epitope__lower_bound" }, trace_iedb_epitope_upper_bound = { x : [ 0, n_residues ], y : [ float_floor, float_floor ], type : "scattergl", mode : 'lines', line : { color: '#000000', width: 1 }, showlegend : false, name: "iedb_epitope__upper_bound" };
            object_data.plot.iedb_epitope.data = [ trace_iedb_epitope_lower_bound, trace_iedb_epitope_upper_bound , trace_iedb_epitope_b_cell_assay, trace_iedb_epitope_t_cell_assay ];

            // draw IEDB epitopes of target with positive assays
            console.log( '[Toggle_IEDB_Epitope_MolecularMimicryMap] plotting "IEDB epitopes of SARS-CoV-2 target" traces...' )
            object_data.plot.iedb_epitope.index_trace_start = plotMolecularMimicryMap.data.length; // record index_start and index_end of traces
            Plotly.addTraces( plotMolecularMimicryMap, lodash.cloneDeep( object_data.plot.iedb_epitope.data ) );
            object_data.plot.iedb_epitope.index_trace_end = plotMolecularMimicryMap.data.length;
            for( let i = 0; i < plotMolecularMimicryMap.data.length; i ++ ) { dict_name_plot_to_trace_index__MolecularMimicryMap[ plotMolecularMimicryMap.data[ i ].name ] = i; } // update trace_name - index mapping
            object_data.flag.iedb_epitope_drawn = true; // update the flag
        }
        if ( object_data.plot.iedb_epitope.data.length > 0 ) { 
            Plotly.restyle( plotMolecularMimicryMap, { visible: object_data.plot.iedb_epitope.show }, nj.arange( object_data.plot.iedb_epitope.index_trace_start, object_data.plot.iedb_epitope.index_trace_end ).tolist( ) );
        } // set visibility based on the toggled flag for the visibiligy of the track
    }
    async function Toggle_VaccineDesign_MolecularMimicryMap( ) {
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        dataset.vaccine_design.show = ! $( "#toggle_vaccine_design_MolecularMimicryMap" ).hasClass( "active" ); // set visibility of the vaccine design trace // inversing the read toggled status works in practice
        if ( ! dataset.flag.vaccine_design_optivax_loaded ) {
            console.log( "[Toggle_VaccineDesign_MolecularMimicryMap] downloading and drawing peptide vaccine candidates" );
            await LoadOptiVax( );
            object_data.flag.vaccine_design_drawn = true;
        } else if ( ! object_data.flag.vaccine_design_drawn ) {
            Draw_DesignedVaccineTrace( "new_trace" );
            object_data.flag.vaccine_design_drawn = true;
        }
        if ( dataset.vaccine_design.data.length > 0 ) { 
            Plotly.restyle( plotMolecularMimicryMap, { visible: dataset.vaccine_design.show }, nj.arange( dataset.vaccine_design.index_trace_start, dataset.vaccine_design.index_trace_end ).tolist( ) );
        } // set visibility based on the toggled flag for the visibiligy of the track
    }
    function Toggle_Legend_MolecularMimicryMap( ) { // toggle the legend of the molecular mimicry map graph
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        let l_name_trace = [ ];
        if ( ! dataset.object_plot_BCellCrossReactivity.flag_bool_mode_is_lines ) {
            l_name_trace.push( "B Cell Cross-Reactivity Prediction" ); // add legend of B Cell Cross-reactivity prediction data only when drawing mode is not line
        }
        l_name_trace = l_name_trace.concat( [
            "IEDB_Epitopes__Positive_B_Cell_Assays",
            "IEDB_Epitopes__Positive_T_Cell_Assays",
            "T Cell Cross-Reactivity Prediction (query)",
            "T Cell Cross-Reactivity Prediction (target)",
            "vaccine_design" ] );
        if ( 'vaccine_metric' in dataset ) {
            l_name_trace.push( ... dataset.vaccine_metric.l_name_data );
        }
        let l_index_trace = [ ]; // list of indices for toggling legend labels
        for ( let i = 0; i < l_name_trace.length; i ++ ) {
            let name_trace = l_name_trace[ i ];
            if ( name_trace in dict_name_plot_to_trace_index__MolecularMimicryMap ) {
                l_index_trace.push( dict_name_plot_to_trace_index__MolecularMimicryMap[ name_trace ] );
            }
        }
        if ( l_index_trace.length == 0 ) { console.log( "[Toggle_Legend_MolecularMimicryMap] no traces drawn. exiting." ); return; }
        object_plot_MolecularMimicryMap.showlegend = ! plotMolecularMimicryMap.data[ 0 ].showlegend; // retrieve toggled 'showlegend' status
        Plotly.restyle( plotMolecularMimicryMap, { showlegend : object_plot_MolecularMimicryMap.showlegend }, l_index_trace ); // toggle legend labels
        console.log( "[Toggle_Legend_MolecularMimicryMap] legend labels " + ( object_plot_MolecularMimicryMap.showlegend? "shown" : "hidden" ) );
    }
    
    function Toggle_BCellCrossReactivityPrediction_MolecularMimicryMap( ) { // toggle BCellCrossReactivityPrediction data
        object_plot_BCellCrossReactivity.show = ! $( "#toggle_BCellCrossReactivityPrediction_MolecularMimicryMap" ).hasClass( "active" ); // since it takes some time to modify class label, inversing the toggled state identified here works practically
        console.log( "[Toggle_BCellCrossReactivityPrediction_MolecularMimicryMap] setting visibility to", object_plot_BCellCrossReactivity.show );
        // retrieve indices of traces for the BCellCrossReactivity data
        let l_index_trace_BCellCrossReactivity = [ ];
        for ( let index_trace = object_plot_BCellCrossReactivity.index_trace_start; index_trace < object_plot_BCellCrossReactivity.index_trace_end; index_trace ++ ) { 
            l_index_trace_BCellCrossReactivity.push( index_trace );
        } 
        if ( object_plot_BCellCrossReactivity.dict_data[ "error_x" ].length > 0 ) { 
            if ( ( ! object_plot_BCellCrossReactivity.show ) & object_plot_TCellCrossReactivity.show & ( l_index_trace_BCellCrossReactivity.length == 1 ) ) {
                // will trigger an annoying error with no apparent direct solution (setting visibility of point-type B-cell record to false at AlignmentToquery mode only trigger the error)
                // one roundabout is turning off Tcell record prior to Bcell records (somehow works)
                let l_index_trace_TCellCrossReactivity = [ ];
                for ( let index_trace = object_plot_TCellCrossReactivity.index_trace_start; index_trace < object_plot_TCellCrossReactivity.index_trace_end; index_trace ++ ) { 
                    l_index_trace_TCellCrossReactivity.push( index_trace );
                } 
                Plotly.restyle( plotMolecularMimicryMap, { visible: false }, l_index_trace_TCellCrossReactivity );
                Plotly.restyle( plotMolecularMimicryMap, { visible: false }, l_index_trace_BCellCrossReactivity );
                Plotly.restyle( plotMolecularMimicryMap, { visible: true }, l_index_trace_TCellCrossReactivity );
            } else {
                Plotly.restyle( plotMolecularMimicryMap, { visible: object_plot_BCellCrossReactivity.show }, l_index_trace_BCellCrossReactivity );
            }
        } // set visibility 
    }
    function Toggle_TCellCrossReactivityPrediction_MolecularMimicryMap( ) { // toggle BCellCrossReactivityPrediction data
        object_plot_TCellCrossReactivity.show = ! $( "#toggle_TCellCrossReactivityPrediction_MolecularMimicryMap" ).hasClass( "active" ); // since it takes some time to modify class label, inversing the toggled state identified here works practically
        console.log( "[Toggle_TCellCrossReactivityPrediction_MolecularMimicryMap] setting visibility to", object_plot_TCellCrossReactivity.show );
        let l_index_trace_TCellCrossReactivity = [ dict_name_plot_to_trace_index__MolecularMimicryMap[ "T Cell Cross-Reactivity Prediction (query)" ], dict_name_plot_to_trace_index__MolecularMimicryMap[ "T Cell Cross-Reactivity Prediction (target)" ] ];
        if ( object_plot_TCellCrossReactivity.dict_data[ "error_x" ].length > 0 ) { Plotly.restyle( plotMolecularMimicryMap, { visible: object_plot_TCellCrossReactivity.show }, l_index_trace_TCellCrossReactivity ); } // set visibility 
    }
    
    object_data.flag.gene_highlighted = false; // flag indicating whether a gene is being highlighted on the plot or not
    // setting for highlight
    var float_line_width_when_highlighting = 2, float_line_width_when_not_highlighting = 0, color_when_highlighting = 'black'; // settings for highlighting
    
    object_data.main.highlight = { str_entry: "" }; // storing variables for highlighting records
    function Highlight_Records_MolecularMimicryMap( str_entry, name_dict_str_entry_to_l_index ) { // highlight records according to the given 'l_index', which can be retrieved using 'str_entry' and 'dict_str_entry_to_l_index' with a given 'name_dict_str_entry_to_l_index' at 'object_plot_BCellCrossReactivity' and 'object_plot_TCellCrossReactivity'
        if ( str_entry == object_data.main.highlight.str_entry ) {
            object_data.main.highlight.str_entry = ""; // clear current highlighting
            delete object_plot_BCellCrossReactivity.mask_selected_highlighting; // remove filters
            delete object_plot_TCellCrossReactivity.mask_selected_highlighting;
            Filter_BCellCrossReactivity( ); // update graph
            Filter_TCellCrossReactivity( );
            return;
        } else if ( str_entry.length > 0 ) { // if previous highlighting exists
            
        }
        object_data.main.highlight.str_entry = str_entry; // update entry being highlighted
        
        // update filter for highlighting
        // if str_entry does not exists, use an empty array to build a boolean index
        object_plot_BCellCrossReactivity.mask_selected_highlighting = ArrayBroadCasting( ArrayFull( object_plot_BCellCrossReactivity.arr_data.length, false ), ( str_entry in object_plot_BCellCrossReactivity[ name_dict_str_entry_to_l_index ] ) ? object_plot_BCellCrossReactivity[ name_dict_str_entry_to_l_index ][ str_entry ] : [ ], true ); 
        if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) {
            object_plot_TCellCrossReactivity.mask_selected_highlighting = ArrayBroadCasting( ArrayFull( object_plot_TCellCrossReactivity.arr_data.length, false ), ( str_entry in object_plot_TCellCrossReactivity[ name_dict_str_entry_to_l_index ] ) ? object_plot_TCellCrossReactivity[ name_dict_str_entry_to_l_index ][ str_entry ] : [ ], true ); 
        }
        Filter_BCellCrossReactivity( ); // update graph
        Filter_TCellCrossReactivity( );
    }
    
    function VaccineMetrics_Update_Visibility( ) { // update visibility_for_each_trace and general visibility for current setting
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        let l_name_data = dataset.vaccine_metric.l_name_data, visibility_for_each_trace = ArrayFull( l_name_data.length, false ), dict_name_data_to_index = dataset.vaccine_metric.dict_name_data_to_index; // set visibility of each trace based on the given settings 
        visibility_for_each_trace[ dict_name_data_to_index[ "count_iedb_epitope_with_tcell_assay" ] ] = document.getElementById( "checkbox_toggle_vaccine_metric_iedb_t_cell_assay" ).checked;
        visibility_for_each_trace[ dict_name_data_to_index[ "count_iedb_epitope_with_bcell_assay" ] ] = document.getElementById( "checkbox_toggle_vaccine_metric_iedb_b_cell_assay" ).checked;
        visibility_for_each_trace[ dict_name_data_to_index[ "avg_processing_score_mhc_i" ] ] = document.getElementById( "checkbox_toggle_vaccine_metric_mhc_i_processing_score" ).checked;
        visibility_for_each_trace[ dict_name_data_to_index[ "score_linear_bcell_epitope_prediction__bepipred" ] ] = document.getElementById( "checkbox_toggle_vaccine_metric_bepipred" ).checked;
        visibility_for_each_trace[ dict_name_data_to_index[ "relative_accessible_surface_area" ] ] = document.getElementById( "checkbox_toggle_vaccine_metric_relative_accessible_surface_area" ).checked;
        if ( document.getElementById( "checkbox_toggle_vaccine_metric_count_non_consensus_residue" ).checked ) { visibility_for_each_trace[ dict_name_data_to_index[ document.getElementById( "select_vaccine_metric_count_non_consensus_residue" ).value ] ] = true; }
        if ( document.getElementById( "checkbox_toggle_vaccine_metric_mhc_i_binding_prediction" ).checked ) { visibility_for_each_trace[ dict_name_data_to_index[ document.getElementById( "select_vaccine_metric__mhc_i_binding_peptide_count" ).value ] ] = true; }
        if ( document.getElementById( "checkbox_toggle_vaccine_metric_mhc_ii_binding_prediction" ).checked ) { visibility_for_each_trace[ dict_name_data_to_index[ document.getElementById( "select_vaccine_metric__mhc_ii_binding_peptide_count" ).value ] ] = true; }
        dataset.vaccine_metric.visibility_for_each_trace = visibility_for_each_trace;
    }
    function VaccineMetrics_Apply_Visibility( flag_function_call_within_script = null ) { // apply updated visibility for each trace
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        dataset.vaccine_metric.show = ! $( "#toggle_vaccine_metrics_MolecularMimicryMap" ).hasClass( "active" ); // set general visibility of all vaccine metric traces // inversing the read toggled status works in practice
        if ( flag_function_call_within_script == true ) {
            dataset.vaccine_metric.show = ! dataset.vaccine_metric.show; // if the function is called by another script, do not inverse the flag
        }
        let n_residues = dataset.consensus_sequence_target.accumulated_length;
        if ( ! object_data.flag.vaccine_metric_drawn ) { // draw metrics for vaccine design
            // parse data for displaying vaccine metrics
            console.log( "[VaccineMetrics_Apply_Visibility] Preprocessing of data started" );
            let l_col = Object.keys( dataset.arr_data_acc_target_representative[ 0 ] ); // retrieve list of columns of 'dataset.arr_data_acc_target_representative'
            for ( let i = 0; i < l_col.length; i ++ ) {
                let col = l_col[ i ], l_data = [ ];
                if ( col.slice( 0, 2 ) == 'l_' ) {
                    for ( let j = 0; j < dataset.arr_data_acc_target_representative.length; j ++ ) { l_data.push( ... Unpack_String_Numbers( dataset.arr_data_acc_target_representative[ j ][ col ] ) ); }
                    dataset.vaccine_metric.dict_data[ col.slice( 2 ) ] = l_data;
                } else if ( col.includes( "___ascii_encoding_" ) ) { // concatanate structural data
                    let name_data = col.split( "___ascii_encoding_" )[ 0 ];
                    for ( let j = 0; j < dataset.arr_data_acc_target_representative.length; j ++ ) { 
                        let seq_data = dataset.arr_data_acc_target_representative[ j ][ col ], l_value = [ ];
                        switch ( name_data ) {
                            case "rsa_combined" : 
                                l_value = Unpack_String_rsa_encoded_by_two_char( seq_data );
                                break;
                            case "rsa_datatype_combined" : 
                                l_value = Unpack_String_datatype( seq_data );
                                break;
                            case "ss8_combined" : 
                                l_value = Unpack_String_ss8( seq_data );
                                break;
                        }
                        l_data.push( ... l_value );
                    }
                    dataset.vaccine_metric.dict_data[ { rsa_combined: "relative_accessible_surface_area", rsa_datatype_combined: "type_of_structural_data", ss8_combined: "secondary_structure_classification__dssp_8_states" }[ name_data ] ] = l_data;
                } else { continue; } // only concatanate data from columns starting with 'l_' or containing '___ascii_encoding_'
                dataset.consensus_sequence_target.accumulated_length = l_data.length; // retrieve the length of concatanated target proteins
            }
            dataset.consensus_sequence_target.seq_consensus_concatenated = unpack( dataset.arr_data_acc_target_representative, 'seq_consensus' ).join( '' ); // retrieve concatanated consensus_sequence of target proteins
            let l_name_data = Object.keys( dataset.vaccine_metric.dict_data ); // retrieve list of data tracks
            dataset.vaccine_metric.l_name_data = l_name_data;
            let dict_name_data_to_index = { }, dict_name_data_to_color = { }; // map name_data to index and set colors
            for ( let i = 0; i < l_name_data.length; i ++ ) { 
                let name_data = l_name_data[ i ], color = '#A9A9A9'; // set default color  //'DarkGray'
                dict_name_data_to_index[ name_data ] = i;
                if ( name_data.includes( "count_non_consensus_residue" ) ) { color = "#0000FF"; // "Blue";
                } else if ( name_data.includes( "count_peptide_binding_common_mhc_i_alleles" ) ) { color = "#B22222"; // "FireBrick";
                } else if ( name_data.includes( "count_peptide_binding_common_mhc_ii_alleles" ) ) { color = "#228B22"; // "ForestGreen";
                } else {
                    switch( name_data ) {
                        case "avg_processing_score_mhc_i": color = "#F08080"; break; // "LightCoral"
                        case "score_linear_bcell_epitope_prediction__bepipred": color = "#90EE90"; break; // "LightGreen"
                        case "count_iedb_epitope_with_tcell_assay": color = "#DC143C"; break; // "Crimson"
                        case "count_iedb_epitope_with_bcell_assay": color = "#7FFF00"; break; // "Chartreuse"
                        case "relative_accessible_surface_area": color = "#949494"; // grey
                    }
                }
                dict_name_data_to_color[ name_data ] = color;
            }
            dataset.vaccine_metric.dict_name_data_to_index = dict_name_data_to_index;
            dataset.vaccine_metric.dict_name_data_to_color = dict_name_data_to_color; // set trace color for each name_data

            console.log( "[VaccineMetrics_Apply_Visibility] Preprocessing of data completed" );
            // retrieve traces of vaccine metrics
            VaccineMetrics_Update_Visibility( ) // update visibility from current settings
            let visibility_for_each_trace = dataset.vaccine_metric.visibility_for_each_trace, n_residues = dataset.consensus_sequence_target.accumulated_length; // set visibility of each trace based on the given settings 
            let trace_vaccine_metric_lower_bound = { x : [ 0, n_residues ], y : [ -3, -3 ], type : "scattergl", mode : 'lines', line : { color: '#000000', width: 1 }, showlegend : false, name: "vaccine_metric__lower_bound" }, trace_vaccine_metric_upper_bound = { x : [ 0, n_residues ], y : [ -1, -1 ], type : "scattergl", mode : 'lines', line : { color: '#000000', width: 1 }, showlegend : false, name: "vaccine_metric__upper_bound" };
            dataset.vaccine_metric.data = [ trace_vaccine_metric_lower_bound, trace_vaccine_metric_upper_bound ];  // traces for boundary of vaccine design traces
            let x = nj.arange( n_residues ).tolist( ) // 0-based coordinates
            for ( let i = 0; i < l_name_data.length; i ++ ) {
                let trace = { }, name_data = l_name_data[ i ];
                let l_data = dataset.vaccine_metric.dict_data[ name_data ]; 
                if ( name_data.includes( "count_non_consensus_residue" ) ) { l_data = ArrayCap( l_data, 50 ); } // cap 'count_non_consensus_residue' with a threshold 50 
                let arr_value = nj.array( l_data ); // numjs array of data values
                trace.name = name_data;
                trace.x = x;
                trace.y = arr_value.divide( arr_value.max( ) / 2 ).subtract( 3 ).tolist( ); // vaccine metric traces at ( - 1, -3  )
                trace.customdata = ArrayTranspose( [ ArrayApply( dataset.vaccine_metric.dict_data[ name_data ], String ), nj.array( ArrayMap( x, dataset.consensus_sequence_target.dict_accumulated_coord_to_individual_coord ) ).add( 1 ).tolist( ), ArrayApply( x, function( x ) { return dataset.arr_data_acc_target_representative[ dataset.consensus_sequence_target.dict_accumulated_coord_to_acc_rep[ x ] ].name; } ) ] ); // display actual values on hover
                trace.mode = 'lines';
                trace.type = 'scattergl';
                trace.showlegend = false;
                trace.visible = visibility_for_each_trace[ i ]; // set visibility of traces
                trace.line = { color: dataset.vaccine_metric.dict_name_data_to_color[ name_data ], width: 1 } // set color of traces
                trace.hovertemplate = name_data + ":<br><b>%{customdata[0]}</b><br>at %{customdata[1]:.0f}-th residue of <b>%{customdata[2]}</b><br><extra></extra>"; // set hovertemplate
                dataset.vaccine_metric.data.push( trace );
            }
            console.log( '[VaccineMetrics_Apply_Visibility] plotting vaccine metric traces...' )
            VaccineMetrics_Update_Visibility( ); // update visibility of vaccine metric traces
            l = dataset.vaccine_metric.visibility_for_each_trace;
            for ( let i = 0; i < l.length; i ++ ) { dataset.vaccine_metric.data[ i + 2 ].visible = l[ i ]; } // first two traces are lower and upper boundary of vaccine metric traces
            dataset.vaccine_metric.index_trace_start = plotMolecularMimicryMap.data.length; // record index_start and index_end of traces
            Plotly.addTraces( plotMolecularMimicryMap, lodash.cloneDeep( dataset.vaccine_metric.data ) );
            dataset.vaccine_metric.index_trace_end = plotMolecularMimicryMap.data.length;
            object_data.flag.vaccine_metric_drawn = true; // update the flag
            for( let i = 0; i < plotMolecularMimicryMap.data.length; i ++ ) { dict_name_plot_to_trace_index__MolecularMimicryMap[ plotMolecularMimicryMap.data[ i ].name ] = i; } // update trace_name - index mapping
        }
        VaccineMetrics_Update_Visibility( ) // update visiblity for current settings
        let l_name_data = lodash.cloneDeep( dataset.vaccine_metric.l_name_data );
        l_name_data.push( ... [ 'vaccine_metric__lower_bound', 'vaccine_metric__upper_bound' ] );
        let l_visibility = dataset.vaccine_metric.show ? dataset.vaccine_metric.visibility_for_each_trace.concat( [ true, true ] ) : ArrayFull( l_name_data.length, false ), l_index_trace = [ ];
        for ( let i = 0; i < l_name_data.length; i ++ ) { l_index_trace.push( dict_name_plot_to_trace_index__MolecularMimicryMap[ l_name_data[ i ] ] ); } // retrieve index_trace of VaccineMetrics traces.
        for ( let i = 0; i < l_index_trace.length; i ++ ) {
            let index_trace = l_index_trace[ i ], visibility = l_visibility[ i ];
            if ( plotMolecularMimicryMap.data[ index_trace ].visible != visibility ) { Plotly.restyle( plotMolecularMimicryMap, { visible: visibility }, index_trace ); } // update visibility of individual traces when current visibility is different from updated visibility
        }
    }
            
    
    // named event handlers
    function EventHandler_plotly_relayout_MolecularMimicryMap( data ) {
        console.log( "plotMolecularMimicryMap, plotly_relayout event triggered:", data );
        Set_Visibility_of_Consensus_Protein_Sequence( );
        Adjust_Layout_MolecularMimicryMap( );
    }
    function EventHandler_plotly_restyle_MolecularMimicryMap( data ) {
        console.log( "plotMolecularMimicryMap, plotly_restyle event triggered:", data );
        Adjust_Layout_MolecularMimicryMap( );
    }
    
    async function Adjust_Layout_MolecularMimicryMap( mode ) { // adjust layout of molecular mimicry graph based on plot height and y-axis range
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ];
        return new Promise ( async function( resolve, reject ) {
            // retrieve 0-based coodinates
            let l_y_range = plotMolecularMimicryMap.layout.yaxis.range, 
                y_floor = l_y_range[ 0 ], 
                y_ceiling = l_y_range[ 1 ], 
                y_axis_size = y_ceiling - y_floor, 
                l_anno = [ ], 
                bool_flag_y_axis_changed = ( object_plot_MolecularMimicryMap.layout.y_floor != y_floor ) || ( object_plot_MolecularMimicryMap.layout.y_ceiling != y_ceiling );
            let l_x_range = plotMolecularMimicryMap.layout.xaxis.range, 
                x_left = parseInt( Math.max( 0, l_x_range[ 0 ] ) ),
                x_right = parseInt( Math.min( l_x_range[ 1 ], object_data.plot.consensus_sequence.accumulated_length - 1 ) ), 
                x_axis_size = x_right - x_left, 
                bool_flag_x_axis_changed = ( object_plot_MolecularMimicryMap.layout.x_left != x_left ) || ( object_plot_MolecularMimicryMap.layout.x_right != x_right );
            if ( true && ( object_plot_BCellCrossReactivity.show || object_plot_TCellCrossReactivity.show ) ) { // if Cross-Reactivity prediction data are being shown and y-axis range has been changed or y-axis-label has not been drawn, adjust y-axis label
                console.log( "[Adjust_Layout_MolecularMimicryMap] change in y-axis detected. Adjusting annotations in the layout" );
                object_plot_MolecularMimicryMap.layout.y_floor = y_floor; // update y axis range
                object_plot_MolecularMimicryMap.layout.y_ceiling = y_ceiling;    
                l_anno.push( {
                        font: { size: 15 },
                        xanchor: "left",
                        yanchor: "middle",
                        xref: "paper", x: 0,
                        yref: 'paper', y: ( 1 + ( - y_floor ) / y_axis_size ) / 2,
                        textangle: - 90,
                        xshift: - layout_MolecularMimicryMap.margin.l - 5,
                        text: ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) ? `(B Cell) ${dataset.object_plot_BCellCrossReactivity.y_axis.label}<br>(T Cell) ${dataset.object_plot_TCellCrossReactivity.y_axis.label}` : `(B Cell) ${dataset.object_plot_BCellCrossReactivity.y_axis.label}`,
                        showarrow: false
                      } ); // update y-axis labal annotation
            }
            if ( true ) {
                console.log( "[Adjust_Layout_MolecularMimicryMap] change in x-axis detected. Adjusting annotations in the layout" );
                // show start and end position of the window
                let str_anno = "";
                object_plot_MolecularMimicryMap.layout.x_left = x_left; // update x axis range
                object_plot_MolecularMimicryMap.layout.x_right = x_right;    
                if ( object_data.flag.alignment_to_target ) {
                    let anno_protein_target_left = dataset.arr_data_acc_target_representative[ dataset.consensus_sequence_target.dict_accumulated_coord_to_acc_rep[ x_left ] ], 
                        anno_protein_target_right = dataset.arr_data_acc_target_representative[ dataset.consensus_sequence_target.dict_accumulated_coord_to_acc_rep[ x_right ] ];
                    let pos_protein_target_left = dataset.consensus_sequence_target.dict_accumulated_coord_to_individual_coord[ x_left ] + 1, 
                        pos_protein_target_right = dataset.consensus_sequence_target.dict_accumulated_coord_to_individual_coord[ x_right ] + 1;
                    str_anno = ( anno_protein_target_left.name == anno_protein_target_right.name ) ? anno_protein_target_left.name + " " + pos_protein_target_left + "-" + pos_protein_target_right + "/" + anno_protein_target_left.length : anno_protein_target_left.name + " " + pos_protein_target_left + "/" + anno_protein_target_left.length + " ... " + anno_protein_target_right.name + " " + pos_protein_target_right + "/" + anno_protein_target_right.length; 
                } else {
                    str_anno = `${object_plot_MolecularMimicryMap.query_gene_symbol_of_interest} ${x_left + 1}-${x_right}`; // 1-based coodinates
                }
                l_anno.push( {
                        font: { size: 18 },
                        xanchor: "left",
                        yanchor: "top",
                        xref: "paper", x: 0,
                        yref: 'paper', y: 1,
                        textangle: 0,
                        xshift: 0,
                        text: str_anno,
                        showarrow: false
                      } ); // update y-axis labal annotation
            }
            if ( ( "vaccine_design" in dict_name_plot_to_trace_index__MolecularMimicryMap ) && dataset.vaccine_design.show ) { // while vaccine_design trace is on display
                let index_trace_vaccine_design = dict_name_plot_to_trace_index__MolecularMimicryMap[ "vaccine_design" ], name_y_value = dataset.vaccine_design.name_y_axis;
                if ( true || mode == "vaccine_design_y_axis_updated" || name_y_value != dataset.vaccine_design.plotly.name_y_value || bool_flag_y_axis_changed ) {
                    console.log( "[Adjust_Layout_MolecularMimicryMap] change of y-axis name of vaccine_design trace or change of y-axis range was detected while vaccine_design trace is on display. Adjusting annotations in the layout" );
                    dataset.vaccine_design.plotly.name_y_value = name_y_value; // update name_y_value
                    if ( ! ( "dict_max_value" in dataset.vaccine_design.plotly ) ) { dataset.vaccine_design.plotly.dict_max_value = { }; }
                    if ( ! ( name_y_value in dataset.vaccine_design.plotly.dict_max_value ) || mode == "vaccine_design_y_axis_updated" ) { // retrieve the max_value of the values of 'name_y_value' data if the data does not exist of y_axis values have been updated.
                        dataset.vaccine_design.plotly.dict_max_value[ name_y_value ] = Math.max( ... dataset.vaccine_design.plotly.y );
                    }
                    let y_value_max = dataset.vaccine_design.plotly.dict_max_value[ name_y_value ];
                    l_anno.push( ... [{
                        font: { size: 12 },
                        xref: 'paper', yref: 'paper',
                        x: 0,
                        xanchor: 'left',
                        y: ( - 4 - y_floor ) / y_axis_size,
                        yanchor: 'top',
                        text: 'Max = ' + ( CheckInt( y_value_max ) ? String( y_value_max ) : y_value_max.toFixed( 3 ) ),
                        xshift: - 30,
                        showarrow: false
                      }, {
                        font: { size: 12 },
                        xref: 'paper', yref: 'paper',
                        x: 0,
                        xanchor: 'left',
                        y: ( - 6 - y_floor ) / y_axis_size,
                        yanchor: 'bottom',
                        text: 'Min = ' + String( 0 ),
                        xshift: - 30,
                        showarrow: false
                      }] );
                }
            }
//             if ( l_anno.length == 0 ) { return; } // if no relavant change was detected, do not update layout
            plotMolecularMimicryMap.removeAllListeners( "plotly_relayout" ); // remove event listeners to avoid infinite event propagation
            plotMolecularMimicryMap.removeAllListeners( "plotly_restyle" ); 
            await Plotly.relayout( plotMolecularMimicryMap, { annotations: l_anno });
            plotMolecularMimicryMap.on( "plotly_relayout", EventHandler_plotly_relayout_MolecularMimicryMap );
            plotMolecularMimicryMap.on( "plotly_restyle", EventHandler_plotly_restyle_MolecularMimicryMap );
            console.log( "[Adjust_Layout_MolecularMimicryMap] annotations adjusted." ); // add listeners back
            resolve( "[Adjust_Layout_MolecularMimicryMap] annotations adjusted." );
        }); 
    }

    // Mol* JS molecule renderer
    //Create plugin instance
    var pdbqueryProtein = new PDBeMolstarPlugin( );
    var pdbtargetProtein = new PDBeMolstarPlugin( );

    //Get element from HTML/Template to place the viewer 
    var pdbqueryProteinContainer = document.getElementById( 'PDB_Viewer_query_Protein' );
    var pdbtargetProteinContainer = document.getElementById( 'PDB_Viewer_target_Protein' );
    //Call render method to display the 3D view
    str_jquery_container = "#container_PDB";
    if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { 
        pdbqueryProtein.render( pdbqueryProteinContainer, option_initialization_molstar ); pdbtargetProtein.render( pdbtargetProteinContainer, option_initialization_molstar ); // draw Plotly plot synchronously if the container is currently shown
        pdbqueryProtein.visual.setColor( { highlight: color_pdb_highlight } ); pdbtargetProtein.visual.setColor( { highlight: color_pdb_highlight } ); // set highlight colors
    } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { // draw Plotly plot once the container is shown if the container is currently hidden
        pdbqueryProtein.render( pdbqueryProteinContainer, option_initialization_molstar ); 
        pdbtargetProtein.render( pdbtargetProteinContainer, option_initialization_molstar );
        Promise.all( [ MolStarRenderCompletePromise( pdbqueryProtein ), MolStarRenderCompletePromise( pdbtargetProtein ) ] ).then( ( ) => { $( "#container_PDB" ).collapse( 'show' ); pdbqueryProtein.visual.setColor( { highlight: color_pdb_highlight } ); pdbtargetProtein.visual.setColor( { highlight: color_pdb_highlight } ); } ); // // hide Mol* viewers once initialization on both viewer instances are completed
    } ); }  
    var l_exclusive_tab = [ "#plotly_graph_b_cell_cross_reactivity", "#plotly_graph_t_cell_cross_reactivity", "#plotly_graph_query_protein", "#container_datatable_panel_MolecularMimicryMap" ], 
        target_tab_among_exclusive_tabs = "";
    function Toggle_Exclusive_Tabs( tab_target ) { 
        target_tab_among_exclusive_tabs = tab_target; // make the target tab name globaly available
        if ( tab_target == "hide_all" ) { for ( let tab of l_exclusive_tab ) { $( tab ).collapse( 'hide' ); } return; } // hide all tabs if tab_target == "hide_all"
        let l_bool_flag_need_change = [ ];
        for ( let tab of l_exclusive_tab ) {
            l_bool_flag_need_change.push( tab == tab_target ? ! ( $( tab ).hasClass( "show" ) ) : $( tab ).hasClass( "show" ) );
        }
        if ( ArraySum( l_bool_flag_need_change ) > 0 ) { // if tab_target is not opened, open the tab
            for ( let tab of l_exclusive_tab ) {
                if( tab == tab_target ) { 
                    BootstrapCollapseShownPromise( tab )
                        .then( ( ) => { 
                        // draw plot if not drawn ofter a dataset has been loaded.
                        switch( target_tab_among_exclusive_tabs ) {
                            case "#plotly_graph_b_cell_cross_reactivity" :
                                if ( ! object_data.flag.bcellmetrics_plot_is_drawn ) {
                                    DrawBCellCrossReactivityPredMetricsPlot( );
                                    object_data.flag.bcellmetrics_plot_is_drawn = true;
                                }
                                break;
                            case "#plotly_graph_t_cell_cross_reactivity" :
                                if ( ! object_data.flag.tcellmetrics_plot_is_drawn ) {
                                    DrawTCellCrossReactivityPredMetricsPlot( );
                                    object_data.flag.tcellmetrics_plot_is_drawn = true;
                                }
                                break;
                            case "#plotly_graph_query_protein" :
                                if ( ! object_data.flag.queryproteinmetrics_plot_is_drawn ) {
                                    DrawqueryProteinMetricsPlot( );
                                    object_data.flag.queryproteinmetrics_plot_is_drawn = true;
                                }
                                break;
                            case "#container_datatable_panel_MolecularMimicryMap" :
                                break;
                        }
                        window.dispatchEvent( new Event( 'resize' ) ); // trigger resize events to allow Plotly plot to resize its plot
                    } );
                } 
                else { $( tab ).collapse( 'hide' ); }
            }
        } else { $( tab_target ).collapse( 'hide' ); } // if tab_target is already opened, close the tab
         
    }
    var target_tab_being_toggled = "";
    function Toggle_Panel( tab, flag_function_call_within_script = null ) { // toggle a collapsable panel containing Plotly plots
        target_tab_being_toggled = tab 
        if ( ! ( $( tab ).hasClass( "show" ) ) ) {
            BootstrapCollapseShownPromise( tab ).then( ( ) => { 
                // draw plot if not drawn ofter a dataset has been loaded.
                switch( target_tab_being_toggled ) {
                    case "#container_expression_panel_MolecularMimicryMap" :
                    case "#container_plotly_scrnaseq" :
                    case "#container_plotly_gtex" :
                        UpdatePlotExpression( ); // update plots showing expression of genes when collapse/show status of the containers are changed
                        break;
                }
                window.dispatchEvent( new Event( 'resize' ) );
            } );
        } // trigger resize events to allow Plotly plot to resize its plot
        else { $( tab ).collapse( 'hide' ); } // if the tab is already opened, close the tab
    }
    function Toggle_div( id_div ) {
        var div = document.getElementById( id_div );
        if ( div.style.display == "none" ) { div.style.display = "block"; } 
        else { div.style.display = "none"; }
    }
    var flag_tooltip_active_Toggle_Tooltips = true;
    function Toggle_Tooltips(  ) {
        console.log( "[Toggle_Tooltips] Tooltips toggled to ", flag_tooltip_active_Toggle_Tooltips )
        flag_tooltip_active_Toggle_Tooltips = ! flag_tooltip_active_Toggle_Tooltips; // toggle the flag
        if ( flag_tooltip_active_Toggle_Tooltips ) { $('[data-tooltip="tooltip"]').tooltip( 'enable' ); }
        else { $('[data-tooltip="tooltip"]').tooltip( 'disable' ); }
    }
    
    var color_non_selected = "#fcfcfc"; // color of residues that are not selected
    function Select_View_of_PDB_target_Protein( ) {
        switch ( document.getElementById( "select_PDB_target_protein_structure" ).value ) {
            case "Clear" : 
                pdbtargetProtein.visual.clearSelection( );
                break;
            case "BLOSUM62 Score" : 
                pdbtargetProtein.visual.select( { data: object_pdb_target.selection, nonSelectedColor: { r:255, g:255, b:255 } } );
                break;
            case "BLOSUM62 Score with Side Chains" : 
                pdbtargetProtein.visual.select( { data: object_pdb_target.selection_showing_side_chain, nonSelectedColor: { r:255, g:255, b:255 } } );
                break;
            default : break;
        }
    }
    function Select_View_of_PDB_query_Protein( ) {
        switch ( document.getElementById( "select_PDB_query_protein_structure" ).value ) {
            case "Clear" : 
                pdbqueryProtein.visual.clearSelection( );
                break;
            case "BLOSUM62 Score" : 
                pdbqueryProtein.visual.select( { data: object_pdb_query.selection, nonSelectedColor: { r:255, g:255, b:255 } } );
                break;
            case "BLOSUM62 Score with Side Chains" : 
                pdbqueryProtein.visual.select( { data: object_pdb_query.selection_showing_side_chain, nonSelectedColor: { r:255, g:255, b:255 } } );
                break;
            default : break;
        }
    }
    
    // Get the button_scroll_to_the_top:
    button_scroll_to_the_top = document.getElementById( "button_scroll_to_the_top" );
    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function( ) { scrollFunction( ) };
    function scrollFunction( ) {
      if ( document.body.scrollTop > 20 || document.documentElement.scrollTop > 20 ) { button_scroll_to_the_top.style.display = "block"; }
      else { button_scroll_to_the_top.style.display = "none"; }
    }
    // When the user clicks on the button, scroll to the top of the document
    function Scroll_to_the_Top() {
      document.body.scrollTop = 0; // For Safari
      document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
    }
    function Scroll_to_the_Bottom() {
      $( document ).scrollTop( $( document ).height( ) ); // scroll to the bottom
    }

</script>
</body>
</html>
